    1                   ;       MS-BASIC START UP ROUTINE
    2                   ;       TARGET: SUPER AKI-80
    3                   ;       ASSEMBLER: ARCPIT XZ80.EXE
    4                   ;
    5 80ED              TSTACK     EQU      80EDH
    6                   ;
    7 0013              PCTCC3     EQU      13H
    8 0018              PSIOAD     EQU      18H
    9 0019              PSIOAC     EQU      19H
   10 001A              PSIOBD     EQU      1AH
   11 001B              PSIOBC     EQU      1BH
   12                   ;
   13 000D              CR         EQU      0DH
   14 000A              LF         EQU      0AH
   15                   ;
   16                   ;       SYSTEM PARAMETERS
   17 8000                         ORG      08000H
   18 8000              RBFCNT     DS       01H
   19 8001              RBFRDP     DS       01H
   20 8002              RBFWTP     DS       01H
   21 8003              RECBUF     DS       40H
   22                   ;
   23                   ;
   24                   ;       RESET VECTOR
   25 0000                         ORG      0000H
   26 0000 F3           RST00:     DI
   27 0001 C3A000                  JP       SINIT
   28                   ;
   29                   ;       RESTART VECTOR
   30 0008                         ORG      0008H
   31 0008 C37100       RST08:     JP       TXA
   32 0010                         ORG      0010H
   33 0010 C34B00       RST10:     JP       RXA
   34 0018                         ORG      0018H
   35 0018 C37C00       RST18:     JP       KBHIT
   36                   ;
   37                   ;       SIOA -> BUFFER BY INTERRUPT
   38 001B              INTRCV:
   39 001B F5                      PUSH     AF
   40 001C C5                      PUSH     BC
   41 001D D5                      PUSH     DE
   42 001E E5                      PUSH     HL
   43 001F DB19                    IN       A,(PSIOAC)  ;CHECK RECEIVE
   44 0021 CB47                    BIT      0,A         ;IF NOT
   45 0023 281F                    JR       Z,RWTEXT    ;EXIT
   46 0025 DB18                    IN       A,(PSIOAD)  ;GET DATA
   47 0027 57                      LD       D,A         ;SAVE TO D
   48 0028 3A0080                  LD       A,(RBFCNT)  ;GET COUNT
   49 002B FE40                    CP       40H         ;IF BUFFER FULL
   50 002D 2815                    JR       Z,RWTEXT    ;EXIT(GIVE UP!)
   51 002F 3C           STRWT3:    INC      A           ;COUNT UP
   52 0030 320080                  LD       (RBFCNT),A  ;COUNT UPDATE
   53 0033 3A0280                  LD       A,(RBFWTP)  ;GET OFFSET
   54 0036 4F                      LD       C,A         ;C, OFFSET LOW
   55 0037 0600                    LD       B,00H       ;B, OFFSET HIGH
   56 0039 210380                  LD       HL,RECBUF   ;HL, BUFFER TOP
   57 003C 09                      ADD      HL,BC       ;HL, WRITE POINT IN BUF
   58 003D 72                      LD       (HL),D      ;WRITE DATA
   59 003E 3C                      INC      A           ;OFFSET INCREMENT
   60 003F E63F                    AND      3FH         ;WRAP
   61 0041 320280                  LD       (RBFWTP),A  ;OFFSET UPDATE
   62 0044 E1           RWTEXT:    POP      HL
   63 0045 D1                      POP      DE
   64 0046 C1                      POP      BC
   65 0047 F1                      POP      AF
   66 0048 FB                      EI
   67 0049 ED4D                    RETI
   68                   ;
   69                   ;       BUFER -> A
   70 004B              RXA:
   71 004B C5                      PUSH     BC
   72 004C D5                      PUSH     DE
   73 004D E5                      PUSH     HL
   74 004E              LOPRBR:
   75 004E 3A0080                  LD       A,(RBFCNT)  ;GET COUNT
   76 0051 FE00                    CP       00H         ;CHECK RECEIVE
   77 0053 28F9                    JR       Z,LOPRBR    ;WAIT FOR RECEIVE
   78 0055 F3                      DI                   ;DISABLE INTERRUPT
   79 0056 3D                      DEC      A           ;COUNT DOWN
   80 0057 320080                  LD       (RBFCNT),A  ;COUNT UPDATE
   81 005A 3A0180                  LD       A,(RBFRDP)  ;GET OFFSET
   82 005D 4F                      LD       C,A         ;C, OFFSET LOW
   83 005E 0600                    LD       B,00H       ;B, OFFSET HIGH
   84 0060 210380                  LD       HL,RECBUF   ;HL, BUFFER TOP
   85 0063 09                      ADD      HL,BC       ;HL, READ POINT IN BUFF
   86 0064 56                      LD       D,(HL)      ;READ DATA
   87 0065 3C                      INC      A           ;OFFSET INCREMENT
   88 0066 E63F                    AND      3FH         ;WRAP
   89 0068 320180                  LD       (RBFRDP),A  ;OFFSET UPDATE
   90 006B 7A                      LD       A,D         ;GET DATA
   91 006C FB                      EI                   ;ENABLE INTERRUPT
   92 006D E1                      POP      HL
   93 006E D1                      POP      DE
   94 006F C1                      POP      BC
   95 0070 C9                      RET
   96                   ;
   97                   ;       A -> SIO
   98 0071 F5           TXA:       PUSH     AF          ;SAVE DATA
   99 0072 DB19         TXLOOP:    IN       A,(PSIOAC)  ;CHECK STATUS
  100 0074 CB57                    BIT      2,A         ;IF BUFFER NOT EMPTY
  101 0076 28FA                    JR       Z,TXLOOP    ;WAIT FOR EMPTY
  102 0078 F1                      POP      AF          ;RESTORE DATA
  103 0079 D318                    OUT      (PSIOAD),A  ;TRANSFER
  104 007B C9                      RET
  105                   ;
  106                   ;       CHECK RECEIVE STATUS
  107 007C 3A0080       KBHIT:     LD       A,(RBFCNT)
  108 007F FE00                    CP       00H
  109 0081 C9                      RET
  110                   ;
  111                   ;       INTERRUPT VECTORS
  112 0090                         ORG      (($-1) AND 0FFF0H) + 10H
  113 0090 1B00         INTVCT:    DW       INTRCV
  114                   ;
  115                   ;       SIOA COMMAND CHAIN
  116 0092              SIOACD:
  117 0092 18                      DB       00011000B   ;RESET
  118 0093 0110                    DB       01H,00010000B ;RX INTERRUPT ENABLE
  119 0095 0444                    DB       04H,01000100B ;FORMAT
  120 0097 05EA                    DB       05H,11101010B ;TX ENABLE
  121 0099 03C1                    DB       03H,11000001B ;RX ENABLE
  122 0009              SIOACL     EQU      $-SIOACD
  123                   ;
  124                   ;       SIOB COMMAND CHAIN
  125 009B              SIOBCD:
  126 009B 18                      DB       00011000B   ;RESET
  127 009C 0100                    DB       01H,00000000B ;DISABLE STATUS/AFFEC
  128 009E 0290                    DB       02H,INTVCT AND 00FFH ;SET INTERRUPT
  129 0005              SIOBCL     EQU      $-SIOBCD
  130                   ;
  131                   ;       SYSTEM INITIALIZE
  132 00A0 31ED80       SINIT:     LD       SP,TSTACK
  133 00A3 AF                      XOR      A
  134 00A4 320080                  LD       (RBFCNT),A
  135 00A7 320180                  LD       (RBFRDP),A
  136 00AA 320280                  LD       (RBFWTP),A
  137                   ;
  138                   ;       CTC INITIALIZE
  139 00AD 3E07                    LD       A,00000111B
  140 00AF D313                    OUT      (PCTCC3),A
  141 00B1 3E04                    LD       A,4         ;9.8304MHz
  142                   ;       LD      A,3             ;7.3728MHz
  143                   ;       LD      A,2             ;4.9152MHz
  144                   ;       LD      A,1             ;2.4576MHz
  145 00B3 D313                    OUT      (PCTCC3),A
  146                   ;
  147                   ;       SIO INITIALIZE
  148 00B5 0609                    LD       B,SIOACL    ;LENGTH
  149 00B7 0E19                    LD       C,PSIOAC    ;I/O ADDRESS
  150 00B9 219200                  LD       HL,SIOACD   ;COMMAND ADDRESS
  151 00BC EDB3                    OTIR
  152 00BE 0605                    LD       B,SIOBCL    ;LENGTH
  153 00C0 0E1B                    LD       C,PSIOBC    ;I/O ADDRESS
  154 00C2 219B00                  LD       HL,SIOBCD   ;COMMAND ADDRESS
  155 00C5 EDB3                    OTIR
  156                   ;
  157                   ;       SETUP INTERRUPT
  158 00C7 219000                  LD       HL,INTVCT
  159 00CA 7C                      LD       A,H
  160 00CB ED47                    LD       I,A
  161 00CD ED5E                    IM       2
  162 00CF FB                      EI
  163                   ;
  164                   ;       START BASIC
  165 00D0 C3D300                  JP       COLD
  166                   ;
  167                   ;======================================================
  168                   ; The updates to the original BASIC within this file ar
  169                   ;
  170                   ; You have permission to use this for NON COMMERCIAL US
  171                   ; If you wish to use it elsewhere, please include an ac
  172                   ;
  173                   ; http://searle.hostei.com/grant/index.html
  174                   ;
  175                   ; eMail: home.micros01@btinternet.com
  176                   ;
  177                   ; If the above don't work, please perform an Internet s
  178                   ; updated the web page hosting service.
  179                   ;
  180                   ;======================================================
  181                   ;
  182                   ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
  183                   ; Scanned from source published in 80-BUS NEWS from Vol
  184                   ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
  185                   ; Adapted for the freeware Zilog Macro Assembler 2.10 t
  186                   ; the original ROM code (checksum A934H). PA
  187                   ;
  188                   ; GENERAL EQUATES
  189                   ;
  190 0003              CTRLC      EQU      03H         ; Control "C"
  191 0007              CTRLG      EQU      07H         ; Control "G"
  192 0008              BKSP       EQU      08H         ; Back space
  193 000A              LF         EQU      0AH         ; Line feed
  194 000C              CS         EQU      0CH         ; Clear screen
  195 000D              CR         EQU      0DH         ; Carriage return
  196 000F              CTRLO      EQU      0FH         ; Control "O"
  197 0011              CTRLQ      EQU      11H         ; Control "Q"
  198 0012              CTRLR      EQU      12H         ; Control "R"
  199 0013              CTRLS      EQU      13H         ; Control "S"
  200 0015              CTRLU      EQU      15H         ; Control "U"
  201 001B              ESC        EQU      1BH         ; Escape
  202 007F              DEL        EQU      7FH         ; Delete
  203                   ;
  204                   ; BASIC WORK SPACE LOCATIONS
  205                   ;
  206 8045              WRKSPC     EQU      8045H       ; BASIC Work space
  207 8048              USR        EQU      WRKSPC+3H   ; "USR (x)" jump
  208 804B              OUTSUB     EQU      WRKSPC+6H   ; "OUT p,n"
  209 804C              OTPORT     EQU      WRKSPC+7H   ; Port (p)
  210 804E              DIVSUP     EQU      WRKSPC+9H   ; Division support rout
  211 804F              DIV1       EQU      WRKSPC+0AH  ; <- Values
  212 8053              DIV2       EQU      WRKSPC+0EH  ; <- to
  213 8057              DIV3       EQU      WRKSPC+12H  ; <- be
  214 805A              DIV4       EQU      WRKSPC+15H  ; <- inserted
  215 805C              SEED       EQU      WRKSPC+17H  ; Random number seed
  216 807F              LSTRND     EQU      WRKSPC+3AH  ; Last random number
  217 8083              INPSUB     EQU      WRKSPC+3EH  ; #INP (x)" Routine
  218 8084              INPORT     EQU      WRKSPC+3FH  ; PORT (x)
  219 8086              NULLS      EQU      WRKSPC+41H  ; Number of nulls
  220 8087              LWIDTH     EQU      WRKSPC+42H  ; Terminal width
  221 8088              COMMAN     EQU      WRKSPC+43H  ; Width for commas
  222 8089              NULFLG     EQU      WRKSPC+44H  ; Null after input byte
  223 808A              CTLOFG     EQU      WRKSPC+45H  ; Control "O" flag
  224 808B              LINESC     EQU      WRKSPC+46H  ; Lines counter
  225 808D              LINESN     EQU      WRKSPC+48H  ; Lines number
  226 808F              CHKSUM     EQU      WRKSPC+4AH  ; Array load/save check
  227 8091              NMIFLG     EQU      WRKSPC+4CH  ; Flag for NMI break ro
  228 8092              BRKFLG     EQU      WRKSPC+4DH  ; Break flag
  229 8093              RINPUT     EQU      WRKSPC+4EH  ; Input reflection
  230 8096              POINT      EQU      WRKSPC+51H  ; "POINT" reflection (u
  231 8099              PSET       EQU      WRKSPC+54H  ; "SET" reflection
  232 809C              RESET      EQU      WRKSPC+57H  ; "RESET" reflection
  233 809F              STRSPC     EQU      WRKSPC+5AH  ; Bottom of string spac
  234 80A1              LINEAT     EQU      WRKSPC+5CH  ; Current line number
  235 80A3              BASTXT     EQU      WRKSPC+5EH  ; Pointer to start of p
  236 80A6              BUFFER     EQU      WRKSPC+61H  ; Input buffer
  237 80AB              STACK      EQU      WRKSPC+66H  ; Initial stack
  238 80F0              CURPOS     EQU      WRKSPC+0ABH ; Character position on
  239 80F1              LCRFLG     EQU      WRKSPC+0ACH ; Locate/Create flag
  240 80F2              TYPE       EQU      WRKSPC+0ADH ; Data type flag
  241 80F3              DATFLG     EQU      WRKSPC+0AEH ; Literal statement fla
  242 80F4              LSTRAM     EQU      WRKSPC+0AFH ; Last available RAM
  243 80F6              TMSTPT     EQU      WRKSPC+0B1H ; Temporary string poin
  244 80F8              TMSTPL     EQU      WRKSPC+0B3H ; Temporary string pool
  245 8104              TMPSTR     EQU      WRKSPC+0BFH ; Temporary string
  246 8108              STRBOT     EQU      WRKSPC+0C3H ; Bottom of string spac
  247 810A              CUROPR     EQU      WRKSPC+0C5H ; Current operator in E
  248 810C              LOOPST     EQU      WRKSPC+0C7H ; First statement of lo
  249 810E              DATLIN     EQU      WRKSPC+0C9H ; Line of current DATA 
  250 8110              FORFLG     EQU      WRKSPC+0CBH ; "FOR" loop flag
  251 8111              LSTBIN     EQU      WRKSPC+0CCH ; Last byte entered
  252 8112              READFG     EQU      WRKSPC+0CDH ; Read/Input flag
  253 8113              BRKLIN     EQU      WRKSPC+0CEH ; Line of break
  254 8115              NXTOPR     EQU      WRKSPC+0D0H ; Next operator in EVAL
  255 8117              ERRLIN     EQU      WRKSPC+0D2H ; Line of error
  256 8119              CONTAD     EQU      WRKSPC+0D4H ; Where to CONTinue
  257 811B              PROGND     EQU      WRKSPC+0D6H ; End of program
  258 811D              VAREND     EQU      WRKSPC+0D8H ; End of variables
  259 811F              ARREND     EQU      WRKSPC+0DAH ; End of arrays
  260 8121              NXTDAT     EQU      WRKSPC+0DCH ; Next data item
  261 8123              FNRGNM     EQU      WRKSPC+0DEH ; Name of FN argument
  262 8125              FNARG      EQU      WRKSPC+0E0H ; FN argument value
  263 8129              FPREG      EQU      WRKSPC+0E4H ; Floating point regist
  264 812C              FPEXP      EQU      FPREG+3     ; Floating point expone
  265 812D              SGNRES     EQU      WRKSPC+0E8H ; Sign of result
  266 812E              PBUFF      EQU      WRKSPC+0E9H ; Number print buffer
  267 813B              MULVAL     EQU      WRKSPC+0F6H ; Multiplier
  268 813E              PROGST     EQU      WRKSPC+0F9H ; Start of program text
  269 81A2              STLOOK     EQU      WRKSPC+15DH ; Start of memory test
  270                   ;
  271                   ; BASIC ERROR CODE VALUES
  272                   ;
  273 0000              NF         EQU      00H         ; NEXT without FOR
  274 0002              SN         EQU      02H         ; Syntax error
  275 0004              RG         EQU      04H         ; RETURN without GOSUB
  276 0006              OD         EQU      06H         ; Out of DATA
  277 0008              FC         EQU      08H         ; Function call error
  278 000A              OV         EQU      0AH         ; Overflow
  279 000C              OM         EQU      0CH         ; Out of memory
  280 000E              UL         EQU      0EH         ; Undefined line number
  281 0010              BS         EQU      10H         ; Bad subscript
  282 0012              RD         EQU      12H         ; Re-DIMensioned array
  283 0014              DZ         EQU      14H         ; Division by zero (/0)
  284 0016              ID         EQU      16H         ; Illegal direct
  285 0018              TM         EQU      18H         ; Type miss-match
  286 001A              OS         EQU      1AH         ; Out of string space
  287 001C              LS         EQU      1CH         ; String too long
  288 001E              ST         EQU      1EH         ; String formula too co
  289 0020              CN         EQU      20H         ; Can't CONTinue
  290 0022              UF         EQU      22H         ; UnDEFined FN function
  291 0024              MO         EQU      24H         ; Missing operand
  292 0026              HX         EQU      26H         ; HEX error
  293 0028              BN         EQU      28H         ; BIN error
  294                   ;
  295 00D3 C3D900       COLD:      JP       STARTB      ; Jump for cold start
  296 00D6 C34E01       WARM:      JP       WARMST      ; Jump for warm start
  297 00D9 C3E000       STARTB:    JP       CSTART      ; Jump to initialise
  298                   ;
  299 00DC 9109                    DW       DEINT       ; Get integer -32768 to
  300 00DE 0711                    DW       ABPASS      ; Return integer in AB
  301                   ;
  302 00E0 214580       CSTART:    LD       HL,WRKSPC   ; Start of workspace RA
  303 00E3 F9                      LD       SP,HL       ; Set up a temporary st
  304 00E4 C3221D                  JP       INITST      ; Go to initialise
  305                   ;
  306 00E7 11B803       INIT:      LD       DE,INITAB   ; Initialise workspace
  307 00EA 0663                    LD       B,INITBE-INITAB+3 ; Bytes to copy
  308 00EC 214580                  LD       HL,WRKSPC   ; Into workspace RAM
  309 00EF 1A           COPY:      LD       A,(DE)      ; Get source
  310 00F0 77                      LD       (HL),A      ; To destination
  311 00F1 23                      INC      HL          ; Next destination
  312 00F2 13                      INC      DE          ; Next source
  313 00F3 05                      DEC      B           ; Count bytes
  314 00F4 C2EF00                  JP       NZ,COPY     ; More to move
  315 00F7 F9                      LD       SP,HL       ; Temporary stack
  316 00F8 CDB905                  CALL     CLREG       ; Clear registers and s
  317 00FB CD870B                  CALL     PRCRLF      ; Output CRLF
  318 00FE 32EF80                  LD       (BUFFER+72+1),A ; Mark end of buffe
  319 0101 323E81                  LD       (PROGST),A  ; Initialise program ar
  320 0104 21A281       MSIZE:     LD       HL,STLOOK   ; Point to start of RAM
  321 0107 23           MLOOP:     INC      HL          ; Next byte
  322 0108 7C                      LD       A,H         ; Above address FFFF ?
  323 0109 B5                      OR       L
  324 010A CA1601                  JP       Z,SETTOP    ; Yes - 64K RAM
  325 010D 7E                      LD       A,(HL)      ; Get contents
  326 010E 47                      LD       B,A         ; Save it
  327 010F 2F                      CPL                  ; Flip all bits
  328 0110 77                      LD       (HL),A      ; Put it back
  329 0111 BE                      CP       (HL)        ; RAM there if same
  330 0112 70                      LD       (HL),B      ; Restore old contents
  331 0113 CA0701                  JP       Z,MLOOP     ; If RAM - test next by
  332                   ;
  333 0116 2B           SETTOP:    DEC      HL          ; Back one byte
  334 0117 11A181                  LD       DE,STLOOK-1 ; See if enough RAM
  335 011A CD4F07                  CALL     CPDEHL      ; Compare DE with HL
  336 011D DA5701                  JP       C,NEMEM     ; If not enough RAM
  337 0120 11CEFF                  LD       DE,0-50     ; 50 Bytes string space
  338 0123 22F480                  LD       (LSTRAM),HL ; Save last available R
  339 0126 19                      ADD      HL,DE       ; Allocate string space
  340 0127 229F80                  LD       (STRSPC),HL ; Save string space
  341 012A CD9405                  CALL     CLRPTR      ; Clear program area
  342 012D 2A9F80                  LD       HL,(STRSPC) ; Get end of memory
  343 0130 11EFFF                  LD       DE,0-17     ; Offset for free bytes
  344 0133 19                      ADD      HL,DE       ; Adjust HL
  345 0134 113E81                  LD       DE,PROGST   ; Start of program text
  346 0137 7D                      LD       A,L         ; Get LSB
  347 0138 93                      SUB      E           ; Adjust it
  348 0139 6F                      LD       L,A         ; Re-save
  349 013A 7C                      LD       A,H         ; Get MSB
  350 013B 9A                      SBC      A,D         ; Adjust it
  351 013C 67                      LD       H,A         ; Re-save
  352 013D E5                      PUSH     HL          ; Save bytes free
  353 013E 216F01                  LD       HL,SIGNON   ; Sign-on message
  354 0141 CD2512                  CALL     PRS         ; Output string
  355 0144 E1                      POP      HL          ; Get bytes free back
  356 0145 CDC818                  CALL     PRNTHL      ; Output amount of free
  357 0148 216001                  LD       HL,BFREE    ; " Bytes free" message
  358 014B CD2512                  CALL     PRS         ; Output string
  359                   ;
  360 014E 31AB80       WARMST:    LD       SP,STACK    ; Temporary stack
  361 0151 CDB905       BRKRET:    CALL     CLREG       ; Clear registers and s
  362 0154 C3D204                  JP       PRNTOK      ; Go to get command lin
  363                   ;
  364 0157 21A601       NEMEM:     LD       HL,MEMMSG   ; Memory size not enoug
  365 015A CD2512                  CALL     PRS         ; Print it
  366 015D C35D01       XXXXX:     JP       XXXXX       ; Stop
  367                   ;
  368 0160 204279746573 BFREE:     DB       " Bytes free",CR,LF,0,0
           20667265650D 
           0A0000       
  369                   ;
  370 016F 5A3830204241 SIGNON:    DB       "Z80 BASIC Ver 4.7b",CR,LF
           534943205665 
           7220342E3762 
           0D0A         
  371 0183 436F70797269            DB       "Copyright ",40,"C",41
           676874202843 
           29           
  372 0190 203139373820            DB       " 1978 by Microsoft",CR,LF,0,0
           6279204D6963 
           726F736F6674 
           0D0A0000     
  373                   ;
  374 01A6 4D656D6F7279 MEMMSG:    DB       "Memory size not enough",CR,LF
           2073697A6520 
           6E6F7420656E 
           6F7567680D0A 
  375 01BE 546865207379            DB       "The system is stopped.",CR,LF,0,0
           7374656D2069 
           732073746F70 
           7065642E0D0A 
           0000         
  376                   ;
  377                   ; FUNCTION ADDRESS TABLE
  378                   ;
  379 01D8 3D17         FNCTAB:    DW       SGN
  380 01DA 0118                    DW       INT
  381 01DC 5317                    DW       ABS
  382 01DE 4880                    DW       USR
  383 01E0 E510                    DW       FRE
  384 01E2 6A14                    DW       INP
  385 01E4 1311                    DW       POS
  386 01E6 C719                    DW       SQR
  387 01E8 A61A                    DW       RND
  388 01EA E215                    DW       LOG
  389 01EC 151A                    DW       EXP
  390 01EE 1B1B                    DW       COS
  391 01F0 211B                    DW       SIN
  392 01F2 821B                    DW       TAN
  393 01F4 971B                    DW       ATN
  394 01F6 BE14                    DW       PEEK
  395 01F8 021C                    DW       DEEK
  396 01FA 9680                    DW       POINT
  397 01FC 9713                    DW       LEN
  398 01FE AF11                    DW       STR
  399 0200 3114                    DW       VAL
  400 0202 A613                    DW       ASC
  401 0204 B713                    DW       CHR
  402 0206 241C                    DW       HEX
  403 0208 B71C                    DW       BIN
  404 020A C713                    DW       LEFT
  405 020C F713                    DW       RIGHT
  406 020E 0114                    DW       MID
  407                   ;
  408                   ; RESERVED WORD LIST
  409                   ;
  410 0210 C54E44       WORDS:     DB       0C5H,"ND"
  411 0213 C64F52                  DB       0C6H,"OR"
  412 0216 CE455854                DB       0CEH,"EXT"
  413 021A C4415441                DB       0C4H,"ATA"
  414 021E C94E505554              DB       0C9H,"NPUT"
  415 0223 C4494D                  DB       0C4H,"IM"
  416 0226 D2454144                DB       0D2H,"EAD"
  417 022A CC4554                  DB       0CCH,"ET"
  418 022D C74F544F                DB       0C7H,"OTO"
  419 0231 D2554E                  DB       0D2H,"UN"
  420 0234 C946                    DB       0C9H,"F"
  421 0236 D24553544F52            DB       0D2H,"ESTORE"
           45           
  422 023D C74F535542              DB       0C7H,"OSUB"
  423 0242 D2455455524E            DB       0D2H,"ETURN"
  424 0248 D2454D                  DB       0D2H,"EM"
  425 024B D3544F50                DB       0D3H,"TOP"
  426 024F CF5554                  DB       0CFH,"UT"
  427 0252 CF4E                    DB       0CFH,"N"
  428 0254 CE554C4C                DB       0CEH,"ULL"
  429 0258 D7414954                DB       0D7H,"AIT"
  430 025C C44546                  DB       0C4H,"EF"
  431 025F D04F4B45                DB       0D0H,"OKE"
  432 0263 C44F4B45                DB       0C4H,"OKE"
  433 0267 D3435245454E            DB       0D3H,"CREEN"
  434 026D CC494E4553              DB       0CCH,"INES"
  435 0272 C34C53                  DB       0C3H,"LS"
  436 0275 D749445448              DB       0D7H,"IDTH"
  437 027A CD4F4E49544F            DB       0CDH,"ONITOR"
           52           
  438 0281 D34554                  DB       0D3H,"ET"
  439 0284 D245534554              DB       0D2H,"ESET"
  440 0289 D052494E54              DB       0D0H,"RINT"
  441 028E C34F4E54                DB       0C3H,"ONT"
  442 0292 CC495354                DB       0CCH,"IST"
  443 0296 C34C454152              DB       0C3H,"LEAR"
  444 029B C34C4F4144              DB       0C3H,"LOAD"
  445 02A0 C353415645              DB       0C3H,"SAVE"
  446 02A5 CE4557                  DB       0CEH,"EW"
  447                   ;
  448 02A8 D4414228                DB       0D4H,"AB("
  449 02AC D44F                    DB       0D4H,"O"
  450 02AE C64E                    DB       0C6H,"N"
  451 02B0 D3504328                DB       0D3H,"PC("
  452 02B4 D448454E                DB       0D4H,"HEN"
  453 02B8 CE4F54                  DB       0CEH,"OT"
  454 02BB D3544550                DB       0D3H,"TEP"
  455                   ;
  456 02BF AB                      DB       0ABH
  457 02C0 AD                      DB       0ADH
  458 02C1 AA                      DB       0AAH
  459 02C2 AF                      DB       0AFH
  460 02C3 DE                      DB       0DEH
  461 02C4 C14E44                  DB       0C1H,"ND"
  462 02C7 CF52                    DB       0CFH,"R"
  463 02C9 BE                      DB       0BEH
  464 02CA BD                      DB       0BDH
  465 02CB BC                      DB       0BCH
  466                   ;
  467 02CC D3474E                  DB       0D3H,"GN"
  468 02CF C94E54                  DB       0C9H,"NT"
  469 02D2 C14253                  DB       0C1H,"BS"
  470 02D5 D55352                  DB       0D5H,"SR"
  471 02D8 C65245                  DB       0C6H,"RE"
  472 02DB C94E50                  DB       0C9H,"NP"
  473 02DE D04F53                  DB       0D0H,"OS"
  474 02E1 D35152                  DB       0D3H,"QR"
  475 02E4 D24E44                  DB       0D2H,"ND"
  476 02E7 CC4F47                  DB       0CCH,"OG"
  477 02EA C55850                  DB       0C5H,"XP"
  478 02ED C34F53                  DB       0C3H,"OS"
  479 02F0 D3494E                  DB       0D3H,"IN"
  480 02F3 D4414E                  DB       0D4H,"AN"
  481 02F6 C1544E                  DB       0C1H,"TN"
  482 02F9 D045454B                DB       0D0H,"EEK"
  483 02FD C445454B                DB       0C4H,"EEK"
  484 0301 D04F494E54              DB       0D0H,"OINT"
  485 0306 CC454E                  DB       0CCH,"EN"
  486 0309 D3545224                DB       0D3H,"TR$"
  487 030D D6414C                  DB       0D6H,"AL"
  488 0310 C15343                  DB       0C1H,"SC"
  489 0313 C3485224                DB       0C3H,"HR$"
  490 0317 C8455824                DB       0C8H,"EX$"
  491 031B C2494E24                DB       0C2H,"IN$"
  492 031F CC45465424              DB       0CCH,"EFT$"
  493 0324 D24947485424            DB       0D2H,"IGHT$"
  494 032A CD494424                DB       0CDH,"ID$"
  495 032E 80                      DB       80H         ; End of list marker
  496                   ;
  497                   ; KEYWORD ADDRESS TABLE
  498                   ;
  499 032F 2909         WORDTB:    DW       PEND
  500 0331 2608                    DW       FOR
  501 0333 010D                    DW       NEXT
  502 0335 760A                    DW       DATA
  503 0337 080C                    DW       INPUT
  504 0339 3D0F                    DW       DIM
  505 033B 370C                    DW       READ
  506 033D 8D0A                    DW       LET
  507 033F 330A                    DW       GOTO
  508 0341 160A                    DW       RUN
  509 0343 050B                    DW       IF
  510 0345 EF08                    DW       RESTOR
  511 0347 220A                    DW       GOSUB
  512 0349 510A                    DW       RETURN
  513 034B 780A                    DW       REM
  514 034D 2709                    DW       STOP
  515 034F 7614                    DW       POUT
  516 0351 E70A                    DW       ON
  517 0353 6809                    DW       NULL
  518 0355 7C14                    DW       WAIT
  519 0357 1B11                    DW       DEF
  520 0359 C514                    DW       POKE
  521 035B 0D1C                    DW       DOKE
  522 035D 780A                    DW       REM
  523 035F F31B                    DW       LINES
  524 0361 E61B                    DW       CLS
  525 0363 EB1B                    DW       WIDTH
  526 0365 1F1D                    DW       MONITR
  527 0367 9980                    DW       PSET
  528 0369 9C80                    DW       RESET
  529 036B 290B                    DW       PRINT
  530 036D 5509                    DW       CONT
  531 036F 9B07                    DW       LIST
  532 0371 D009                    DW       CLEAR
  533 0373 780A                    DW       REM
  534 0375 780A                    DW       REM
  535 0377 9305                    DW       NEW
  536                   ;
  537                   ; RESERVED WORD TOKEN VALUES
  538                   ;
  539 0080              ZEND       EQU      080H        ; END
  540 0081              ZFOR       EQU      081H        ; FOR
  541 0083              ZDATA      EQU      083H        ; DATA
  542 0088              ZGOTO      EQU      088H        ; GOTO
  543 008C              ZGOSUB     EQU      08CH        ; GOSUB
  544 008E              ZREM       EQU      08EH        ; REM
  545 009E              ZPRINT     EQU      09EH        ; PRINT
  546 00A4              ZNEW       EQU      0A4H        ; NEW
  547                   ;
  548 00A5              ZTAB       EQU      0A5H        ; TAB
  549 00A6              ZTO        EQU      0A6H        ; TO
  550 00A7              ZFN        EQU      0A7H        ; FN
  551 00A8              ZSPC       EQU      0A8H        ; SPC
  552 00A9              ZTHEN      EQU      0A9H        ; THEN
  553 00AA              ZNOT       EQU      0AAH        ; NOT
  554 00AB              ZSTEP      EQU      0ABH        ; STEP
  555                   ;
  556 00AC              ZPLUS      EQU      0ACH        ; +
  557 00AD              ZMINUS     EQU      0ADH        ; -
  558 00AE              ZTIMES     EQU      0AEH        ; *
  559 00AF              ZDIV       EQU      0AFH        ; /
  560 00B2              ZOR        EQU      0B2H        ; OR
  561 00B3              ZGTR       EQU      0B3H        ; >
  562 00B4              ZEQUAL     EQU      0B4H        ; M
  563 00B5              ZLTH       EQU      0B5H        ; <
  564 00B6              ZSGN       EQU      0B6H        ; SGN
  565 00C7              ZPOINT     EQU      0C7H        ; POINT
  566 00CF              ZLEFT      EQU      0CDH +2     ; LEFT$
  567                   ;
  568                   ; ARITHMETIC PRECEDENCE TABLE
  569                   ;
  570 0379 79           PRITAB:    DB       79H         ; Precedence value
  571 037A AF18                    DW       PADD        ; FPREG = <last> + FPRE
  572                   ;
  573 037C 79                      DB       79H         ; Precedence value
  574 037D E314                    DW       PSUB        ; FPREG = <last> - FPRE
  575                   ;
  576 037F 7C                      DB       7CH         ; Precedence value
  577 0380 2116                    DW       MULT        ; PPREG = <last> * FPRE
  578                   ;
  579 0382 7C                      DB       7CH         ; Precedence value
  580 0383 8216                    DW       DIV         ; FPREG = <last> / FPRE
  581                   ;
  582 0385 7F                      DB       7FH         ; Precedence value
  583 0386 D019                    DW       POWER       ; FPREG = <last> ^ FPRE
  584                   ;
  585 0388 50                      DB       50H         ; Precedence value
  586 0389 960E                    DW       PAND        ; FPREG = <last> AND FP
  587                   ;
  588 038B 46                      DB       46H         ; Precedence value
  589 038C 950E                    DW       POR         ; FPREG = <last> OR FPR
  590                   ;
  591                   ; BASIC ERROR CODE LIST
  592                   ;
  593 038E 4E46         ERRORS:    DB       "NF"        ; NEXT without FOR
  594 0390 534E                    DB       "SN"        ; Syntax error
  595 0392 5247                    DB       "RG"        ; RETURN without GOSUB
  596 0394 4F44                    DB       "OD"        ; Out of DATA
  597 0396 4643                    DB       "FC"        ; Illegal function call
  598 0398 4F56                    DB       "OV"        ; Overflow error
  599 039A 4F4D                    DB       "OM"        ; Out of memory
  600 039C 554C                    DB       "UL"        ; Undefined line
  601 039E 4253                    DB       "BS"        ; Bad subscript
  602 03A0 4444                    DB       "DD"        ; Re-DIMensioned array
  603 03A2 2F30                    DB       "/0"        ; Division by zero
  604 03A4 4944                    DB       "ID"        ; Illegal direct
  605 03A6 544D                    DB       "TM"        ; Type mis-match
  606 03A8 4F53                    DB       "OS"        ; Out of string space
  607 03AA 4C53                    DB       "LS"        ; String too long
  608 03AC 5354                    DB       "ST"        ; String formula too co
  609 03AE 434E                    DB       "CN"        ; Can't CONTinue
  610 03B0 5546                    DB       "UF"        ; Undefined FN function
  611 03B2 4D4F                    DB       "MO"        ; Missing operand
  612 03B4 4858                    DB       "HX"        ; HEX error
  613 03B6 424E                    DB       "BN"        ; BIN error
  614                   ;
  615                   ; INITIALISATION TABLE --------------------------------
  616                   ;
  617 03B8 C34E01       INITAB:    JP       WARMST      ; Warm start jump
  618 03BB C3A609                  JP       FCERR       ; "USR (X)" jump (Set t
  619 03BE D300                    OUT      (0),A       ; "OUT p,n" skeleton
  620 03C0 C9                      RET
  621 03C1 D600                    SUB      0           ; Division support rout
  622 03C3 6F                      LD       L,A
  623 03C4 7C                      LD       A,H
  624 03C5 DE00                    SBC      A,0
  625 03C7 67                      LD       H,A
  626 03C8 78                      LD       A,B
  627 03C9 DE00                    SBC      A,0
  628 03CB 47                      LD       B,A
  629 03CC 3E00                    LD       A,0
  630 03CE C9                      RET
  631 03CF 000000                  DB       0,0,0       ; Random number seed ta
  632 03D2 354ACA99                DB       035H,04AH,0CAH,099H ;-2.65145E+07
  633 03D6 391C7698                DB       039H,01CH,076H,098H ; 1.61291E+07
  634 03DA 2295B398                DB       022H,095H,0B3H,098H ;-1.17691E+07
  635 03DE 0ADD4798                DB       00AH,0DDH,047H,098H ; 1.30983E+07
  636 03E2 53D19999                DB       053H,0D1H,099H,099H ;-2-01612E+07
  637 03E6 0A1A9F98                DB       00AH,01AH,09FH,098H ;-1.04269E+07
  638 03EA 65BCCD98                DB       065H,0BCH,0CDH,098H ;-1.34831E+07
  639 03EE D6773E98                DB       0D6H,077H,03EH,098H ; 1.24825E+07
  640 03F2 52C74F80                DB       052H,0C7H,04FH,080H ; Last random n
  641 03F6 DB00                    IN       A,(0)       ; INP (x) skeleton
  642 03F8 C9                      RET
  643 03F9 01                      DB       1           ; POS (x) number (1)
  644 03FA FF                      DB       255         ; Terminal width (255 =
  645 03FB 1C                      DB       28          ; Width for commas (3 c
  646 03FC 00                      DB       0           ; No nulls after input 
  647 03FD 00                      DB       0           ; Output enabled (^O of
  648 03FE 1400                    DW       20          ; Initial lines counter
  649 0400 1400                    DW       20          ; Initial lines number
  650 0402 0000                    DW       0           ; Array load/save check
  651 0404 00                      DB       0           ; Break not by NMI
  652 0405 00                      DB       0           ; Break flag
  653 0406 C3CC06                  JP       TTYLIN      ; Input reflection (set
  654 0409 C30000                  JP       0000H       ; POINT reflection unus
  655 040C C30000                  JP       0000H       ; SET reflection
  656 040F C30000                  JP       0000H       ; RESET reflection
  657 0412 A281                    DW       STLOOK      ; Temp string space
  658 0414 FEFF                    DW       -2          ; Current line number (
  659 0416 3F81                    DW       PROGST+1    ; Start of program text
  660 0418              INITBE:
  661                   ;
  662                   ; END OF INITIALISATION TABLE -------------------------
  663                   ;
  664 0418 204572726F72 ERRMSG:    DB       " Error",0
           00           
  665 041F 20696E2000   INMSG:     DB       " in ",0
  666 0423              ZERBYT     EQU      $-1         ; A zero byte
  667 0424 4F6B0D0A0000 OKMSG:     DB       "Ok",CR,LF,0,0
  668 042A 427265616B00 BRKMSG:    DB       "Break",0
  669                   ;
  670 0430 210400       BAKSTK:    LD       HL,4        ; Look for "FOR" block 
  671 0433 39                      ADD      HL,SP       ; same index as specifi
  672 0434 7E           LOKFOR:    LD       A,(HL)      ; Get block ID
  673 0435 23                      INC      HL          ; Point to index addres
  674 0436 FE81                    CP       ZFOR        ; Is it a "FOR" token
  675 0438 C0                      RET      NZ          ; No - exit
  676 0439 4E                      LD       C,(HL)      ; BC = Address of "FOR"
  677 043A 23                      INC      HL
  678 043B 46                      LD       B,(HL)
  679 043C 23                      INC      HL          ; Point to sign of STEP
  680 043D E5                      PUSH     HL          ; Save pointer to sign
  681 043E 69                      LD       L,C         ; HL = address of "FOR"
  682 043F 60                      LD       H,B
  683 0440 7A                      LD       A,D         ; See if an index was s
  684 0441 B3                      OR       E           ; DE = 0 if no index sp
  685 0442 EB                      EX       DE,HL       ; Specified index into 
  686 0443 CA4A04                  JP       Z,INDFND    ; Skip if no index give
  687 0446 EB                      EX       DE,HL       ; Index back into DE
  688 0447 CD4F07                  CALL     CPDEHL      ; Compare index with on
  689 044A 010D00       INDFND:    LD       BC,16-3     ; Offset to next block
  690 044D E1                      POP      HL          ; Restore pointer to si
  691 044E C8                      RET      Z           ; Return if block found
  692 044F 09                      ADD      HL,BC       ; Point to next block
  693 0450 C33404                  JP       LOKFOR      ; Keep on looking
  694                   ;
  695 0453 CD6D04       MOVUP:     CALL     ENFMEM      ; See if enough memory
  696 0456 C5           MOVSTR:    PUSH     BC          ; Save end of source
  697 0457 E3                      EX       (SP),HL     ; Swap source and dest"
  698 0458 C1                      POP      BC          ; Get end of destinatio
  699 0459 CD4F07       MOVLP:     CALL     CPDEHL      ; See if list moved
  700 045C 7E                      LD       A,(HL)      ; Get byte
  701 045D 02                      LD       (BC),A      ; Move it
  702 045E C8                      RET      Z           ; Exit if all done
  703 045F 0B                      DEC      BC          ; Next byte to move to
  704 0460 2B                      DEC      HL          ; Next byte to move
  705 0461 C35904                  JP       MOVLP       ; Loop until all bytes 
  706                   ;
  707 0464 E5           CHKSTK:    PUSH     HL          ; Save code string addr
  708 0465 2A1F81                  LD       HL,(ARREND) ; Lowest free memory
  709 0468 0600                    LD       B,0         ; BC = Number of levels
  710 046A 09                      ADD      HL,BC       ; 2 Bytes for each leve
  711 046B 09                      ADD      HL,BC
  712 046C 3E                      DB       3EH         ; Skip "PUSH HL"
  713 046D E5           ENFMEM:    PUSH     HL          ; Save code string addr
  714 046E 3ED0                    LD       A,0D0H      ; LOW -48; 48 Bytes min
  715 0470 95                      SUB      L
  716 0471 6F                      LD       L,A
  717 0472 3EFF                    LD       A,0FFH      ; HIGH (-48); 48 Bytes 
  718 0474 9C                      SBC      A,H
  719 0475 DA7C04                  JP       C,OMERR     ; Not enough - ?OM Erro
  720 0478 67                      LD       H,A
  721 0479 39                      ADD      HL,SP       ; Test if stack is over
  722 047A E1                      POP      HL          ; Restore code string a
  723 047B D8                      RET      C           ; Return if enough mmor
  724 047C 1E0C         OMERR:     LD       E,OM        ; ?OM Error
  725 047E C39B04                  JP       ERROR
  726                   ;
  727 0481 2A0E81       DATSNR:    LD       HL,(DATLIN) ; Get line of current D
  728 0484 22A180                  LD       (LINEAT),HL ; Save as current line
  729 0487 1E02         SNERR:     LD       E,SN        ; ?SN Error
  730 0489 01                      DB       01H         ; Skip "LD E,DZ"
  731 048A 1E14         DZERR:     LD       E,DZ        ; ?/0 Error
  732 048C 01                      DB       01H         ; Skip "LD E,NF"
  733 048D 1E00         NFERR:     LD       E,NF        ; ?NF Error
  734 048F 01                      DB       01H         ; Skip "LD E,RD"
  735 0490 1E12         DDERR:     LD       E,RD        ; ?DD Error
  736 0492 01                      DB       01H         ; Skip "LD E,UF"
  737 0493 1E22         UFERR:     LD       E,UF        ; ?UF Error
  738 0495 01                      DB       01H         ; Skip "LD E,OV
  739 0496 1E0A         OVERR:     LD       E,OV        ; ?OV Error
  740 0498 01                      DB       01H         ; Skip "LD E,TM"
  741 0499 1E18         TMERR:     LD       E,TM        ; ?TM Error
  742                   ;
  743 049B CDB905       ERROR:     CALL     CLREG       ; Clear registers and s
  744 049E 328A80                  LD       (CTLOFG),A  ; Enable output (A is 0
  745 04A1 CD7A0B                  CALL     STTLIN      ; Start new line
  746 04A4 218E03                  LD       HL,ERRORS   ; Point to error codes
  747 04A7 57                      LD       D,A         ; D = 0 (A is 0)
  748 04A8 3E3F                    LD       A,'?'
  749 04AA CD6007                  CALL     OUTC        ; Output '?'
  750 04AD 19                      ADD      HL,DE       ; Offset to correct err
  751 04AE 7E                      LD       A,(HL)      ; First character
  752 04AF CD6007                  CALL     OUTC        ; Output it
  753 04B2 CDDF08                  CALL     GETCHR      ; Get next character
  754 04B5 CD6007                  CALL     OUTC        ; Output it
  755 04B8 211804                  LD       HL,ERRMSG   ; "Error" message
  756 04BB CD2512       ERRIN:     CALL     PRS         ; Output message
  757 04BE 2AA180                  LD       HL,(LINEAT) ; Get line of error
  758 04C1 11FEFF                  LD       DE,-2       ; Cold start error if -
  759 04C4 CD4F07                  CALL     CPDEHL      ; See if cold start err
  760 04C7 CAE000                  JP       Z,CSTART    ; Cold start error - Re
  761 04CA 7C                      LD       A,H         ; Was it a direct error
  762 04CB A5                      AND      L           ; Line = -1 if direct e
  763 04CC 3C                      INC      A
  764 04CD C4C018                  CALL     NZ,LINEIN   ; No - output line of e
  765 04D0 3E                      DB       3EH         ; Skip "POP BC"
  766 04D1 C1           POPNOK:    POP      BC          ; Drop address in input
  767                   ;
  768 04D2 AF           PRNTOK:    XOR      A           ; Output "Ok" and get c
  769 04D3 328A80                  LD       (CTLOFG),A  ; Enable output
  770 04D6 CD7A0B                  CALL     STTLIN      ; Start new line
  771 04D9 212404                  LD       HL,OKMSG    ; "Ok" message
  772 04DC CD2512                  CALL     PRS         ; Output "Ok"
  773 04DF 21FFFF       GETCMD:    LD       HL,-1       ; Flag direct mode
  774 04E2 22A180                  LD       (LINEAT),HL ; Save as current line
  775 04E5 CDCC06                  CALL     GETLIN      ; Get an input line
  776 04E8 DADF04                  JP       C,GETCMD    ; Get line again if bre
  777 04EB CDDF08                  CALL     GETCHR      ; Get first character
  778 04EE 3C                      INC      A           ; Test if end of line
  779 04EF 3D                      DEC      A           ; Without affecting Car
  780 04F0 CADF04                  JP       Z,GETCMD    ; Nothing entered - Get
  781 04F3 F5                      PUSH     AF          ; Save Carry status
  782 04F4 CDAB09                  CALL     ATOH        ; Get line number into 
  783 04F7 D5                      PUSH     DE          ; Save line number
  784 04F8 CDE305                  CALL     CRUNCH      ; Tokenise rest of line
  785 04FB 47                      LD       B,A         ; Length of tokenised l
  786 04FC D1                      POP      DE          ; Restore line number
  787 04FD F1                      POP      AF          ; Restore Carry
  788 04FE D2BF08                  JP       NC,EXCUTE   ; No line number - Dire
  789 0501 D5                      PUSH     DE          ; Save line number
  790 0502 C5                      PUSH     BC          ; Save length of tokeni
  791 0503 AF                      XOR      A
  792 0504 321181                  LD       (LSTBIN),A  ; Clear last byte input
  793 0507 CDDF08                  CALL     GETCHR      ; Get next character
  794 050A B7                      OR       A           ; Set flags
  795 050B F5                      PUSH     AF          ; And save them
  796 050C CD7305                  CALL     SRCHLN      ; Search for line numbe
  797 050F DA1805                  JP       C,LINFND    ; Jump if line found
  798 0512 F1                      POP      AF          ; Get status
  799 0513 F5                      PUSH     AF          ; And re-save
  800 0514 CA4C0A                  JP       Z,ULERR     ; Nothing after number 
  801 0517 B7                      OR       A           ; Clear Carry
  802 0518 C5           LINFND:    PUSH     BC          ; Save address of line 
  803 0519 D22F05                  JP       NC,INEWLN   ; Line not found - Inse
  804 051C EB                      EX       DE,HL       ; Next line address in 
  805 051D 2A1B81                  LD       HL,(PROGND) ; End of program
  806 0520 1A           SFTPRG:    LD       A,(DE)      ; Shift rest of program
  807 0521 02                      LD       (BC),A
  808 0522 03                      INC      BC          ; Next destination
  809 0523 13                      INC      DE          ; Next source
  810 0524 CD4F07                  CALL     CPDEHL      ; All done?
  811 0527 C22005                  JP       NZ,SFTPRG   ; More to do
  812 052A 60                      LD       H,B         ; HL - New end of progr
  813 052B 69                      LD       L,C
  814 052C 221B81                  LD       (PROGND),HL ; Update end of program
  815                   ;
  816 052F D1           INEWLN:    POP      DE          ; Get address of line,
  817 0530 F1                      POP      AF          ; Get status
  818 0531 CA5605                  JP       Z,SETPTR    ; No text - Set up poin
  819 0534 2A1B81                  LD       HL,(PROGND) ; Get end of program
  820 0537 E3                      EX       (SP),HL     ; Get length of input l
  821 0538 C1                      POP      BC          ; End of program to BC
  822 0539 09                      ADD      HL,BC       ; Find new end
  823 053A E5                      PUSH     HL          ; Save new end
  824 053B CD5304                  CALL     MOVUP       ; Make space for line
  825 053E E1                      POP      HL          ; Restore new end
  826 053F 221B81                  LD       (PROGND),HL ; Update end of program
  827 0542 EB                      EX       DE,HL       ; Get line to move up i
  828 0543 74                      LD       (HL),H      ; Save MSB
  829 0544 D1                      POP      DE          ; Get new line number
  830 0545 23                      INC      HL          ; Skip pointer
  831 0546 23                      INC      HL
  832 0547 73                      LD       (HL),E      ; Save LSB of line numb
  833 0548 23                      INC      HL
  834 0549 72                      LD       (HL),D      ; Save MSB of line numb
  835 054A 23                      INC      HL          ; To first byte in line
  836 054B 11A680                  LD       DE,BUFFER   ; Copy buffer to progra
  837 054E 1A           MOVBUF:    LD       A,(DE)      ; Get source
  838 054F 77                      LD       (HL),A      ; Save destinations
  839 0550 23                      INC      HL          ; Next source
  840 0551 13                      INC      DE          ; Next destination
  841 0552 B7                      OR       A           ; Done?
  842 0553 C24E05                  JP       NZ,MOVBUF   ; No - Repeat
  843 0556 CD9F05       SETPTR:    CALL     RUNFST      ; Set line pointers
  844 0559 23                      INC      HL          ; To LSB of pointer
  845 055A EB                      EX       DE,HL       ; Address to DE
  846 055B 62           PTRLP:     LD       H,D         ; Address to HL
  847 055C 6B                      LD       L,E
  848 055D 7E                      LD       A,(HL)      ; Get LSB of pointer
  849 055E 23                      INC      HL          ; To MSB of pointer
  850 055F B6                      OR       (HL)        ; Compare with MSB poin
  851 0560 CADF04                  JP       Z,GETCMD    ; Get command line if e
  852 0563 23                      INC      HL          ; To LSB of line number
  853 0564 23                      INC      HL          ; Skip line number
  854 0565 23                      INC      HL          ; Point to first byte i
  855 0566 AF                      XOR      A           ; Looking for 00 byte
  856 0567 BE           FNDEND:    CP       (HL)        ; Found end of line?
  857 0568 23                      INC      HL          ; Move to next byte
  858 0569 C26705                  JP       NZ,FNDEND   ; No - Keep looking
  859 056C EB                      EX       DE,HL       ; Next line address to 
  860 056D 73                      LD       (HL),E      ; Save LSB of pointer
  861 056E 23                      INC      HL
  862 056F 72                      LD       (HL),D      ; Save MSB of pointer
  863 0570 C35B05                  JP       PTRLP       ; Do next line
  864                   ;
  865 0573 2AA380       SRCHLN:    LD       HL,(BASTXT) ; Start of program text
  866 0576 44           SRCHLP:    LD       B,H         ; BC = Address to look 
  867 0577 4D                      LD       C,L
  868 0578 7E                      LD       A,(HL)      ; Get address of next l
  869 0579 23                      INC      HL
  870 057A B6                      OR       (HL)        ; End of program found?
  871 057B 2B                      DEC      HL
  872 057C C8                      RET      Z           ; Yes - Line not found
  873 057D 23                      INC      HL
  874 057E 23                      INC      HL
  875 057F 7E                      LD       A,(HL)      ; Get LSB of line numbe
  876 0580 23                      INC      HL
  877 0581 66                      LD       H,(HL)      ; Get MSB of line numbe
  878 0582 6F                      LD       L,A
  879 0583 CD4F07                  CALL     CPDEHL      ; Compare with line in 
  880 0586 60                      LD       H,B         ; HL = Start of this li
  881 0587 69                      LD       L,C
  882 0588 7E                      LD       A,(HL)      ; Get LSB of next line 
  883 0589 23                      INC      HL
  884 058A 66                      LD       H,(HL)      ; Get MSB of next line 
  885 058B 6F                      LD       L,A         ; Next line to HL
  886 058C 3F                      CCF
  887 058D C8                      RET      Z           ; Lines found - Exit
  888 058E 3F                      CCF
  889 058F D0                      RET      NC          ; Line not found,at lin
  890 0590 C37605                  JP       SRCHLP      ; Keep looking
  891                   ;
  892 0593 C0           NEW:       RET      NZ          ; Return if any more on
  893 0594 2AA380       CLRPTR:    LD       HL,(BASTXT) ; Point to start of pro
  894 0597 AF                      XOR      A           ; Set program area to e
  895 0598 77                      LD       (HL),A      ; Save LSB = 00
  896 0599 23                      INC      HL
  897 059A 77                      LD       (HL),A      ; Save MSB = 00
  898 059B 23                      INC      HL
  899 059C 221B81                  LD       (PROGND),HL ; Set program end
  900                   ;
  901 059F 2AA380       RUNFST:    LD       HL,(BASTXT) ; Clear all variables
  902 05A2 2B                      DEC      HL
  903                   ;
  904 05A3 221381       INTVAR:    LD       (BRKLIN),HL ; Initialise RUN variab
  905 05A6 2AF480                  LD       HL,(LSTRAM) ; Get end of RAM
  906 05A9 220881                  LD       (STRBOT),HL ; Clear string space
  907 05AC AF                      XOR      A
  908 05AD CDEF08                  CALL     RESTOR      ; Reset DATA pointers
  909 05B0 2A1B81                  LD       HL,(PROGND) ; Get end of program
  910 05B3 221D81                  LD       (VAREND),HL ; Clear variables
  911 05B6 221F81                  LD       (ARREND),HL ; Clear arrays
  912                   ;
  913 05B9 C1           CLREG:     POP      BC          ; Save return address
  914 05BA 2A9F80                  LD       HL,(STRSPC) ; Get end of working RA
  915 05BD F9                      LD       SP,HL       ; Set stack
  916 05BE 21F880                  LD       HL,TMSTPL   ; Temporary string pool
  917 05C1 22F680                  LD       (TMSTPT),HL ; Reset temporary strin
  918 05C4 AF                      XOR      A           ; A = 00
  919 05C5 6F                      LD       L,A         ; HL = 0000
  920 05C6 67                      LD       H,A
  921 05C7 221981                  LD       (CONTAD),HL ; No CONTinue
  922 05CA 321081                  LD       (FORFLG),A  ; Clear FOR flag
  923 05CD 222381                  LD       (FNRGNM),HL ; Clear FN argument
  924 05D0 E5                      PUSH     HL          ; HL = 0000
  925 05D1 C5                      PUSH     BC          ; Put back return
  926 05D2 2A1381       DOAGN:     LD       HL,(BRKLIN) ; Get address of code t
  927 05D5 C9                      RET                  ; Return to execution d
  928                   ;
  929 05D6 3E3F         PROMPT:    LD       A,'?'       ; '?'
  930 05D8 CD6007                  CALL     OUTC        ; Output character
  931 05DB 3E20                    LD       A,' '       ; Space
  932 05DD CD6007                  CALL     OUTC        ; Output character
  933 05E0 C39380                  JP       RINPUT      ; Get input line
  934                   ;
  935 05E3 AF           CRUNCH:    XOR      A           ; Tokenise line @ HL to
  936 05E4 32F380                  LD       (DATFLG),A  ; Reset literal flag
  937 05E7 0E05                    LD       C,2+3       ; 2 byte number and 3 n
  938 05E9 11A680                  LD       DE,BUFFER   ; Start of input buffer
  939 05EC 7E           CRNCLP:    LD       A,(HL)      ; Get byte
  940 05ED FE20                    CP       ' '         ; Is it a space?
  941 05EF CA6B06                  JP       Z,MOVDIR    ; Yes - Copy direct
  942 05F2 47                      LD       B,A         ; Save character
  943 05F3 FE22                    CP       '"'         ; Is it a quote?
  944 05F5 CA8B06                  JP       Z,CPYLIT    ; Yes - Copy literal st
  945 05F8 B7                      OR       A           ; Is it end of buffer?
  946 05F9 CA9206                  JP       Z,ENDBUF    ; Yes - End buffer
  947 05FC 3AF380                  LD       A,(DATFLG)  ; Get data type
  948 05FF B7                      OR       A           ; Literal?
  949 0600 7E                      LD       A,(HL)      ; Get byte to copy
  950 0601 C26B06                  JP       NZ,MOVDIR   ; Literal - Copy direct
  951 0604 FE3F                    CP       '?'         ; Is it '?' short for P
  952 0606 3E9E                    LD       A,ZPRINT    ; "PRINT" token
  953 0608 CA6B06                  JP       Z,MOVDIR    ; Yes - replace it
  954 060B 7E                      LD       A,(HL)      ; Get byte again
  955 060C FE30                    CP       '0'         ; Is it less than '0'
  956 060E DA1606                  JP       C,FNDWRD    ; Yes - Look for reserv
  957 0611 FE3C                    CP       60          ; ";"+1; Is it "0123456
  958 0613 DA6B06                  JP       C,MOVDIR    ; Yes - copy it direct
  959 0616 D5           FNDWRD:    PUSH     DE          ; Look for reserved wor
  960 0617 110F02                  LD       DE,WORDS-1  ; Point to table
  961 061A C5                      PUSH     BC          ; Save count
  962 061B 016706                  LD       BC,RETNAD   ; Where to return to
  963 061E C5                      PUSH     BC          ; Save return address
  964 061F 067F                    LD       B,ZEND-1    ; First token value -1
  965 0621 7E                      LD       A,(HL)      ; Get byte
  966 0622 FE61                    CP       'a'         ; Less than 'a' ?
  967 0624 DA2F06                  JP       C,SEARCH    ; Yes - search for word
  968 0627 FE7B                    CP       'z'+1       ; Greater than 'z' ?
  969 0629 D22F06                  JP       NC,SEARCH   ; Yes - search for word
  970 062C E65F                    AND      01011111B   ; Force upper case
  971 062E 77                      LD       (HL),A      ; Replace byte
  972 062F 4E           SEARCH:    LD       C,(HL)      ; Search for a word
  973 0630 EB                      EX       DE,HL
  974 0631 23           GETNXT:    INC      HL          ; Get next reserved wor
  975 0632 B6                      OR       (HL)        ; Start of word?
  976 0633 F23106                  JP       P,GETNXT    ; No - move on
  977 0636 04                      INC      B           ; Increment token value
  978 0637 7E                      LD       A, (HL)     ; Get byte from table
  979 0638 E67F                    AND      01111111B   ; Strip bit 7
  980 063A C8                      RET      Z           ; Return if end of list
  981 063B B9                      CP       C           ; Same character as in 
  982 063C C23106                  JP       NZ,GETNXT   ; No - get next word
  983 063F EB                      EX       DE,HL
  984 0640 E5                      PUSH     HL          ; Save start of word
  985                   ;
  986 0641 13           NXTBYT:    INC      DE          ; Look through rest of 
  987 0642 1A                      LD       A,(DE)      ; Get byte from table
  988 0643 B7                      OR       A           ; End of word ?
  989 0644 FA6306                  JP       M,MATCH     ; Yes - Match found
  990 0647 4F                      LD       C,A         ; Save it
  991 0648 78                      LD       A,B         ; Get token value
  992 0649 FE88                    CP       ZGOTO       ; Is it "GOTO" token ?
  993 064B C25206                  JP       NZ,NOSPC    ; No - Don't allow spac
  994 064E CDDF08                  CALL     GETCHR      ; Get next character
  995 0651 2B                      DEC      HL          ; Cancel increment from
  996 0652 23           NOSPC:     INC      HL          ; Next byte
  997 0653 7E                      LD       A,(HL)      ; Get byte
  998 0654 FE61                    CP       'a'         ; Less than 'a' ?
  999 0656 DA5B06                  JP       C,NOCHNG    ; Yes - don't change
 1000 0659 E65F                    AND      01011111B   ; Make upper case
 1001 065B B9           NOCHNG:    CP       C           ; Same as in buffer ?
 1002 065C CA4106                  JP       Z,NXTBYT    ; Yes - keep testing
 1003 065F E1                      POP      HL          ; Get back start of wor
 1004 0660 C32F06                  JP       SEARCH      ; Look at next word
 1005                   ;
 1006 0663 48           MATCH:     LD       C,B         ; Word found - Save tok
 1007 0664 F1                      POP      AF          ; Throw away return
 1008 0665 EB                      EX       DE,HL
 1009 0666 C9                      RET                  ; Return to "RETNAD"
 1010 0667 EB           RETNAD:    EX       DE,HL       ; Get address in string
 1011 0668 79                      LD       A,C         ; Get token value
 1012 0669 C1                      POP      BC          ; Restore buffer length
 1013 066A D1                      POP      DE          ; Get destination addre
 1014 066B 23           MOVDIR:    INC      HL          ; Next source in buffer
 1015 066C 12                      LD       (DE),A      ; Put byte in buffer
 1016 066D 13                      INC      DE          ; Move up buffer
 1017 066E 0C                      INC      C           ; Increment length of b
 1018 066F D63A                    SUB      ':'         ; End of statement?
 1019 0671 CA7906                  JP       Z,SETLIT    ; Jump if multi-stateme
 1020 0674 FE49                    CP       ZDATA-3AH   ; Is it DATA statement 
 1021 0676 C27C06                  JP       NZ,TSTREM   ; No - see if REM
 1022 0679 32F380       SETLIT:    LD       (DATFLG),A  ; Set literal flag
 1023 067C D654         TSTREM:    SUB      ZREM-3AH    ; Is it REM?
 1024 067E C2EC05                  JP       NZ,CRNCLP   ; No - Leave flag
 1025 0681 47                      LD       B,A         ; Copy rest of buffer
 1026 0682 7E           NXTCHR:    LD       A,(HL)      ; Get byte
 1027 0683 B7                      OR       A           ; End of line ?
 1028 0684 CA9206                  JP       Z,ENDBUF    ; Yes - Terminate buffe
 1029 0687 B8                      CP       B           ; End of statement ?
 1030 0688 CA6B06                  JP       Z,MOVDIR    ; Yes - Get next one
 1031 068B 23           CPYLIT:    INC      HL          ; Move up source string
 1032 068C 12                      LD       (DE),A      ; Save in destination
 1033 068D 0C                      INC      C           ; Increment length
 1034 068E 13                      INC      DE          ; Move up destination
 1035 068F C38206                  JP       NXTCHR      ; Repeat
 1036                   ;
 1037 0692 21A580       ENDBUF:    LD       HL,BUFFER-1 ; Point to start of buf
 1038 0695 12                      LD       (DE),A      ; Mark end of buffer (A
 1039 0696 13                      INC      DE
 1040 0697 12                      LD       (DE),A      ; A = 00
 1041 0698 13                      INC      DE
 1042 0699 12                      LD       (DE),A      ; A = 00
 1043 069A C9                      RET
 1044                   ;
 1045 069B 3A8980       DODEL:     LD       A,(NULFLG)  ; Get null flag status
 1046 069E B7                      OR       A           ; Is it zero?
 1047 069F 3E00                    LD       A,0         ; Zero A - Leave flags
 1048 06A1 328980                  LD       (NULFLG),A  ; Zero null flag
 1049 06A4 C2AF06                  JP       NZ,ECHDEL   ; Set - Echo it
 1050 06A7 05                      DEC      B           ; Decrement length
 1051 06A8 CACC06                  JP       Z,GETLIN    ; Get line again if emp
 1052 06AB CD6007                  CALL     OUTC        ; Output null character
 1053 06AE 3E                      DB       3EH         ; Skip "DEC B"
 1054 06AF 05           ECHDEL:    DEC      B           ; Count bytes in buffer
 1055 06B0 2B                      DEC      HL          ; Back space buffer
 1056 06B1 CAC306                  JP       Z,OTKLN     ; No buffer - Try again
 1057 06B4 7E                      LD       A,(HL)      ; Get deleted byte
 1058 06B5 CD6007                  CALL     OUTC        ; Echo it
 1059 06B8 C3D506                  JP       MORINP      ; Get more input
 1060                   ;
 1061 06BB 05           DELCHR:    DEC      B           ; Count bytes in buffer
 1062 06BC 2B                      DEC      HL          ; Back space buffer
 1063 06BD CD6007                  CALL     OUTC        ; Output character in A
 1064 06C0 C2D506                  JP       NZ,MORINP   ; Not end - Get more
 1065 06C3 CD6007       OTKLN:     CALL     OUTC        ; Output character in A
 1066 06C6 CD870B       KILIN:     CALL     PRCRLF      ; Output CRLF
 1067 06C9 C3CC06                  JP       TTYLIN      ; Get line again
 1068                   ;
 1069 06CC              GETLIN:
 1070 06CC 21A680       TTYLIN:    LD       HL,BUFFER   ; Get a line by charact
 1071 06CF 0601                    LD       B,1         ; Set buffer as empty
 1072 06D1 AF                      XOR      A
 1073 06D2 328980                  LD       (NULFLG),A  ; Clear null flag
 1074 06D5 CD8A07       MORINP:    CALL     CLOTST      ; Get character and tes
 1075 06D8 4F                      LD       C,A         ; Save character in C
 1076 06D9 FE7F                    CP       DEL         ; Delete character?
 1077 06DB CA9B06                  JP       Z,DODEL     ; Yes - Process it
 1078 06DE 3A8980                  LD       A,(NULFLG)  ; Get null flag
 1079 06E1 B7                      OR       A           ; Test null flag status
 1080 06E2 CAEE06                  JP       Z,PROCES    ; Reset - Process chara
 1081 06E5 3E00                    LD       A,0         ; Set a null
 1082 06E7 CD6007                  CALL     OUTC        ; Output null
 1083 06EA AF                      XOR      A           ; Clear A
 1084 06EB 328980                  LD       (NULFLG),A  ; Reset null flag
 1085 06EE 79           PROCES:    LD       A,C         ; Get character
 1086 06EF FE07                    CP       CTRLG       ; Bell?
 1087 06F1 CA3207                  JP       Z,PUTCTL    ; Yes - Save it
 1088 06F4 FE03                    CP       CTRLC       ; Is it control "C"?
 1089 06F6 CC870B                  CALL     Z,PRCRLF    ; Yes - Output CRLF
 1090 06F9 37                      SCF                  ; Flag break
 1091 06FA C8                      RET      Z           ; Return if control "C"
 1092 06FB FE0D                    CP       CR          ; Is it enter?
 1093 06FD CA820B                  JP       Z,ENDINP    ; Yes - Terminate input
 1094 0700 FE15                    CP       CTRLU       ; Is it control "U"?
 1095 0702 CAC606                  JP       Z,KILIN     ; Yes - Get another lin
 1096 0705 FE40                    CP       '@'         ; Is it "kill line"?
 1097 0707 CAC306                  JP       Z,OTKLN     ; Yes - Kill line
 1098 070A FE5F                    CP       '_'         ; Is it delete?
 1099 070C CABB06                  JP       Z,DELCHR    ; Yes - Delete characte
 1100 070F FE08                    CP       BKSP        ; Is it backspace?
 1101 0711 CABB06                  JP       Z,DELCHR    ; Yes - Delete characte
 1102 0714 FE12                    CP       CTRLR       ; Is it control "R"?
 1103 0716 C22D07                  JP       NZ,PUTBUF   ; No - Put in buffer
 1104 0719 C5                      PUSH     BC          ; Save buffer length
 1105 071A D5                      PUSH     DE          ; Save DE
 1106 071B E5                      PUSH     HL          ; Save buffer address
 1107 071C 3600                    LD       (HL),0      ; Mark end of buffer
 1108 071E CD311D                  CALL     OUTNCR      ; Output and do CRLF
 1109 0721 21A680                  LD       HL,BUFFER   ; Point to buffer start
 1110 0724 CD2512                  CALL     PRS         ; Output buffer
 1111 0727 E1                      POP      HL          ; Restore buffer addres
 1112 0728 D1                      POP      DE          ; Restore DE
 1113 0729 C1                      POP      BC          ; Restore buffer length
 1114 072A C3D506                  JP       MORINP      ; Get another character
 1115                   ;
 1116 072D FE20         PUTBUF:    CP       ' '         ; Is it a control code?
 1117 072F DAD506                  JP       C,MORINP    ; Yes - Ignore
 1118 0732 78           PUTCTL:    LD       A,B         ; Get number of bytes i
 1119 0733 FE49                    CP       72+1        ; Test for line overflo
 1120 0735 3E07                    LD       A,CTRLG     ; Set a bell
 1121 0737 D24707                  JP       NC,OUTNBS   ; Ring bell if buffer f
 1122 073A 79                      LD       A,C         ; Get character
 1123 073B 71                      LD       (HL),C      ; Save in buffer
 1124 073C 321181                  LD       (LSTBIN),A  ; Save last input byte
 1125 073F 23                      INC      HL          ; Move up buffer
 1126 0740 04                      INC      B           ; Increment length
 1127 0741 CD6007       OUTIT:     CALL     OUTC        ; Output the character 
 1128 0744 C3D506                  JP       MORINP      ; Get another character
 1129                   ;
 1130 0747 CD6007       OUTNBS:    CALL     OUTC        ; Output bell and back 
 1131 074A 3E08                    LD       A,BKSP      ; Set back space
 1132 074C C34107                  JP       OUTIT       ; Output it and get mor
 1133                   ;
 1134 074F 7C           CPDEHL:    LD       A,H         ; Get H
 1135 0750 92                      SUB      D           ; Compare with D
 1136 0751 C0                      RET      NZ          ; Different - Exit
 1137 0752 7D                      LD       A,L         ; Get L
 1138 0753 93                      SUB      E           ; Compare with E
 1139 0754 C9                      RET                  ; Return status
 1140                   ;
 1141 0755 7E           CHKSYN:    LD       A,(HL)      ; Check syntax of chara
 1142 0756 E3                      EX       (SP),HL     ; Address of test byte
 1143 0757 BE                      CP       (HL)        ; Same as in code strin
 1144 0758 23                      INC      HL          ; Return address
 1145 0759 E3                      EX       (SP),HL     ; Put it back
 1146 075A CADF08                  JP       Z,GETCHR    ; Yes - Get next charac
 1147 075D C38704                  JP       SNERR       ; Different - ?SN Error
 1148                   ;
 1149 0760 F5           OUTC:      PUSH     AF          ; Save character
 1150 0761 3A8A80                  LD       A,(CTLOFG)  ; Get control "O" flag
 1151 0764 B7                      OR       A           ; Is it set?
 1152 0765 C25A12                  JP       NZ,POPAF    ; Yes - don't output
 1153 0768 F1                      POP      AF          ; Restore character
 1154 0769 C5                      PUSH     BC          ; Save buffer length
 1155 076A F5                      PUSH     AF          ; Save character
 1156 076B FE20                    CP       ' '         ; Is it a control code?
 1157 076D DA8407                  JP       C,DINPOS    ; Yes - Don't INC POS(X
 1158 0770 3A8780                  LD       A,(LWIDTH)  ; Get line width
 1159 0773 47                      LD       B,A         ; To B
 1160 0774 3AF080                  LD       A,(CURPOS)  ; Get cursor position
 1161 0777 04                      INC      B           ; Width 255?
 1162 0778 CA8007                  JP       Z,INCLEN    ; Yes - No width limit
 1163 077B 05                      DEC      B           ; Restore width
 1164 077C B8                      CP       B           ; At end of line?
 1165 077D CC870B                  CALL     Z,PRCRLF    ; Yes - output CRLF
 1166 0780 3C           INCLEN:    INC      A           ; Move on one character
 1167 0781 32F080                  LD       (CURPOS),A  ; Save new position
 1168 0784 F1           DINPOS:    POP      AF          ; Restore character
 1169 0785 C1                      POP      BC          ; Restore buffer length
 1170 0786 CD1C1D                  CALL     MONOUT      ; Send it
 1171 0789 C9                      RET
 1172                   ;
 1173 078A CDE41B       CLOTST:    CALL     GETINP      ; Get input character
 1174 078D E67F                    AND      01111111B   ; Strip bit 7
 1175 078F FE0F                    CP       CTRLO       ; Is it control "O"?
 1176 0791 C0                      RET      NZ          ; No don't flip flag
 1177 0792 3A8A80                  LD       A,(CTLOFG)  ; Get flag
 1178 0795 2F                      CPL                  ; Flip it
 1179 0796 328A80                  LD       (CTLOFG),A  ; Put it back
 1180 0799 AF                      XOR      A           ; Null character
 1181 079A C9                      RET
 1182                   ;
 1183 079B CDAB09       LIST:      CALL     ATOH        ; ASCII number to DE
 1184 079E C0                      RET      NZ          ; Return if anything ex
 1185 079F C1                      POP      BC          ; Rubbish - Not needed
 1186 07A0 CD7305                  CALL     SRCHLN      ; Search for line numbe
 1187 07A3 C5                      PUSH     BC          ; Save address of line
 1188 07A4 CDF107                  CALL     SETLIN      ; Set up lines counter
 1189 07A7 E1           LISTLP:    POP      HL          ; Restore address of li
 1190 07A8 4E                      LD       C,(HL)      ; Get LSB of next line
 1191 07A9 23                      INC      HL
 1192 07AA 46                      LD       B,(HL)      ; Get MSB of next line
 1193 07AB 23                      INC      HL
 1194 07AC 78                      LD       A,B         ; BC = 0 (End of progra
 1195 07AD B1                      OR       C
 1196 07AE CAD204                  JP       Z,PRNTOK    ; Yes - Go to command m
 1197 07B1 CDFA07                  CALL     COUNT       ; Count lines
 1198 07B4 CD0A09                  CALL     TSTBRK      ; Test for break key
 1199 07B7 C5                      PUSH     BC          ; Save address of next 
 1200 07B8 CD870B                  CALL     PRCRLF      ; Output CRLF
 1201 07BB 5E                      LD       E,(HL)      ; Get LSB of line numbe
 1202 07BC 23                      INC      HL
 1203 07BD 56                      LD       D,(HL)      ; Get MSB of line numbe
 1204 07BE 23                      INC      HL
 1205 07BF E5                      PUSH     HL          ; Save address of line 
 1206 07C0 EB                      EX       DE,HL       ; Line number to HL
 1207 07C1 CDC818                  CALL     PRNTHL      ; Output line number in
 1208 07C4 3E20                    LD       A,' '       ; Space after line numb
 1209 07C6 E1                      POP      HL          ; Restore start of line
 1210 07C7 CD6007       LSTLP2:    CALL     OUTC        ; Output character in A
 1211 07CA 7E           LSTLP3:    LD       A,(HL)      ; Get next byte in line
 1212 07CB B7                      OR       A           ; End of line?
 1213 07CC 23                      INC      HL          ; To next byte in line
 1214 07CD CAA707                  JP       Z,LISTLP    ; Yes - get next line
 1215 07D0 F2C707                  JP       P,LSTLP2    ; No token - output it
 1216 07D3 D67F                    SUB      ZEND-1      ; Find and output word
 1217 07D5 4F                      LD       C,A         ; Token offset+1 to C
 1218 07D6 111002                  LD       DE,WORDS    ; Reserved word list
 1219 07D9 1A           FNDTOK:    LD       A,(DE)      ; Get character in list
 1220 07DA 13                      INC      DE          ; Move on to next
 1221 07DB B7                      OR       A           ; Is it start of word?
 1222 07DC F2D907                  JP       P,FNDTOK    ; No - Keep looking for
 1223 07DF 0D                      DEC      C           ; Count words
 1224 07E0 C2D907                  JP       NZ,FNDTOK   ; Not there - keep look
 1225 07E3 E67F         OUTWRD:    AND      01111111B   ; Strip bit 7
 1226 07E5 CD6007                  CALL     OUTC        ; Output first characte
 1227 07E8 1A                      LD       A,(DE)      ; Get next character
 1228 07E9 13                      INC      DE          ; Move on to next
 1229 07EA B7                      OR       A           ; Is it end of word?
 1230 07EB F2E307                  JP       P,OUTWRD    ; No - output the rest
 1231 07EE C3CA07                  JP       LSTLP3      ; Next byte in line
 1232                   ;
 1233 07F1 E5           SETLIN:    PUSH     HL          ; Set up LINES counter
 1234 07F2 2A8D80                  LD       HL,(LINESN) ; Get LINES number
 1235 07F5 228B80                  LD       (LINESC),HL ; Save in LINES counter
 1236 07F8 E1                      POP      HL
 1237 07F9 C9                      RET
 1238                   ;
 1239 07FA E5           COUNT:     PUSH     HL          ; Save code string addr
 1240 07FB D5                      PUSH     DE
 1241 07FC 2A8B80                  LD       HL,(LINESC) ; Get LINES counter
 1242 07FF 11FFFF                  LD       DE,-1
 1243 0802 ED5A                    ADC      HL,DE       ; Decrement
 1244 0804 228B80                  LD       (LINESC),HL ; Put it back
 1245 0807 D1                      POP      DE
 1246 0808 E1                      POP      HL          ; Restore code string a
 1247 0809 F0                      RET      P           ; Return if more lines 
 1248 080A E5                      PUSH     HL          ; Save code string addr
 1249 080B 2A8D80                  LD       HL,(LINESN) ; Get LINES number
 1250 080E 228B80                  LD       (LINESC),HL ; Reset LINES counter
 1251 0811 CDE41B                  CALL     GETINP      ; Get input character
 1252 0814 FE03                    CP       CTRLC       ; Is it control "C"?
 1253 0816 CA1D08                  JP       Z,RSLNBK    ; Yes - Reset LINES and
 1254 0819 E1                      POP      HL          ; Restore code string a
 1255 081A C3FA07                  JP       COUNT       ; Keep on counting
 1256                   ;
 1257 081D 2A8D80       RSLNBK:    LD       HL,(LINESN) ; Get LINES number
 1258 0820 228B80                  LD       (LINESC),HL ; Reset LINES counter
 1259 0823 C35101                  JP       BRKRET      ; Go and output "Break"
 1260                   ;
 1261 0826 3E64         FOR:       LD       A,64H       ; Flag "FOR" assignment
 1262 0828 321081                  LD       (FORFLG),A  ; Save "FOR" flag
 1263 082B CD8D0A                  CALL     LET         ; Set up initial index
 1264 082E C1                      POP      BC          ; Drop RETurn address
 1265 082F E5                      PUSH     HL          ; Save code string addr
 1266 0830 CD760A                  CALL     DATA        ; Get next statement ad
 1267 0833 220C81                  LD       (LOOPST),HL ; Save it for start of 
 1268 0836 210200                  LD       HL,2        ; Offset for "FOR" bloc
 1269 0839 39                      ADD      HL,SP       ; Point to it
 1270 083A CD3404       FORSLP:    CALL     LOKFOR      ; Look for existing "FO
 1271 083D D1                      POP      DE          ; Get code string addre
 1272 083E C25608                  JP       NZ,FORFND   ; No nesting found
 1273 0841 09                      ADD      HL,BC       ; Move into "FOR" block
 1274 0842 D5                      PUSH     DE          ; Save code string addr
 1275 0843 2B                      DEC      HL
 1276 0844 56                      LD       D,(HL)      ; Get MSB of loop state
 1277 0845 2B                      DEC      HL
 1278 0846 5E                      LD       E,(HL)      ; Get LSB of loop state
 1279 0847 23                      INC      HL
 1280 0848 23                      INC      HL
 1281 0849 E5                      PUSH     HL          ; Save block address
 1282 084A 2A0C81                  LD       HL,(LOOPST) ; Get address of loop s
 1283 084D CD4F07                  CALL     CPDEHL      ; Compare the FOR loops
 1284 0850 E1                      POP      HL          ; Restore block address
 1285 0851 C23A08                  JP       NZ,FORSLP   ; Different FORs - Find
 1286 0854 D1                      POP      DE          ; Restore code string a
 1287 0855 F9                      LD       SP,HL       ; Remove all nested loo
 1288                   ;
 1289 0856 EB           FORFND:    EX       DE,HL       ; Code string address t
 1290 0857 0E08                    LD       C,8
 1291 0859 CD6404                  CALL     CHKSTK      ; Check for 8 levels of
 1292 085C E5                      PUSH     HL          ; Save code string addr
 1293 085D 2A0C81                  LD       HL,(LOOPST) ; Get first statement o
 1294 0860 E3                      EX       (SP),HL     ; Save and restore code
 1295 0861 E5                      PUSH     HL          ; Re-save code string a
 1296 0862 2AA180                  LD       HL,(LINEAT) ; Get current line numb
 1297 0865 E3                      EX       (SP),HL     ; Save and restore code
 1298 0866 CD4F0D                  CALL     TSTNUM      ; Make sure it's a numb
 1299 0869 CD5507                  CALL     CHKSYN      ; Make sure "TO" is nex
 1300 086C A6                      DB       ZTO         ; "TO" token
 1301 086D CD4C0D                  CALL     GETNUM      ; Get "TO" expression v
 1302 0870 E5                      PUSH     HL          ; Save code string addr
 1303 0871 CD7A17                  CALL     BCDEFP      ; Move "TO" value to BC
 1304 0874 E1                      POP      HL          ; Restore code string a
 1305 0875 C5                      PUSH     BC          ; Save "TO" value in bl
 1306 0876 D5                      PUSH     DE
 1307 0877 010081                  LD       BC,8100H    ; BCDE - 1 (default STE
 1308 087A 51                      LD       D,C         ; C=0
 1309 087B 5A                      LD       E,D         ; D=0
 1310 087C 7E                      LD       A,(HL)      ; Get next byte in code
 1311 087D FEAB                    CP       ZSTEP       ; See if "STEP" is stat
 1312 087F 3E01                    LD       A,1         ; Sign of step = 1
 1313 0881 C29208                  JP       NZ,SAVSTP   ; No STEP given - Defau
 1314 0884 CDDF08                  CALL     GETCHR      ; Jump over "STEP" toke
 1315 0887 CD4C0D                  CALL     GETNUM      ; Get step value
 1316 088A E5                      PUSH     HL          ; Save code string addr
 1317 088B CD7A17                  CALL     BCDEFP      ; Move STEP to BCDE
 1318 088E CD2E17                  CALL     TSTSGN      ; Test sign of FPREG
 1319 0891 E1                      POP      HL          ; Restore code string a
 1320 0892 C5           SAVSTP:    PUSH     BC          ; Save the STEP value i
 1321 0893 D5                      PUSH     DE
 1322 0894 F5                      PUSH     AF          ; Save sign of STEP
 1323 0895 33                      INC      SP          ; Don't save flags
 1324 0896 E5                      PUSH     HL          ; Save code string addr
 1325 0897 2A1381                  LD       HL,(BRKLIN) ; Get address of index 
 1326 089A E3                      EX       (SP),HL     ; Save and restore code
 1327 089B 0681         PUTFID:    LD       B,ZFOR      ; "FOR" block marker
 1328 089D C5                      PUSH     BC          ; Save it
 1329 089E 33                      INC      SP          ; Don't save C
 1330                   ;
 1331 089F CD0A09       RUNCNT:    CALL     TSTBRK      ; Execution driver - Te
 1332 08A2 221381                  LD       (BRKLIN),HL ; Save code address for
 1333 08A5 7E                      LD       A,(HL)      ; Get next byte in code
 1334 08A6 FE3A                    CP       ':'         ; Multi statement line?
 1335 08A8 CABF08                  JP       Z,EXCUTE    ; Yes - Execute it
 1336 08AB B7                      OR       A           ; End of line?
 1337 08AC C28704                  JP       NZ,SNERR    ; No - Syntax error
 1338 08AF 23                      INC      HL          ; Point to address of n
 1339 08B0 7E                      LD       A,(HL)      ; Get LSB of line point
 1340 08B1 23                      INC      HL
 1341 08B2 B6                      OR       (HL)        ; Is it zero (End of pr
 1342 08B3 CA3109                  JP       Z,ENDPRG    ; Yes - Terminate execu
 1343 08B6 23                      INC      HL          ; Point to line number
 1344 08B7 5E                      LD       E,(HL)      ; Get LSB of line numbe
 1345 08B8 23                      INC      HL
 1346 08B9 56                      LD       D,(HL)      ; Get MSB of line numbe
 1347 08BA EB                      EX       DE,HL       ; Line number to HL
 1348 08BB 22A180                  LD       (LINEAT),HL ; Save as current line 
 1349 08BE EB                      EX       DE,HL       ; Line number back to D
 1350 08BF CDDF08       EXCUTE:    CALL     GETCHR      ; Get key word
 1351 08C2 119F08                  LD       DE,RUNCNT   ; Where to RETurn to
 1352 08C5 D5                      PUSH     DE          ; Save for RETurn
 1353 08C6 C8           IFJMP:     RET      Z           ; Go to RUNCNT if end o
 1354 08C7 D680         ONJMP:     SUB      ZEND        ; Is it a token?
 1355 08C9 DA8D0A                  JP       C,LET       ; No - try to assign it
 1356 08CC FE25                    CP       ZNEW+1-ZEND ; END to NEW ?
 1357 08CE D28704                  JP       NC,SNERR    ; Not a key word - ?SN 
 1358 08D1 07                      RLCA                 ; Double it
 1359 08D2 4F                      LD       C,A         ; BC = Offset into tabl
 1360 08D3 0600                    LD       B,0
 1361 08D5 EB                      EX       DE,HL       ; Save code string addr
 1362 08D6 212F03                  LD       HL,WORDTB   ; Keyword address table
 1363 08D9 09                      ADD      HL,BC       ; Point to routine addr
 1364 08DA 4E                      LD       C,(HL)      ; Get LSB of routine ad
 1365 08DB 23                      INC      HL
 1366 08DC 46                      LD       B,(HL)      ; Get MSB of routine ad
 1367 08DD C5                      PUSH     BC          ; Save routine address
 1368 08DE EB                      EX       DE,HL       ; Restore code string a
 1369                   ;
 1370 08DF 23           GETCHR:    INC      HL          ; Point to next charact
 1371 08E0 7E                      LD       A,(HL)      ; Get next code string 
 1372 08E1 FE3A                    CP       ':'         ; Z if ':'
 1373 08E3 D0                      RET      NC          ; NC if > "9"
 1374 08E4 FE20                    CP       ' '
 1375 08E6 CADF08                  JP       Z,GETCHR    ; Skip over spaces
 1376 08E9 FE30                    CP       '0'
 1377 08EB 3F                      CCF                  ; NC if < '0'
 1378 08EC 3C                      INC      A           ; Test for zero - Leave
 1379 08ED 3D                      DEC      A           ; Z if Null
 1380 08EE C9                      RET
 1381                   ;
 1382 08EF EB           RESTOR:    EX       DE,HL       ; Save code string addr
 1383 08F0 2AA380                  LD       HL,(BASTXT) ; Point to start of pro
 1384 08F3 CA0409                  JP       Z,RESTNL    ; Just RESTORE - reset 
 1385 08F6 EB                      EX       DE,HL       ; Restore code string a
 1386 08F7 CDAB09                  CALL     ATOH        ; Get line number to DE
 1387 08FA E5                      PUSH     HL          ; Save code string addr
 1388 08FB CD7305                  CALL     SRCHLN      ; Search for line numbe
 1389 08FE 60                      LD       H,B         ; HL = Address of line
 1390 08FF 69                      LD       L,C
 1391 0900 D1                      POP      DE          ; Restore code string a
 1392 0901 D24C0A                  JP       NC,ULERR    ; ?UL Error if not foun
 1393 0904 2B           RESTNL:    DEC      HL          ; Byte before DATA stat
 1394 0905 222181       UPDATA:    LD       (NXTDAT),HL ; Update DATA pointer
 1395 0908 EB                      EX       DE,HL       ; Restore code string a
 1396 0909 C9                      RET
 1397                   ;
 1398                   
 1399 090A DF           TSTBRK:    RST      18H         ; Check input status
 1400 090B C8                      RET      Z           ; No key, go back
 1401 090C D7                      RST      10H         ; Get the key into A
 1402 090D FE1B                    CP       ESC         ; Escape key?
 1403 090F 2811                    JR       Z,BRK       ; Yes, break
 1404 0911 FE03                    CP       CTRLC       ; <Ctrl-C>
 1405 0913 280D                    JR       Z,BRK       ; Yes, break
 1406 0915 FE13                    CP       CTRLS       ; Stop scrolling?
 1407 0917 C0                      RET      NZ          ; Other key, ignore
 1408                   ;
 1409                   
 1410 0918 D7           STALL:     RST      10H         ; Wait for key
 1411 0919 FE11                    CP       CTRLQ       ; Resume scrolling?
 1412 091B C8                      RET      Z           ; Release the chokehold
 1413 091C FE03                    CP       CTRLC       ; Second break?
 1414 091E 2807                    JR       Z,STOP      ; Break during hold exi
 1415 0920 18F6                    JR       STALL       ; Loop until <Ctrl-Q> o
 1416                   ;
 1417 0922 3EFF         BRK        LD       A,0FFH      ; Set BRKFLG
 1418 0924 329280                  LD       (BRKFLG),A  ; Store it
 1419                   ;
 1420                   
 1421 0927 C0           STOP:      RET      NZ          ; Exit if anything else
 1422 0928 F6                      DB       0F6H        ; Flag "STOP"
 1423 0929 C0           PEND:      RET      NZ          ; Exit if anything else
 1424 092A 221381                  LD       (BRKLIN),HL ; Save point of break
 1425 092D 21                      DB       21H         ; Skip "OR 11111111B"
 1426 092E F6FF         INPBRK:    OR       11111111B   ; Flag "Break" wanted
 1427 0930 C1                      POP      BC          ; Return not needed and
 1428 0931 2AA180       ENDPRG:    LD       HL,(LINEAT) ; Get current line numb
 1429 0934 F5                      PUSH     AF          ; Save STOP / END statu
 1430 0935 7D                      LD       A,L         ; Is it direct break?
 1431 0936 A4                      AND      H
 1432 0937 3C                      INC      A           ; Line is -1 if direct 
 1433 0938 CA4409                  JP       Z,NOLIN     ; Yes - No line number
 1434 093B 221781                  LD       (ERRLIN),HL ; Save line of break
 1435 093E 2A1381                  LD       HL,(BRKLIN) ; Get point of break
 1436 0941 221981                  LD       (CONTAD),HL ; Save point to CONTinu
 1437 0944 AF           NOLIN:     XOR      A
 1438 0945 328A80                  LD       (CTLOFG),A  ; Enable output
 1439 0948 CD7A0B                  CALL     STTLIN      ; Start a new line
 1440 094B F1                      POP      AF          ; Restore STOP / END st
 1441 094C 212A04                  LD       HL,BRKMSG   ; "Break" message
 1442 094F C2BB04                  JP       NZ,ERRIN    ; "in line" wanted?
 1443 0952 C3D204                  JP       PRNTOK      ; Go to command mode
 1444                   ;
 1445 0955 2A1981       CONT:      LD       HL,(CONTAD) ; Get CONTinue address
 1446 0958 7C                      LD       A,H         ; Is it zero?
 1447 0959 B5                      OR       L
 1448 095A 1E20                    LD       E,CN        ; ?CN Error
 1449 095C CA9B04                  JP       Z,ERROR     ; Yes - output "?CN Err
 1450 095F EB                      EX       DE,HL       ; Save code string addr
 1451 0960 2A1781                  LD       HL,(ERRLIN) ; Get line of last brea
 1452 0963 22A180                  LD       (LINEAT),HL ; Set up current line n
 1453 0966 EB                      EX       DE,HL       ; Restore code string a
 1454 0967 C9                      RET                  ; CONTinue where left o
 1455                   ;
 1456 0968 CDAD14       NULL:      CALL     GETINT      ; Get integer 0-255
 1457 096B C0                      RET      NZ          ; Return if bad value
 1458 096C 328680                  LD       (NULLS),A   ; Set nulls number
 1459 096F C9                      RET
 1460                   ;
 1461                   
 1462 0970 E5           ACCSUM:    PUSH     HL          ; Save address in array
 1463 0971 2A8F80                  LD       HL,(CHKSUM) ; Get check sum
 1464 0974 0600                    LD       B,0         ; BC - Value of byte
 1465 0976 4F                      LD       C,A
 1466 0977 09                      ADD      HL,BC       ; Add byte to check sum
 1467 0978 228F80                  LD       (CHKSUM),HL ; Re-save check sum
 1468 097B E1                      POP      HL          ; Restore address in ar
 1469 097C C9                      RET
 1470                   ;
 1471 097D 7E           CHKLTR:    LD       A,(HL)      ; Get byte
 1472 097E FE41                    CP       'A'         ; < 'a' ?
 1473 0980 D8                      RET      C           ; Carry set if not lett
 1474 0981 FE5B                    CP       'Z'+1       ; > 'z' ?
 1475 0983 3F                      CCF
 1476 0984 C9                      RET                  ; Carry set if not lett
 1477                   ;
 1478 0985 CDDF08       FPSINT:    CALL     GETCHR      ; Get next character
 1479 0988 CD4C0D       POSINT:    CALL     GETNUM      ; Get integer 0 to 3276
 1480 098B CD2E17       DEPINT:    CALL     TSTSGN      ; Test sign of FPREG
 1481 098E FAA609                  JP       M,FCERR     ; Negative - ?FC Error
 1482 0991 3A2C81       DEINT:     LD       A,(FPEXP)   ; Get integer value to 
 1483 0994 FE90                    CP       80H+16      ; Exponent in range (16
 1484 0996 DAD617                  JP       C,FPINT     ; Yes - convert it
 1485 0999 018090                  LD       BC,9080H    ; BCDE = -32768
 1486 099C 110000                  LD       DE,0000
 1487 099F E5                      PUSH     HL          ; Save code string addr
 1488 09A0 CDA917                  CALL     CMPNUM      ; Compare FPREG with BC
 1489 09A3 E1                      POP      HL          ; Restore code string a
 1490 09A4 51                      LD       D,C         ; MSB to D
 1491 09A5 C8                      RET      Z           ; Return if in range
 1492 09A6 1E08         FCERR:     LD       E,FC        ; ?FC Error
 1493 09A8 C39B04                  JP       ERROR       ; Output error-
 1494                   ;
 1495 09AB 2B           ATOH:      DEC      HL          ; ASCII number to DE bi
 1496 09AC 110000       GETLN:     LD       DE,0        ; Get number to DE
 1497 09AF CDDF08       GTLNLP:    CALL     GETCHR      ; Get next character
 1498 09B2 D0                      RET      NC          ; Exit if not a digit
 1499 09B3 E5                      PUSH     HL          ; Save code string addr
 1500 09B4 F5                      PUSH     AF          ; Save digit
 1501 09B5 219819                  LD       HL,65529/10 ; Largest number 65529
 1502 09B8 CD4F07                  CALL     CPDEHL      ; Number in range?
 1503 09BB DA8704                  JP       C,SNERR     ; No - ?SN Error
 1504 09BE 62                      LD       H,D         ; HL = Number
 1505 09BF 6B                      LD       L,E
 1506 09C0 19                      ADD      HL,DE       ; Times 2
 1507 09C1 29                      ADD      HL,HL       ; Times 4
 1508 09C2 19                      ADD      HL,DE       ; Times 5
 1509 09C3 29                      ADD      HL,HL       ; Times 10
 1510 09C4 F1                      POP      AF          ; Restore digit
 1511 09C5 D630                    SUB      '0'         ; Make it 0 to 9
 1512 09C7 5F                      LD       E,A         ; DE = Value of digit
 1513 09C8 1600                    LD       D,0
 1514 09CA 19                      ADD      HL,DE       ; Add to number
 1515 09CB EB                      EX       DE,HL       ; Number to DE
 1516 09CC E1                      POP      HL          ; Restore code string a
 1517 09CD C3AF09                  JP       GTLNLP      ; Go to next character
 1518                   ;
 1519 09D0 CAA305       CLEAR:     JP       Z,INTVAR    ; Just "CLEAR" Keep par
 1520 09D3 CD8809                  CALL     POSINT      ; Get integer 0 to 3276
 1521 09D6 2B                      DEC      HL          ; Cancel increment
 1522 09D7 CDDF08                  CALL     GETCHR      ; Get next character
 1523 09DA E5                      PUSH     HL          ; Save code string addr
 1524 09DB 2AF480                  LD       HL,(LSTRAM) ; Get end of RAM
 1525 09DE CAF309                  JP       Z,STORED    ; No value given - Use 
 1526 09E1 E1                      POP      HL          ; Restore code string a
 1527 09E2 CD5507                  CALL     CHKSYN      ; Check for comma
 1528 09E5 2C                      DB       ','
 1529 09E6 D5                      PUSH     DE          ; Save number
 1530 09E7 CD8809                  CALL     POSINT      ; Get integer 0 to 3276
 1531 09EA 2B                      DEC      HL          ; Cancel increment
 1532 09EB CDDF08                  CALL     GETCHR      ; Get next character
 1533 09EE C28704                  JP       NZ,SNERR    ; ?SN Error if more on 
 1534 09F1 E3                      EX       (SP),HL     ; Save code string addr
 1535 09F2 EB                      EX       DE,HL       ; Number to DE
 1536 09F3 7D           STORED:    LD       A,L         ; Get LSB of new RAM to
 1537 09F4 93                      SUB      E           ; Subtract LSB of strin
 1538 09F5 5F                      LD       E,A         ; Save LSB
 1539 09F6 7C                      LD       A,H         ; Get MSB of new RAM to
 1540 09F7 9A                      SBC      A,D         ; Subtract MSB of strin
 1541 09F8 57                      LD       D,A         ; Save MSB
 1542 09F9 DA7C04                  JP       C,OMERR     ; ?OM Error if not enou
 1543 09FC E5                      PUSH     HL          ; Save RAM top
 1544 09FD 2A1B81                  LD       HL,(PROGND) ; Get program end
 1545 0A00 012800                  LD       BC,40       ; 40 Bytes minimum work
 1546 0A03 09                      ADD      HL,BC       ; Get lowest address
 1547 0A04 CD4F07                  CALL     CPDEHL      ; Enough memory?
 1548 0A07 D27C04                  JP       NC,OMERR    ; No - ?OM Error
 1549 0A0A EB                      EX       DE,HL       ; RAM top to HL
 1550 0A0B 229F80                  LD       (STRSPC),HL ; Set new string space
 1551 0A0E E1                      POP      HL          ; End of memory to use
 1552 0A0F 22F480                  LD       (LSTRAM),HL ; Set new top of RAM
 1553 0A12 E1                      POP      HL          ; Restore code string a
 1554 0A13 C3A305                  JP       INTVAR      ; Initialise variables
 1555                   ;
 1556 0A16 CA9F05       RUN:       JP       Z,RUNFST    ; RUN from start if jus
 1557 0A19 CDA305                  CALL     INTVAR      ; Initialise variables
 1558 0A1C 019F08                  LD       BC,RUNCNT   ; Execution driver loop
 1559 0A1F C3320A                  JP       RUNLIN      ; RUN from line number
 1560                   ;
 1561 0A22 0E03         GOSUB:     LD       C,3         ; 3 Levels of stack nee
 1562 0A24 CD6404                  CALL     CHKSTK      ; Check for 3 levels of
 1563 0A27 C1                      POP      BC          ; Get return address
 1564 0A28 E5                      PUSH     HL          ; Save code string for 
 1565 0A29 E5                      PUSH     HL          ; And for GOSUB routine
 1566 0A2A 2AA180                  LD       HL,(LINEAT) ; Get current line
 1567 0A2D E3                      EX       (SP),HL     ; Into stack - Code str
 1568 0A2E 3E8C                    LD       A,ZGOSUB    ; "GOSUB" token
 1569 0A30 F5                      PUSH     AF          ; Save token
 1570 0A31 33                      INC      SP          ; Don't save flags
 1571                   ;
 1572 0A32 C5           RUNLIN:    PUSH     BC          ; Save return address
 1573 0A33 CDAB09       GOTO:      CALL     ATOH        ; ASCII number to DE bi
 1574 0A36 CD780A                  CALL     REM         ; Get end of line
 1575 0A39 E5                      PUSH     HL          ; Save end of line
 1576 0A3A 2AA180                  LD       HL,(LINEAT) ; Get current line
 1577 0A3D CD4F07                  CALL     CPDEHL      ; Line after current?
 1578 0A40 E1                      POP      HL          ; Restore end of line
 1579 0A41 23                      INC      HL          ; Start of next line
 1580 0A42 DC7605                  CALL     C,SRCHLP    ; Line is after current
 1581 0A45 D47305                  CALL     NC,SRCHLN   ; Line is before curren
 1582 0A48 60                      LD       H,B         ; Set up code string ad
 1583 0A49 69                      LD       L,C
 1584 0A4A 2B                      DEC      HL          ; Incremented after
 1585 0A4B D8                      RET      C           ; Line found
 1586 0A4C 1E0E         ULERR:     LD       E,UL        ; ?UL Error
 1587 0A4E C39B04                  JP       ERROR       ; Output error message
 1588                   ;
 1589 0A51 C0           RETURN:    RET      NZ          ; Return if not just RE
 1590 0A52 16FF                    LD       D,-1        ; Flag "GOSUB" search
 1591 0A54 CD3004                  CALL     BAKSTK      ; Look "GOSUB" block
 1592 0A57 F9                      LD       SP,HL       ; Kill all FORs in subr
 1593 0A58 FE8C                    CP       ZGOSUB      ; Test for "GOSUB" toke
 1594 0A5A 1E04                    LD       E,RG        ; ?RG Error
 1595 0A5C C29B04                  JP       NZ,ERROR    ; Error if no "GOSUB" f
 1596 0A5F E1                      POP      HL          ; Get RETURN line numbe
 1597 0A60 22A180                  LD       (LINEAT),HL ; Save as current
 1598 0A63 23                      INC      HL          ; Was it from direct st
 1599 0A64 7C                      LD       A,H
 1600 0A65 B5                      OR       L           ; Return to line
 1601 0A66 C2700A                  JP       NZ,RETLIN   ; No - Return to line
 1602 0A69 3A1181                  LD       A,(LSTBIN)  ; Any INPUT in subrouti
 1603 0A6C B7                      OR       A           ; If so buffer is corru
 1604 0A6D C2D104                  JP       NZ,POPNOK   ; Yes - Go to command m
 1605 0A70 219F08       RETLIN:    LD       HL,RUNCNT   ; Execution driver loop
 1606 0A73 E3                      EX       (SP),HL     ; Into stack - Code str
 1607 0A74 3E                      DB       3EH         ; Skip "POP HL"
 1608 0A75 E1           NXTDTA:    POP      HL          ; Restore code string a
 1609                   ;
 1610 0A76 013A         DATA:      DB       01H,3AH     ; ':' End of statement
 1611 0A78 0E00         REM:       LD       C,0         ; 00    End of statemen
 1612 0A7A 0600                    LD       B,0
 1613 0A7C 79           NXTSTL:    LD       A,C         ; Statement and byte
 1614 0A7D 48                      LD       C,B
 1615 0A7E 47                      LD       B,A         ; Statement end byte
 1616 0A7F 7E           NXTSTT:    LD       A,(HL)      ; Get byte
 1617 0A80 B7                      OR       A           ; End of line?
 1618 0A81 C8                      RET      Z           ; Yes - Exit
 1619 0A82 B8                      CP       B           ; End of statement?
 1620 0A83 C8                      RET      Z           ; Yes - Exit
 1621 0A84 23                      INC      HL          ; Next byte
 1622 0A85 FE22                    CP       '"'         ; Literal string?
 1623 0A87 CA7C0A                  JP       Z,NXTSTL    ; Yes - Look for anothe
 1624 0A8A C37F0A                  JP       NXTSTT      ; Keep looking
 1625                   ;
 1626 0A8D CD420F       LET:       CALL     GETVAR      ; Get variable name
 1627 0A90 CD5507                  CALL     CHKSYN      ; Make sure "=" follows
 1628 0A93 B4                      DB       ZEQUAL      ; "=" token
 1629 0A94 D5                      PUSH     DE          ; Save address of varia
 1630 0A95 3AF280                  LD       A,(TYPE)    ; Get data type
 1631 0A98 F5                      PUSH     AF          ; Save type
 1632 0A99 CD5E0D                  CALL     EVAL        ; Evaluate expression
 1633 0A9C F1                      POP      AF          ; Restore type
 1634 0A9D E3                      EX       (SP),HL     ; Save code - Get var a
 1635 0A9E 221381                  LD       (BRKLIN),HL ; Save address of varia
 1636 0AA1 1F                      RRA                  ; Adjust type
 1637 0AA2 CD510D                  CALL     CHKTYP      ; Check types are the s
 1638 0AA5 CAE00A                  JP       Z,LETNUM    ; Numeric - Move value
 1639 0AA8 E5           LETSTR:    PUSH     HL          ; Save address of strin
 1640 0AA9 2A2981                  LD       HL,(FPREG)  ; Pointer to string ent
 1641 0AAC E5                      PUSH     HL          ; Save it on stack
 1642 0AAD 23                      INC      HL          ; Skip over length
 1643 0AAE 23                      INC      HL
 1644 0AAF 5E                      LD       E,(HL)      ; LSB of string address
 1645 0AB0 23                      INC      HL
 1646 0AB1 56                      LD       D,(HL)      ; MSB of string address
 1647 0AB2 2AA380                  LD       HL,(BASTXT) ; Point to start of pro
 1648 0AB5 CD4F07                  CALL     CPDEHL      ; Is string before prog
 1649 0AB8 D2CF0A                  JP       NC,CRESTR   ; Yes - Create string e
 1650 0ABB 2A9F80                  LD       HL,(STRSPC) ; Point to string space
 1651 0ABE CD4F07                  CALL     CPDEHL      ; Is string literal in 
 1652 0AC1 D1                      POP      DE          ; Restore address of st
 1653 0AC2 D2D70A                  JP       NC,MVSTPT   ; Yes - Set up pointer
 1654 0AC5 210481                  LD       HL,TMPSTR   ; Temporary string pool
 1655 0AC8 CD4F07                  CALL     CPDEHL      ; Is string in temporar
 1656 0ACB D2D70A                  JP       NC,MVSTPT   ; No - Set up pointer
 1657 0ACE 3E                      DB       3EH         ; Skip "POP DE"
 1658 0ACF D1           CRESTR:    POP      DE          ; Restore address of st
 1659 0AD0 CD8613                  CALL     BAKTMP      ; Back to last tmp-str 
 1660 0AD3 EB                      EX       DE,HL       ; Address of string ent
 1661 0AD4 CDBF11                  CALL     SAVSTR      ; Save string in string
 1662 0AD7 CD8613       MVSTPT:    CALL     BAKTMP      ; Back to last tmp-str 
 1663 0ADA E1                      POP      HL          ; Get string pointer
 1664 0ADB CD8917                  CALL     DETHL4      ; Move string pointer t
 1665 0ADE E1                      POP      HL          ; Restore code string a
 1666 0ADF C9                      RET
 1667                   ;
 1668 0AE0 E5           LETNUM:    PUSH     HL          ; Save address of varia
 1669 0AE1 CD8617                  CALL     FPTHL       ; Move value to variabl
 1670 0AE4 D1                      POP      DE          ; Restore address of va
 1671 0AE5 E1                      POP      HL          ; Restore code string a
 1672 0AE6 C9                      RET
 1673                   ;
 1674 0AE7 CDAD14       ON:        CALL     GETINT      ; Get integer 0-255
 1675 0AEA 7E                      LD       A,(HL)      ; Get "GOTO" or "GOSUB"
 1676 0AEB 47                      LD       B,A         ; Save in B
 1677 0AEC FE8C                    CP       ZGOSUB      ; "GOSUB" token?
 1678 0AEE CAF60A                  JP       Z,ONGO      ; Yes - Find line numbe
 1679 0AF1 CD5507                  CALL     CHKSYN      ; Make sure it's "GOTO"
 1680 0AF4 88                      DB       ZGOTO       ; "GOTO" token
 1681 0AF5 2B                      DEC      HL          ; Cancel increment
 1682 0AF6 4B           ONGO:      LD       C,E         ; Integer of branch val
 1683 0AF7 0D           ONGOLP:    DEC      C           ; Count branches
 1684 0AF8 78                      LD       A,B         ; Get "GOTO" or "GOSUB"
 1685 0AF9 CAC708                  JP       Z,ONJMP     ; Go to that line if ri
 1686 0AFC CDAC09                  CALL     GETLN       ; Get line number to DE
 1687 0AFF FE2C                    CP       ','         ; Another line number?
 1688 0B01 C0                      RET      NZ          ; No - Drop through
 1689 0B02 C3F70A                  JP       ONGOLP      ; Yes - loop
 1690                   ;
 1691 0B05 CD5E0D       IF:        CALL     EVAL        ; Evaluate expression
 1692 0B08 7E                      LD       A,(HL)      ; Get token
 1693 0B09 FE88                    CP       ZGOTO       ; "GOTO" token?
 1694 0B0B CA130B                  JP       Z,IFGO      ; Yes - Get line
 1695 0B0E CD5507                  CALL     CHKSYN      ; Make sure it's "THEN"
 1696 0B11 A9                      DB       ZTHEN       ; "THEN" token
 1697 0B12 2B                      DEC      HL          ; Cancel increment
 1698 0B13 CD4F0D       IFGO:      CALL     TSTNUM      ; Make sure it's numeri
 1699 0B16 CD2E17                  CALL     TSTSGN      ; Test state of express
 1700 0B19 CA780A                  JP       Z,REM       ; False - Drop through
 1701 0B1C CDDF08                  CALL     GETCHR      ; Get next character
 1702 0B1F DA330A                  JP       C,GOTO      ; Number - GOTO that li
 1703 0B22 C3C608                  JP       IFJMP       ; Otherwise do statemen
 1704                   ;
 1705 0B25 2B           MRPRNT:    DEC      HL          ; DEC 'cos GETCHR INCs
 1706 0B26 CDDF08                  CALL     GETCHR      ; Get next character
 1707 0B29 CA870B       PRINT:     JP       Z,PRCRLF    ; CRLF if just PRINT
 1708 0B2C C8           PRNTLP:    RET      Z           ; End of list - Exit
 1709 0B2D FEA5                    CP       ZTAB        ; "TAB(" token?
 1710 0B2F CABA0B                  JP       Z,DOTAB     ; Yes - Do TAB routine
 1711 0B32 FEA8                    CP       ZSPC        ; "SPC(" token?
 1712 0B34 CABA0B                  JP       Z,DOTAB     ; Yes - Do SPC routine
 1713 0B37 E5                      PUSH     HL          ; Save code string addr
 1714 0B38 FE2C                    CP       ','         ; Comma?
 1715 0B3A CAA30B                  JP       Z,DOCOM     ; Yes - Move to next zo
 1716 0B3D FE3B                    CP       59          ;";"          ; Semi-co
 1717 0B3F CADD0B                  JP       Z,NEXITM    ; Do semi-colon routine
 1718 0B42 C1                      POP      BC          ; Code string address t
 1719 0B43 CD5E0D                  CALL     EVAL        ; Evaluate expression
 1720 0B46 E5                      PUSH     HL          ; Save code string addr
 1721 0B47 3AF280                  LD       A,(TYPE)    ; Get variable type
 1722 0B4A B7                      OR       A           ; Is it a string variab
 1723 0B4B C2730B                  JP       NZ,PRNTST   ; Yes - Output string c
 1724 0B4E CDD318                  CALL     NUMASC      ; Convert number to tex
 1725 0B51 CDE311                  CALL     CRTST       ; Create temporary stri
 1726 0B54 3620                    LD       (HL),' '    ; Followed by a space
 1727 0B56 2A2981                  LD       HL,(FPREG)  ; Get length of output
 1728 0B59 34                      INC      (HL)        ; Plus 1 for the space
 1729 0B5A 2A2981                  LD       HL,(FPREG)  ; < Not needed >
 1730 0B5D 3A8780                  LD       A,(LWIDTH)  ; Get width of line
 1731 0B60 47                      LD       B,A         ; To B
 1732 0B61 04                      INC      B           ; Width 255 (No limit)?
 1733 0B62 CA6F0B                  JP       Z,PRNTNB    ; Yes - Output number s
 1734 0B65 04                      INC      B           ; Adjust it
 1735 0B66 3AF080                  LD       A,(CURPOS)  ; Get cursor position
 1736 0B69 86                      ADD      A,(HL)      ; Add length of string
 1737 0B6A 3D                      DEC      A           ; Adjust it
 1738 0B6B B8                      CP       B           ; Will output fit on th
 1739 0B6C D4870B                  CALL     NC,PRCRLF   ; No - CRLF first
 1740 0B6F CD2812       PRNTNB:    CALL     PRS1        ; Output string at (HL)
 1741 0B72 AF                      XOR      A           ; Skip CALL by setting 
 1742 0B73 C42812       PRNTST:    CALL     NZ,PRS1     ; Output string at (HL)
 1743 0B76 E1                      POP      HL          ; Restore code string a
 1744 0B77 C3250B                  JP       MRPRNT      ; See if more to PRINT
 1745                   ;
 1746 0B7A 3AF080       STTLIN:    LD       A,(CURPOS)  ; Make sure on new line
 1747 0B7D B7                      OR       A           ; Already at start?
 1748 0B7E C8                      RET      Z           ; Yes - Do nothing
 1749 0B7F C3870B                  JP       PRCRLF      ; Start a new line
 1750                   ;
 1751 0B82 3600         ENDINP:    LD       (HL),0      ; Mark end of buffer
 1752 0B84 21A580                  LD       HL,BUFFER-1 ; Point to buffer
 1753 0B87 3E0D         PRCRLF:    LD       A,CR        ; Load a CR
 1754 0B89 CD6007                  CALL     OUTC        ; Output character
 1755 0B8C 3E0A                    LD       A,LF        ; Load a LF
 1756 0B8E CD6007                  CALL     OUTC        ; Output character
 1757 0B91 AF           DONULL:    XOR      A           ; Set to position 0
 1758 0B92 32F080                  LD       (CURPOS),A  ; Store it
 1759 0B95 3A8680                  LD       A,(NULLS)   ; Get number of nulls
 1760 0B98 3D           NULLP:     DEC      A           ; Count them
 1761 0B99 C8                      RET      Z           ; Return if done
 1762 0B9A F5                      PUSH     AF          ; Save count
 1763 0B9B AF                      XOR      A           ; Load a null
 1764 0B9C CD6007                  CALL     OUTC        ; Output it
 1765 0B9F F1                      POP      AF          ; Restore count
 1766 0BA0 C3980B                  JP       NULLP       ; Keep counting
 1767                   ;
 1768 0BA3 3A8880       DOCOM:     LD       A,(COMMAN)  ; Get comma width
 1769 0BA6 47                      LD       B,A         ; Save in B
 1770 0BA7 3AF080                  LD       A,(CURPOS)  ; Get current position
 1771 0BAA B8                      CP       B           ; Within the limit?
 1772 0BAB D4870B                  CALL     NC,PRCRLF   ; No - output CRLF
 1773 0BAE D2DD0B                  JP       NC,NEXITM   ; Get next item
 1774 0BB1 D60E         ZONELP:    SUB      14          ; Next zone of 14 chara
 1775 0BB3 D2B10B                  JP       NC,ZONELP   ; Repeat if more zones
 1776 0BB6 2F                      CPL                  ; Number of spaces to o
 1777 0BB7 C3D20B                  JP       ASPCS       ; Output them
 1778                   ;
 1779 0BBA F5           DOTAB:     PUSH     AF          ; Save token
 1780 0BBB CDAA14                  CALL     FNDNUM      ; Evaluate expression
 1781 0BBE CD5507                  CALL     CHKSYN      ; Make sure ")" follows
 1782 0BC1 29                      DB       ")"
 1783 0BC2 2B                      DEC      HL          ; Back space on to ")"
 1784 0BC3 F1                      POP      AF          ; Restore token
 1785 0BC4 D6A8                    SUB      ZSPC        ; Was it "SPC(" ?
 1786 0BC6 E5                      PUSH     HL          ; Save code string addr
 1787 0BC7 CACD0B                  JP       Z,DOSPC     ; Yes - Do 'E' spaces
 1788 0BCA 3AF080                  LD       A,(CURPOS)  ; Get current position
 1789 0BCD 2F           DOSPC:     CPL                  ; Number of spaces to p
 1790 0BCE 83                      ADD      A,E         ; Total number to print
 1791 0BCF D2DD0B                  JP       NC,NEXITM   ; TAB < Current POS(X)
 1792 0BD2 3C           ASPCS:     INC      A           ; Output A spaces
 1793 0BD3 47                      LD       B,A         ; Save number to print
 1794 0BD4 3E20                    LD       A,' '       ; Space
 1795 0BD6 CD6007       SPCLP:     CALL     OUTC        ; Output character in A
 1796 0BD9 05                      DEC      B           ; Count them
 1797 0BDA C2D60B                  JP       NZ,SPCLP    ; Repeat if more
 1798 0BDD E1           NEXITM:    POP      HL          ; Restore code string a
 1799 0BDE CDDF08                  CALL     GETCHR      ; Get next character
 1800 0BE1 C32C0B                  JP       PRNTLP      ; More to print
 1801                   ;
 1802 0BE4 3F5265646F20 REDO:      DB       "?Redo from start",CR,LF,0
           66726F6D2073 
           746172740D0A 
           00           
 1803                   ;
 1804 0BF7 3A1281       BADINP:    LD       A,(READFG)  ; READ or INPUT?
 1805 0BFA B7                      OR       A
 1806 0BFB C28104                  JP       NZ,DATSNR   ; READ - ?SN Error
 1807 0BFE C1                      POP      BC          ; Throw away code strin
 1808 0BFF 21E40B                  LD       HL,REDO     ; "Redo from start" mes
 1809 0C02 CD2512                  CALL     PRS         ; Output string
 1810 0C05 C3D205                  JP       DOAGN       ; Do last INPUT again
 1811                   ;
 1812 0C08 CD9011       INPUT:     CALL     IDTEST      ; Test for illegal dire
 1813 0C0B 7E                      LD       A,(HL)      ; Get character after "
 1814 0C0C FE22                    CP       '"'         ; Is there a prompt str
 1815 0C0E 3E00                    LD       A,0         ; Clear A and leave fla
 1816 0C10 328A80                  LD       (CTLOFG),A  ; Enable output
 1817 0C13 C2220C                  JP       NZ,NOPMPT   ; No prompt - get input
 1818 0C16 CDE411                  CALL     QTSTR       ; Get string terminated
 1819 0C19 CD5507                  CALL     CHKSYN      ; Check for ';' after p
 1820 0C1C 3B                      DB       ';'
 1821 0C1D E5                      PUSH     HL          ; Save code string addr
 1822 0C1E CD2812                  CALL     PRS1        ; Output prompt string
 1823 0C21 3E                      DB       3EH         ; Skip "PUSH HL"
 1824 0C22 E5           NOPMPT:    PUSH     HL          ; Save code string addr
 1825 0C23 CDD605                  CALL     PROMPT      ; Get input with "? " p
 1826 0C26 C1                      POP      BC          ; Restore code string a
 1827 0C27 DA2E09                  JP       C,INPBRK    ; Break pressed - Exit
 1828 0C2A 23                      INC      HL          ; Next byte
 1829 0C2B 7E                      LD       A,(HL)      ; Get it
 1830 0C2C B7                      OR       A           ; End of line?
 1831 0C2D 2B                      DEC      HL          ; Back again
 1832 0C2E C5                      PUSH     BC          ; Re-save code string a
 1833 0C2F CA750A                  JP       Z,NXTDTA    ; Yes - Find next DATA 
 1834 0C32 362C                    LD       (HL),','    ; Store comma as separa
 1835 0C34 C33C0C                  JP       NXTITM      ; Get next item
 1836                   ;
 1837 0C37 E5           READ:      PUSH     HL          ; Save code string addr
 1838 0C38 2A2181                  LD       HL,(NXTDAT) ; Next DATA statement
 1839 0C3B F6                      DB       0F6H        ; Flag "READ"
 1840 0C3C AF           NXTITM:    XOR      A           ; Flag "INPUT"
 1841 0C3D 321281                  LD       (READFG),A  ; Save "READ"/"INPUT" f
 1842 0C40 E3                      EX       (SP),HL     ; Get code str' , Save 
 1843 0C41 C3480C                  JP       GTVLUS      ; Get values
 1844                   ;
 1845 0C44 CD5507       NEDMOR:    CALL     CHKSYN      ; Check for comma betwe
 1846 0C47 2C                      DB       ','
 1847 0C48 CD420F       GTVLUS:    CALL     GETVAR      ; Get variable name
 1848 0C4B E3                      EX       (SP),HL     ; Save code str" , Get 
 1849 0C4C D5                      PUSH     DE          ; Save variable address
 1850 0C4D 7E                      LD       A,(HL)      ; Get next "INPUT"/"DAT
 1851 0C4E FE2C                    CP       ','         ; Comma?
 1852 0C50 CA700C                  JP       Z,ANTVLU    ; Yes - Get another val
 1853 0C53 3A1281                  LD       A,(READFG)  ; Is it READ?
 1854 0C56 B7                      OR       A
 1855 0C57 C2DD0C                  JP       NZ,FDTLP    ; Yes - Find next DATA 
 1856 0C5A 3E3F                    LD       A,'?'       ; More INPUT needed
 1857 0C5C CD6007                  CALL     OUTC        ; Output character
 1858 0C5F CDD605                  CALL     PROMPT      ; Get INPUT with prompt
 1859 0C62 D1                      POP      DE          ; Variable address
 1860 0C63 C1                      POP      BC          ; Code string address
 1861 0C64 DA2E09                  JP       C,INPBRK    ; Break pressed
 1862 0C67 23                      INC      HL          ; Point to next DATA by
 1863 0C68 7E                      LD       A,(HL)      ; Get byte
 1864 0C69 B7                      OR       A           ; Is it zero (No input)
 1865 0C6A 2B                      DEC      HL          ; Back space INPUT poin
 1866 0C6B C5                      PUSH     BC          ; Save code string addr
 1867 0C6C CA750A                  JP       Z,NXTDTA    ; Find end of buffer
 1868 0C6F D5                      PUSH     DE          ; Save variable address
 1869 0C70 3AF280       ANTVLU:    LD       A,(TYPE)    ; Check data type
 1870 0C73 B7                      OR       A           ; Is it numeric?
 1871 0C74 CA9A0C                  JP       Z,INPBIN    ; Yes - Convert to bina
 1872 0C77 CDDF08                  CALL     GETCHR      ; Get next character
 1873 0C7A 57                      LD       D,A         ; Save input character
 1874 0C7B 47                      LD       B,A         ; Again
 1875 0C7C FE22                    CP       '"'         ; Start of literal stin
 1876 0C7E CA8E0C                  JP       Z,STRENT    ; Yes - Create string e
 1877 0C81 3A1281                  LD       A,(READFG)  ; "READ" or "INPUT" ?
 1878 0C84 B7                      OR       A
 1879 0C85 57                      LD       D,A         ; Save 00 if "INPUT"
 1880 0C86 CA8B0C                  JP       Z,ITMSEP    ; "INPUT" - End with 00
 1881 0C89 163A                    LD       D,':'       ; "DATA" - End with 00 
 1882 0C8B 062C         ITMSEP:    LD       B,','       ; Item separator
 1883 0C8D 2B                      DEC      HL          ; Back space for DTSTR
 1884 0C8E CDE711       STRENT:    CALL     DTSTR       ; Get string terminated
 1885 0C91 EB                      EX       DE,HL       ; String address to DE
 1886 0C92 21A50C                  LD       HL,LTSTND   ; Where to go after LET
 1887 0C95 E3                      EX       (SP),HL     ; Save HL , get input p
 1888 0C96 D5                      PUSH     DE          ; Save address of strin
 1889 0C97 C3A80A                  JP       LETSTR      ; Assign string to vari
 1890                   ;
 1891 0C9A CDDF08       INPBIN:    CALL     GETCHR      ; Get next character
 1892 0C9D CD3518                  CALL     ASCTFP      ; Convert ASCII to FP n
 1893 0CA0 E3                      EX       (SP),HL     ; Save input ptr, Get v
 1894 0CA1 CD8617                  CALL     FPTHL       ; Move FPREG to variabl
 1895 0CA4 E1                      POP      HL          ; Restore input pointer
 1896 0CA5 2B           LTSTND:    DEC      HL          ; DEC 'cos GETCHR INCs
 1897 0CA6 CDDF08                  CALL     GETCHR      ; Get next character
 1898 0CA9 CAB10C                  JP       Z,MORDT     ; End of line - More ne
 1899 0CAC FE2C                    CP       ','         ; Another value?
 1900 0CAE C2F70B                  JP       NZ,BADINP   ; No - Bad input
 1901 0CB1 E3           MORDT:     EX       (SP),HL     ; Get code string addre
 1902 0CB2 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 1903 0CB3 CDDF08                  CALL     GETCHR      ; Get next character
 1904 0CB6 C2440C                  JP       NZ,NEDMOR   ; More needed - Get it
 1905 0CB9 D1                      POP      DE          ; Restore DATA pointer
 1906 0CBA 3A1281                  LD       A,(READFG)  ; "READ" or "INPUT" ?
 1907 0CBD B7                      OR       A
 1908 0CBE EB                      EX       DE,HL       ; DATA pointer to HL
 1909 0CBF C20509                  JP       NZ,UPDATA   ; Update DATA pointer i
 1910 0CC2 D5                      PUSH     DE          ; Save code string addr
 1911 0CC3 B6                      OR       (HL)        ; More input given?
 1912 0CC4 21CC0C                  LD       HL,EXTIG    ; "?Extra ignored" mess
 1913 0CC7 C42512                  CALL     NZ,PRS      ; Output string if extr
 1914 0CCA E1                      POP      HL          ; Restore code string a
 1915 0CCB C9                      RET
 1916                   ;
 1917 0CCC 3F4578747261 EXTIG:     DB       "?Extra ignored",CR,LF,0
           2069676E6F72 
           65640D0A00   
 1918                   ;
 1919 0CDD CD760A       FDTLP:     CALL     DATA        ; Get next statement
 1920 0CE0 B7                      OR       A           ; End of line?
 1921 0CE1 C2F60C                  JP       NZ,FANDT    ; No - See if DATA stat
 1922 0CE4 23                      INC      HL
 1923 0CE5 7E                      LD       A,(HL)      ; End of program?
 1924 0CE6 23                      INC      HL
 1925 0CE7 B6                      OR       (HL)        ; 00 00 Ends program
 1926 0CE8 1E06                    LD       E,OD        ; ?OD Error
 1927 0CEA CA9B04                  JP       Z,ERROR     ; Yes - Out of DATA
 1928 0CED 23                      INC      HL
 1929 0CEE 5E                      LD       E,(HL)      ; LSB of line number
 1930 0CEF 23                      INC      HL
 1931 0CF0 56                      LD       D,(HL)      ; MSB of line number
 1932 0CF1 EB                      EX       DE,HL
 1933 0CF2 220E81                  LD       (DATLIN),HL ; Set line of current D
 1934 0CF5 EB                      EX       DE,HL
 1935 0CF6 CDDF08       FANDT:     CALL     GETCHR      ; Get next character
 1936 0CF9 FE83                    CP       ZDATA       ; "DATA" token
 1937 0CFB C2DD0C                  JP       NZ,FDTLP    ; No "DATA" - Keep look
 1938 0CFE C3700C                  JP       ANTVLU      ; Found - Convert input
 1939                   ;
 1940 0D01 110000       NEXT:      LD       DE,0        ; In case no index give
 1941 0D04 C4420F       NEXT1:     CALL     NZ,GETVAR   ; Get index address
 1942 0D07 221381                  LD       (BRKLIN),HL ; Save code string addr
 1943 0D0A CD3004                  CALL     BAKSTK      ; Look for "FOR" block
 1944 0D0D C28D04                  JP       NZ,NFERR    ; No "FOR" - ?NF Error
 1945 0D10 F9                      LD       SP,HL       ; Clear nested loops
 1946 0D11 D5                      PUSH     DE          ; Save index address
 1947 0D12 7E                      LD       A,(HL)      ; Get sign of STEP
 1948 0D13 23                      INC      HL
 1949 0D14 F5                      PUSH     AF          ; Save sign of STEP
 1950 0D15 D5                      PUSH     DE          ; Save index address
 1951 0D16 CD6C17                  CALL     PHLTFP      ; Move index value to F
 1952 0D19 E3                      EX       (SP),HL     ; Save address of TO va
 1953 0D1A E5                      PUSH     HL          ; Save address of index
 1954 0D1B CDD914                  CALL     ADDPHL      ; Add STEP to index val
 1955 0D1E E1                      POP      HL          ; Restore address of in
 1956 0D1F CD8617                  CALL     FPTHL       ; Move value to index v
 1957 0D22 E1                      POP      HL          ; Restore address of TO
 1958 0D23 CD7D17                  CALL     LOADFP      ; Move TO value to BCDE
 1959 0D26 E5                      PUSH     HL          ; Save address of line 
 1960 0D27 CDA917                  CALL     CMPNUM      ; Compare index with TO
 1961 0D2A E1                      POP      HL          ; Restore address of li
 1962 0D2B C1                      POP      BC          ; Address of sign of ST
 1963 0D2C 90                      SUB      B           ; Compare with expected
 1964 0D2D CD7D17                  CALL     LOADFP      ; BC = Loop stmt,DE = L
 1965 0D30 CA3C0D                  JP       Z,KILFOR    ; Loop finished - Termi
 1966 0D33 EB                      EX       DE,HL       ; Loop statement line n
 1967 0D34 22A180                  LD       (LINEAT),HL ; Set loop line number
 1968 0D37 69                      LD       L,C         ; Set code string to lo
 1969 0D38 60                      LD       H,B
 1970 0D39 C39B08                  JP       PUTFID      ; Put back "FOR" and co
 1971                   ;
 1972 0D3C F9           KILFOR:    LD       SP,HL       ; Remove "FOR" block
 1973 0D3D 2A1381                  LD       HL,(BRKLIN) ; Code string after "NE
 1974 0D40 7E                      LD       A,(HL)      ; Get next byte in code
 1975 0D41 FE2C                    CP       ','         ; More NEXTs ?
 1976 0D43 C29F08                  JP       NZ,RUNCNT   ; No - Do next statemen
 1977 0D46 CDDF08                  CALL     GETCHR      ; Position to index nam
 1978 0D49 CD040D                  CALL     NEXT1       ; Re-enter NEXT routine
 1979                   ; < will not RETurn to here , Exit to RUNCNT or Loop >
 1980                   ;
 1981 0D4C CD5E0D       GETNUM:    CALL     EVAL        ; Get a numeric express
 1982 0D4F F6           TSTNUM:    DB       0F6H        ; Clear carry (numeric)
 1983 0D50 37           TSTSTR:    SCF                  ; Set carry (string)
 1984 0D51 3AF280       CHKTYP:    LD       A,(TYPE)    ; Check types match
 1985 0D54 8F                      ADC      A,A         ; Expected + actual
 1986 0D55 B7                      OR       A           ; Clear carry , set par
 1987 0D56 E8                      RET      PE          ; Even parity - Types m
 1988 0D57 C39904                  JP       TMERR       ; Different types - Err
 1989                   ;
 1990 0D5A CD5507       OPNPAR:    CALL     CHKSYN      ; Make sure "(" follows
 1991 0D5D 28                      DB       "("
 1992 0D5E 2B           EVAL:      DEC      HL          ; Evaluate expression &
 1993 0D5F 1600                    LD       D,0         ; Precedence value
 1994 0D61 D5           EVAL1:     PUSH     DE          ; Save precedence
 1995 0D62 0E01                    LD       C,1
 1996 0D64 CD6404                  CALL     CHKSTK      ; Check for 1 level of 
 1997 0D67 CDD50D                  CALL     OPRND       ; Get next expression v
 1998 0D6A 221581       EVAL2:     LD       (NXTOPR),HL ; Save address of next 
 1999 0D6D 2A1581       EVAL3:     LD       HL,(NXTOPR) ; Restore address of ne
 2000 0D70 C1                      POP      BC          ; Precedence value and 
 2001 0D71 78                      LD       A,B         ; Get precedence value
 2002 0D72 FE78                    CP       78H         ; "AND" or "OR" ?
 2003 0D74 D44F0D                  CALL     NC,TSTNUM   ; No - Make sure it's a
 2004 0D77 7E                      LD       A,(HL)      ; Get next operator / f
 2005 0D78 1600                    LD       D,0         ; Clear Last relation
 2006 0D7A D6B3         RLTLP:     SUB      ZGTR        ; ">" Token
 2007 0D7C DA960D                  JP       C,FOPRND    ; + - * / ^ AND OR - Te
 2008 0D7F FE03                    CP       ZLTH+1-ZGTR ; < = >
 2009 0D81 D2960D                  JP       NC,FOPRND   ; Function - Call it
 2010 0D84 FE01                    CP       ZEQUAL-ZGTR ; "="
 2011 0D86 17                      RLA                  ; <- Test for legal
 2012 0D87 AA                      XOR      D           ; <- combinations of < 
 2013 0D88 BA                      CP       D           ; <- by combining last 
 2014 0D89 57                      LD       D,A         ; <- with current one
 2015 0D8A DA8704                  JP       C,SNERR     ; Error if "<<' '==" or
 2016 0D8D 220A81                  LD       (CUROPR),HL ; Save address of curre
 2017 0D90 CDDF08                  CALL     GETCHR      ; Get next character
 2018 0D93 C37A0D                  JP       RLTLP       ; Treat the two as one
 2019                   ;
 2020 0D96 7A           FOPRND:    LD       A,D         ; < = > found ?
 2021 0D97 B7                      OR       A
 2022 0D98 C2BD0E                  JP       NZ,TSTRED   ; Yes - Test for reduct
 2023 0D9B 7E                      LD       A,(HL)      ; Get operator token
 2024 0D9C 220A81                  LD       (CUROPR),HL ; Save operator address
 2025 0D9F D6AC                    SUB      ZPLUS       ; Operator or function?
 2026 0DA1 D8                      RET      C           ; Neither - Exit
 2027 0DA2 FE07                    CP       ZOR+1-ZPLUS ; Is it + - * / ^ AND O
 2028 0DA4 D0                      RET      NC          ; No - Exit
 2029 0DA5 5F                      LD       E,A         ; Coded operator
 2030 0DA6 3AF280                  LD       A,(TYPE)    ; Get data type
 2031 0DA9 3D                      DEC      A           ; FF = numeric , 00 = s
 2032 0DAA B3                      OR       E           ; Combine with coded op
 2033 0DAB 7B                      LD       A,E         ; Get coded operator
 2034 0DAC CA1B13                  JP       Z,CONCAT    ; String concatenation
 2035 0DAF 07                      RLCA                 ; Times 2
 2036 0DB0 83                      ADD      A,E         ; Times 3
 2037 0DB1 5F                      LD       E,A         ; To DE (D is 0)
 2038 0DB2 217903                  LD       HL,PRITAB   ; Precedence table
 2039 0DB5 19                      ADD      HL,DE       ; To the operator conce
 2040 0DB6 78                      LD       A,B         ; Last operator precede
 2041 0DB7 56                      LD       D,(HL)      ; Get evaluation preced
 2042 0DB8 BA                      CP       D           ; Compare with eval pre
 2043 0DB9 D0                      RET      NC          ; Exit if higher preced
 2044 0DBA 23                      INC      HL          ; Point to routine addr
 2045 0DBB CD4F0D                  CALL     TSTNUM      ; Make sure it's a numb
 2046                   ;
 2047 0DBE C5           STKTHS:    PUSH     BC          ; Save last precedence 
 2048 0DBF 016D0D                  LD       BC,EVAL3    ; Where to go on prec' 
 2049 0DC2 C5                      PUSH     BC          ; Save on stack for ret
 2050 0DC3 43                      LD       B,E         ; Save operator
 2051 0DC4 4A                      LD       C,D         ; Save precedence
 2052 0DC5 CD5F17                  CALL     STAKFP      ; Move value to stack
 2053 0DC8 58                      LD       E,B         ; Restore operator
 2054 0DC9 51                      LD       D,C         ; Restore precedence
 2055 0DCA 4E                      LD       C,(HL)      ; Get LSB of routine ad
 2056 0DCB 23                      INC      HL
 2057 0DCC 46                      LD       B,(HL)      ; Get MSB of routine ad
 2058 0DCD 23                      INC      HL
 2059 0DCE C5                      PUSH     BC          ; Save routine address
 2060 0DCF 2A0A81                  LD       HL,(CUROPR) ; Address of current op
 2061 0DD2 C3610D                  JP       EVAL1       ; Loop until prec' brea
 2062                   ;
 2063 0DD5 AF           OPRND:     XOR      A           ; Get operand routine
 2064 0DD6 32F280                  LD       (TYPE),A    ; Set numeric expected
 2065 0DD9 CDDF08                  CALL     GETCHR      ; Get next character
 2066 0DDC 1E24                    LD       E,MO        ; ?MO Error
 2067 0DDE CA9B04                  JP       Z,ERROR     ; No operand - Error
 2068 0DE1 DA3518                  JP       C,ASCTFP    ; Number - Get value
 2069 0DE4 CD7D09                  CALL     CHKLTR      ; See if a letter
 2070 0DE7 D23C0E                  JP       NC,CONVAR   ; Letter - Find variabl
 2071 0DEA FE26                    CP       '&'         ; &H = HEX, &B = BINARY
 2072 0DEC 2012                    JR       NZ, NOTAMP
 2073 0DEE CDDF08                  CALL     GETCHR      ; Get next character
 2074 0DF1 FE48                    CP       'H'         ; Hex number indicated?
 2075 0DF3 CA791C                  JP       Z,HEXTFP    ; Convert Hex to FPREG
 2076 0DF6 FE42                    CP       'B'         ; Binary number indicat
 2077 0DF8 CAE91C                  JP       Z,BINTFP    ; Convert Bin to FPREG
 2078 0DFB 1E02                    LD       E,SN        ; If neither then a ?SN
 2079 0DFD CA9B04                  JP       Z,ERROR
 2080 0E00 FEAC         NOTAMP:    CP       ZPLUS       ; '+' Token ?
 2081 0E02 CAD50D                  JP       Z,OPRND     ; Yes - Look for operan
 2082 0E05 FE2E                    CP       '.'         ; '.' ?
 2083 0E07 CA3518                  JP       Z,ASCTFP    ; Yes - Create FP numbe
 2084 0E0A FEAD                    CP       ZMINUS      ; '-' Token ?
 2085 0E0C CA2B0E                  JP       Z,MINUS     ; Yes - Do minus
 2086 0E0F FE22                    CP       '"'         ; Literal string ?
 2087 0E11 CAE411                  JP       Z,QTSTR     ; Get string terminated
 2088 0E14 FEAA                    CP       ZNOT        ; "NOT" Token ?
 2089 0E16 CA1D0F                  JP       Z,EVNOT     ; Yes - Eval NOT expres
 2090 0E19 FEA7                    CP       ZFN         ; "FN" Token ?
 2091 0E1B CA4811                  JP       Z,DOFN      ; Yes - Do FN routine
 2092 0E1E D6B6                    SUB      ZSGN        ; Is it a function?
 2093 0E20 D24D0E                  JP       NC,FNOFST   ; Yes - Evaluate functi
 2094 0E23 CD5A0D       EVLPAR:    CALL     OPNPAR      ; Evaluate expression i
 2095 0E26 CD5507                  CALL     CHKSYN      ; Make sure ")" follows
 2096 0E29 29                      DB       ")"
 2097 0E2A C9                      RET
 2098                   ;
 2099 0E2B 167D         MINUS:     LD       D,7DH       ; '-' precedence
 2100 0E2D CD610D                  CALL     EVAL1       ; Evaluate until prec' 
 2101 0E30 2A1581                  LD       HL,(NXTOPR) ; Get next operator add
 2102 0E33 E5                      PUSH     HL          ; Save next operator ad
 2103 0E34 CD5717                  CALL     INVSGN      ; Negate value
 2104 0E37 CD4F0D       RETNUM:    CALL     TSTNUM      ; Make sure it's a numb
 2105 0E3A E1                      POP      HL          ; Restore next operator
 2106 0E3B C9                      RET
 2107                   ;
 2108 0E3C CD420F       CONVAR:    CALL     GETVAR      ; Get variable address 
 2109 0E3F E5           FRMEVL:    PUSH     HL          ; Save code string addr
 2110 0E40 EB                      EX       DE,HL       ; Variable address to H
 2111 0E41 222981                  LD       (FPREG),HL  ; Save address of varia
 2112 0E44 3AF280                  LD       A,(TYPE)    ; Get type
 2113 0E47 B7                      OR       A           ; Numeric?
 2114 0E48 CC6C17                  CALL     Z,PHLTFP    ; Yes - Move contents t
 2115 0E4B E1                      POP      HL          ; Restore code string a
 2116 0E4C C9                      RET
 2117                   ;
 2118 0E4D 0600         FNOFST:    LD       B,0         ; Get address of functi
 2119 0E4F 07                      RLCA                 ; Double function offse
 2120 0E50 4F                      LD       C,A         ; BC = Offset in functi
 2121 0E51 C5                      PUSH     BC          ; Save adjusted token v
 2122 0E52 CDDF08                  CALL     GETCHR      ; Get next character
 2123 0E55 79                      LD       A,C         ; Get adjusted token va
 2124 0E56 FE31                    CP       2*(ZLEFT-ZSGN)-1 ; Adj' LEFT$,RIGHT
 2125 0E58 DA740E                  JP       C,FNVAL     ; No - Do function
 2126 0E5B CD5A0D                  CALL     OPNPAR      ; Evaluate expression  
 2127 0E5E CD5507                  CALL     CHKSYN      ; Make sure ',' follows
 2128 0E61 2C                      DB       ','
 2129 0E62 CD500D                  CALL     TSTSTR      ; Make sure it's a stri
 2130 0E65 EB                      EX       DE,HL       ; Save code string addr
 2131 0E66 2A2981                  LD       HL,(FPREG)  ; Get address of string
 2132 0E69 E3                      EX       (SP),HL     ; Save address of strin
 2133 0E6A E5                      PUSH     HL          ; Save adjusted token v
 2134 0E6B EB                      EX       DE,HL       ; Restore code string a
 2135 0E6C CDAD14                  CALL     GETINT      ; Get integer 0-255
 2136 0E6F EB                      EX       DE,HL       ; Save code string addr
 2137 0E70 E3                      EX       (SP),HL     ; Save integer,HL = adj
 2138 0E71 C37C0E                  JP       GOFUNC      ; Jump to string functi
 2139                   ;
 2140 0E74 CD230E       FNVAL:     CALL     EVLPAR      ; Evaluate expression
 2141 0E77 E3                      EX       (SP),HL     ; HL = Adjusted token v
 2142 0E78 11370E                  LD       DE,RETNUM   ; Return number from fu
 2143 0E7B D5                      PUSH     DE          ; Save on stack
 2144 0E7C 01D801       GOFUNC:    LD       BC,FNCTAB   ; Function routine addr
 2145 0E7F 09                      ADD      HL,BC       ; Point to right addres
 2146 0E80 4E                      LD       C,(HL)      ; Get LSB of address
 2147 0E81 23                      INC      HL          ;
 2148 0E82 66                      LD       H,(HL)      ; Get MSB of address
 2149 0E83 69                      LD       L,C         ; Address to HL
 2150 0E84 E9                      JP       (HL)        ; Jump to function
 2151                   ;
 2152 0E85 15           SGNEXP:    DEC      D           ; Dee to flag negative 
 2153 0E86 FEAD                    CP       ZMINUS      ; '-' token ?
 2154 0E88 C8                      RET      Z           ; Yes - Return
 2155 0E89 FE2D                    CP       '-'         ; '-' ASCII ?
 2156 0E8B C8                      RET      Z           ; Yes - Return
 2157 0E8C 14                      INC      D           ; Inc to flag positive 
 2158 0E8D FE2B                    CP       '+'         ; '+' ASCII ?
 2159 0E8F C8                      RET      Z           ; Yes - Return
 2160 0E90 FEAC                    CP       ZPLUS       ; '+' token ?
 2161 0E92 C8                      RET      Z           ; Yes - Return
 2162 0E93 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 2163 0E94 C9                      RET                  ; Return "NZ"
 2164                   ;
 2165 0E95 F6           POR:       DB       0F6H        ; Flag "OR"
 2166 0E96 AF           PAND:      XOR      A           ; Flag "AND"
 2167 0E97 F5                      PUSH     AF          ; Save "AND" / "OR" fla
 2168 0E98 CD4F0D                  CALL     TSTNUM      ; Make sure it's a numb
 2169 0E9B CD9109                  CALL     DEINT       ; Get integer -32768 to
 2170 0E9E F1                      POP      AF          ; Restore "AND" / "OR" 
 2171 0E9F EB                      EX       DE,HL       ; <- Get last
 2172 0EA0 C1                      POP      BC          ; <- value
 2173 0EA1 E3                      EX       (SP),HL     ; <- from
 2174 0EA2 EB                      EX       DE,HL       ; <- stack
 2175 0EA3 CD6F17                  CALL     FPBCDE      ; Move last value to FP
 2176 0EA6 F5                      PUSH     AF          ; Save "AND" / "OR" fla
 2177 0EA7 CD9109                  CALL     DEINT       ; Get integer -32768 to
 2178 0EAA F1                      POP      AF          ; Restore "AND" / "OR" 
 2179 0EAB C1                      POP      BC          ; Get value
 2180 0EAC 79                      LD       A,C         ; Get LSB
 2181 0EAD 210611                  LD       HL,ACPASS   ; Address of save AC as
 2182 0EB0 C2B80E                  JP       NZ,POR1     ; Jump if OR
 2183 0EB3 A3                      AND      E           ; "AND" LSBs
 2184 0EB4 4F                      LD       C,A         ; Save LSB
 2185 0EB5 78                      LD       A,B         ; Get MBS
 2186 0EB6 A2                      AND      D           ; "AND" MSBs
 2187 0EB7 E9                      JP       (HL)        ; Save AC as current (A
 2188                   ;
 2189 0EB8 B3           POR1:      OR       E           ; "OR" LSBs
 2190 0EB9 4F                      LD       C,A         ; Save LSB
 2191 0EBA 78                      LD       A,B         ; Get MSB
 2192 0EBB B2                      OR       D           ; "OR" MSBs
 2193 0EBC E9                      JP       (HL)        ; Save AC as current (A
 2194                   ;
 2195 0EBD 21CF0E       TSTRED:    LD       HL,CMPLOG   ; Logical compare routi
 2196 0EC0 3AF280                  LD       A,(TYPE)    ; Get data type
 2197 0EC3 1F                      RRA                  ; Carry set = string
 2198 0EC4 7A                      LD       A,D         ; Get last precedence v
 2199 0EC5 17                      RLA                  ; Times 2 plus carry
 2200 0EC6 5F                      LD       E,A         ; To E
 2201 0EC7 1664                    LD       D,64H       ; Relational precedence
 2202 0EC9 78                      LD       A,B         ; Get current precedenc
 2203 0ECA BA                      CP       D           ; Compare with last
 2204 0ECB D0                      RET      NC          ; Eval if last was rel'
 2205 0ECC C3BE0D                  JP       STKTHS      ; Stack this one and ge
 2206                   ;
 2207 0ECF D10E         CMPLOG:    DW       CMPLG1      ; Compare two values / 
 2208 0ED1 79           CMPLG1:    LD       A,C         ; Get data type
 2209 0ED2 B7                      OR       A
 2210 0ED3 1F                      RRA
 2211 0ED4 C1                      POP      BC          ; Get last expression t
 2212 0ED5 D1                      POP      DE
 2213 0ED6 F5                      PUSH     AF          ; Save status
 2214 0ED7 CD510D                  CALL     CHKTYP      ; Check that types matc
 2215 0EDA 21130F                  LD       HL,CMPRES   ; Result to comparison
 2216 0EDD E5                      PUSH     HL          ; Save for RETurn
 2217 0EDE CAA917                  JP       Z,CMPNUM    ; Compare values if num
 2218 0EE1 AF                      XOR      A           ; Compare two strings
 2219 0EE2 32F280                  LD       (TYPE),A    ; Set type to numeric
 2220 0EE5 D5                      PUSH     DE          ; Save string name
 2221 0EE6 CD6813                  CALL     GSTRCU      ; Get current string
 2222 0EE9 7E                      LD       A,(HL)      ; Get length of string
 2223 0EEA 23                      INC      HL
 2224 0EEB 23                      INC      HL
 2225 0EEC 4E                      LD       C,(HL)      ; Get LSB of address
 2226 0EED 23                      INC      HL
 2227 0EEE 46                      LD       B,(HL)      ; Get MSB of address
 2228 0EEF D1                      POP      DE          ; Restore string name
 2229 0EF0 C5                      PUSH     BC          ; Save address of strin
 2230 0EF1 F5                      PUSH     AF          ; Save length of string
 2231 0EF2 CD6C13                  CALL     GSTRDE      ; Get second string
 2232 0EF5 CD7D17                  CALL     LOADFP      ; Get address of second
 2233 0EF8 F1                      POP      AF          ; Restore length of str
 2234 0EF9 57                      LD       D,A         ; Length to D
 2235 0EFA E1                      POP      HL          ; Restore address of st
 2236 0EFB 7B           CMPSTR:    LD       A,E         ; Bytes of string 2 to 
 2237 0EFC B2                      OR       D           ; Bytes of string 1 to 
 2238 0EFD C8                      RET      Z           ; Exit if all bytes com
 2239 0EFE 7A                      LD       A,D         ; Get bytes of string 1
 2240 0EFF D601                    SUB      1
 2241 0F01 D8                      RET      C           ; Exit if end of string
 2242 0F02 AF                      XOR      A
 2243 0F03 BB                      CP       E           ; Bytes of string 2 to 
 2244 0F04 3C                      INC      A
 2245 0F05 D0                      RET      NC          ; Exit if end of string
 2246 0F06 15                      DEC      D           ; Count bytes in string
 2247 0F07 1D                      DEC      E           ; Count bytes in string
 2248 0F08 0A                      LD       A,(BC)      ; Byte in string 2
 2249 0F09 BE                      CP       (HL)        ; Compare to byte in st
 2250 0F0A 23                      INC      HL          ; Move up string 1
 2251 0F0B 03                      INC      BC          ; Move up string 2
 2252 0F0C CAFB0E                  JP       Z,CMPSTR    ; Same - Try next bytes
 2253 0F0F 3F                      CCF                  ; Flag difference (">" 
 2254 0F10 C33917                  JP       FLGDIF      ; "<" gives -1 , ">" gi
 2255                   ;
 2256 0F13 3C           CMPRES:    INC      A           ; Increment current val
 2257 0F14 8F                      ADC      A,A         ; Double plus carry
 2258 0F15 C1                      POP      BC          ; Get other value
 2259 0F16 A0                      AND      B           ; Combine them
 2260 0F17 C6FF                    ADD      A,-1        ; Carry set if differen
 2261 0F19 9F                      SBC      A,A         ; 00 - Equal , FF - Dif
 2262 0F1A C34017                  JP       FLGREL      ; Set current value & c
 2263                   ;
 2264 0F1D 165A         EVNOT:     LD       D,5AH       ; Precedence value for 
 2265 0F1F CD610D                  CALL     EVAL1       ; Eval until precedence
 2266 0F22 CD4F0D                  CALL     TSTNUM      ; Make sure it's a numb
 2267 0F25 CD9109                  CALL     DEINT       ; Get integer -32768 - 
 2268 0F28 7B                      LD       A,E         ; Get LSB
 2269 0F29 2F                      CPL                  ; Invert LSB
 2270 0F2A 4F                      LD       C,A         ; Save "NOT" of LSB
 2271 0F2B 7A                      LD       A,D         ; Get MSB
 2272 0F2C 2F                      CPL                  ; Invert MSB
 2273 0F2D CD0611                  CALL     ACPASS      ; Save AC as current
 2274 0F30 C1                      POP      BC          ; Clean up stack
 2275 0F31 C36D0D                  JP       EVAL3       ; Continue evaluation
 2276                   ;
 2277 0F34 2B           DIMRET:    DEC      HL          ; DEC 'cos GETCHR INCs
 2278 0F35 CDDF08                  CALL     GETCHR      ; Get next character
 2279 0F38 C8                      RET      Z           ; End of DIM statement
 2280 0F39 CD5507                  CALL     CHKSYN      ; Make sure ',' follows
 2281 0F3C 2C                      DB       ','
 2282 0F3D 01340F       DIM:       LD       BC,DIMRET   ; Return to "DIMRET"
 2283 0F40 C5                      PUSH     BC          ; Save on stack
 2284 0F41 F6                      DB       0F6H        ; Flag "Create" variabl
 2285 0F42 AF           GETVAR:    XOR      A           ; Find variable address
 2286 0F43 32F180                  LD       (LCRFLG),A  ; Set locate / create f
 2287 0F46 46                      LD       B,(HL)      ; Get First byte of nam
 2288 0F47 CD7D09       GTFNAM:    CALL     CHKLTR      ; See if a letter
 2289 0F4A DA8704                  JP       C,SNERR     ; ?SN Error if not a le
 2290 0F4D AF                      XOR      A
 2291 0F4E 4F                      LD       C,A         ; Clear second byte of 
 2292 0F4F 32F280                  LD       (TYPE),A    ; Set type to numeric
 2293 0F52 CDDF08                  CALL     GETCHR      ; Get next character
 2294 0F55 DA5E0F                  JP       C,SVNAM2    ; Numeric - Save in nam
 2295 0F58 CD7D09                  CALL     CHKLTR      ; See if a letter
 2296 0F5B DA6B0F                  JP       C,CHARTY    ; Not a letter - Check 
 2297 0F5E 4F           SVNAM2:    LD       C,A         ; Save second byte of n
 2298 0F5F CDDF08       ENDNAM:    CALL     GETCHR      ; Get next character
 2299 0F62 DA5F0F                  JP       C,ENDNAM    ; Numeric - Get another
 2300 0F65 CD7D09                  CALL     CHKLTR      ; See if a letter
 2301 0F68 D25F0F                  JP       NC,ENDNAM   ; Letter - Get another
 2302 0F6B D624         CHARTY:    SUB      '$'         ; String variable?
 2303 0F6D C27A0F                  JP       NZ,NOTSTR   ; No - Numeric variable
 2304 0F70 3C                      INC      A           ; A = 1 (string type)
 2305 0F71 32F280                  LD       (TYPE),A    ; Set type to string
 2306 0F74 0F                      RRCA                 ; A = 80H , Flag for st
 2307 0F75 81                      ADD      A,C         ; 2nd byte of name has 
 2308 0F76 4F                      LD       C,A         ; Resave second byte on
 2309 0F77 CDDF08                  CALL     GETCHR      ; Get next character
 2310 0F7A 3A1081       NOTSTR:    LD       A,(FORFLG)  ; Array name needed ?
 2311 0F7D 3D                      DEC      A
 2312 0F7E CA2710                  JP       Z,ARLDSV    ; Yes - Get array name
 2313 0F81 F28A0F                  JP       P,NSCFOR    ; No array with "FOR" o
 2314 0F84 7E                      LD       A,(HL)      ; Get byte again
 2315 0F85 D628                    SUB      '('         ; Subscripted variable?
 2316 0F87 CAFF0F                  JP       Z,SBSCPT    ; Yes - Sort out subscr
 2317                   ;
 2318 0F8A AF           NSCFOR:    XOR      A           ; Simple variable
 2319 0F8B 321081                  LD       (FORFLG),A  ; Clear "FOR" flag
 2320 0F8E E5                      PUSH     HL          ; Save code string addr
 2321 0F8F 50                      LD       D,B         ; DE = Variable name to
 2322 0F90 59                      LD       E,C
 2323 0F91 2A2381                  LD       HL,(FNRGNM) ; FN argument name
 2324 0F94 CD4F07                  CALL     CPDEHL      ; Is it the FN argument
 2325 0F97 112581                  LD       DE,FNARG    ; Point to argument val
 2326 0F9A CA6F16                  JP       Z,POPHRT    ; Yes - Return FN argum
 2327 0F9D 2A1D81                  LD       HL,(VAREND) ; End of variables
 2328 0FA0 EB                      EX       DE,HL       ; Address of end of sea
 2329 0FA1 2A1B81                  LD       HL,(PROGND) ; Start of variables ad
 2330 0FA4 CD4F07       FNDVAR:    CALL     CPDEHL      ; End of variable list 
 2331 0FA7 CABD0F                  JP       Z,CFEVAL    ; Yes - Called from EVA
 2332 0FAA 79                      LD       A,C         ; Get second byte of na
 2333 0FAB 96                      SUB      (HL)        ; Compare with name in 
 2334 0FAC 23                      INC      HL          ; Move on to first byte
 2335 0FAD C2B20F                  JP       NZ,FNTHR    ; Different - Find anot
 2336 0FB0 78                      LD       A,B         ; Get first byte of nam
 2337 0FB1 96                      SUB      (HL)        ; Compare with name in 
 2338 0FB2 23           FNTHR:     INC      HL          ; Move on to LSB of val
 2339 0FB3 CAF10F                  JP       Z,RETADR    ; Found - Return addres
 2340 0FB6 23                      INC      HL          ; <- Skip
 2341 0FB7 23                      INC      HL          ; <- over
 2342 0FB8 23                      INC      HL          ; <- F.P.
 2343 0FB9 23                      INC      HL          ; <- value
 2344 0FBA C3A40F                  JP       FNDVAR      ; Keep looking
 2345                   ;
 2346 0FBD E1           CFEVAL:    POP      HL          ; Restore code string a
 2347 0FBE E3                      EX       (SP),HL     ; Get return address
 2348 0FBF D5                      PUSH     DE          ; Save address of varia
 2349 0FC0 113F0E                  LD       DE,FRMEVL   ; Return address in EVA
 2350 0FC3 CD4F07                  CALL     CPDEHL      ; Called from EVAL ?
 2351 0FC6 D1                      POP      DE          ; Restore address of va
 2352 0FC7 CAF40F                  JP       Z,RETNUL    ; Yes - Return null var
 2353 0FCA E3                      EX       (SP),HL     ; Put back return
 2354 0FCB E5                      PUSH     HL          ; Save code string addr
 2355 0FCC C5                      PUSH     BC          ; Save variable name
 2356 0FCD 010600                  LD       BC,6        ; 2 byte name plus 4 by
 2357 0FD0 2A1F81                  LD       HL,(ARREND) ; End of arrays
 2358 0FD3 E5                      PUSH     HL          ; Save end of arrays
 2359 0FD4 09                      ADD      HL,BC       ; Move up 6 bytes
 2360 0FD5 C1                      POP      BC          ; Source address in BC
 2361 0FD6 E5                      PUSH     HL          ; Save new end address
 2362 0FD7 CD5304                  CALL     MOVUP       ; Move arrays up
 2363 0FDA E1                      POP      HL          ; Restore new end addre
 2364 0FDB 221F81                  LD       (ARREND),HL ; Set new end address
 2365 0FDE 60                      LD       H,B         ; End of variables to H
 2366 0FDF 69                      LD       L,C
 2367 0FE0 221D81                  LD       (VAREND),HL ; Set new end address
 2368                   ;
 2369 0FE3 2B           ZEROLP:    DEC      HL          ; Back through to zero 
 2370 0FE4 3600                    LD       (HL),0      ; Zero byte in variable
 2371 0FE6 CD4F07                  CALL     CPDEHL      ; Done them all?
 2372 0FE9 C2E30F                  JP       NZ,ZEROLP   ; No - Keep on going
 2373 0FEC D1                      POP      DE          ; Get variable name
 2374 0FED 73                      LD       (HL),E      ; Store second characte
 2375 0FEE 23                      INC      HL
 2376 0FEF 72                      LD       (HL),D      ; Store first character
 2377 0FF0 23                      INC      HL
 2378 0FF1 EB           RETADR:    EX       DE,HL       ; Address of variable i
 2379 0FF2 E1                      POP      HL          ; Restore code string a
 2380 0FF3 C9                      RET
 2381                   ;
 2382 0FF4 322C81       RETNUL:    LD       (FPEXP),A   ; Set result to zero
 2383 0FF7 212304                  LD       HL,ZERBYT   ; Also set a null strin
 2384 0FFA 222981                  LD       (FPREG),HL  ; Save for EVAL
 2385 0FFD E1                      POP      HL          ; Restore code string a
 2386 0FFE C9                      RET
 2387                   ;
 2388 0FFF E5           SBSCPT:    PUSH     HL          ; Save code string addr
 2389 1000 2AF180                  LD       HL,(LCRFLG) ; Locate/Create and Typ
 2390 1003 E3                      EX       (SP),HL     ; Save and get code str
 2391 1004 57                      LD       D,A         ; Zero number of dimens
 2392 1005 D5           SCPTLP:    PUSH     DE          ; Save number of dimens
 2393 1006 C5                      PUSH     BC          ; Save array name
 2394 1007 CD8509                  CALL     FPSINT      ; Get subscript (0-3276
 2395 100A C1                      POP      BC          ; Restore array name
 2396 100B F1                      POP      AF          ; Get number of dimensi
 2397 100C EB                      EX       DE,HL
 2398 100D E3                      EX       (SP),HL     ; Save subscript value
 2399 100E E5                      PUSH     HL          ; Save LCRFLG and TYPE
 2400 100F EB                      EX       DE,HL
 2401 1010 3C                      INC      A           ; Count dimensions
 2402 1011 57                      LD       D,A         ; Save in D
 2403 1012 7E                      LD       A,(HL)      ; Get next byte in code
 2404 1013 FE2C                    CP       ','         ; Comma (more to come)?
 2405 1015 CA0510                  JP       Z,SCPTLP    ; Yes - More subscripts
 2406 1018 CD5507                  CALL     CHKSYN      ; Make sure ")" follows
 2407 101B 29                      DB       ")"
 2408 101C 221581                  LD       (NXTOPR),HL ; Save code string addr
 2409 101F E1                      POP      HL          ; Get LCRFLG and TYPE
 2410 1020 22F180                  LD       (LCRFLG),HL ; Restore Locate/create
 2411 1023 1E00                    LD       E,0         ; Flag not CSAVE* or CL
 2412 1025 D5                      PUSH     DE          ; Save number of dimens
 2413 1026 11                      DB       11H         ; Skip "PUSH HL" and "P
 2414                   ;
 2415 1027 E5           ARLDSV:    PUSH     HL          ; Save code string addr
 2416 1028 F5                      PUSH     AF          ; A = 00 , Flags set = 
 2417 1029 2A1D81                  LD       HL,(VAREND) ; Start of arrays
 2418 102C 3E                      DB       3EH         ; Skip "ADD HL,DE"
 2419 102D 19           FNDARY:    ADD      HL,DE       ; Move to next array st
 2420 102E EB                      EX       DE,HL
 2421 102F 2A1F81                  LD       HL,(ARREND) ; End of arrays
 2422 1032 EB                      EX       DE,HL       ; Current array pointer
 2423 1033 CD4F07                  CALL     CPDEHL      ; End of arrays found?
 2424 1036 CA5F10                  JP       Z,CREARY    ; Yes - Create array
 2425 1039 7E                      LD       A,(HL)      ; Get second byte of na
 2426 103A B9                      CP       C           ; Compare with name giv
 2427 103B 23                      INC      HL          ; Move on
 2428 103C C24110                  JP       NZ,NXTARY   ; Different - Find next
 2429 103F 7E                      LD       A,(HL)      ; Get first byte of nam
 2430 1040 B8                      CP       B           ; Compare with name giv
 2431 1041 23           NXTARY:    INC      HL          ; Move on
 2432 1042 5E                      LD       E,(HL)      ; Get LSB of next array
 2433 1043 23                      INC      HL
 2434 1044 56                      LD       D,(HL)      ; Get MSB of next array
 2435 1045 23                      INC      HL
 2436 1046 C22D10                  JP       NZ,FNDARY   ; Not found - Keep look
 2437 1049 3AF180                  LD       A,(LCRFLG)  ; Found Locate or Creat
 2438 104C B7                      OR       A
 2439 104D C29004                  JP       NZ,DDERR    ; Create - ?DD Error
 2440 1050 F1                      POP      AF          ; Locate - Get number o
 2441 1051 44                      LD       B,H         ; BC Points to array di
 2442 1052 4D                      LD       C,L
 2443 1053 CA6F16                  JP       Z,POPHRT    ; Jump if array load/sa
 2444 1056 96                      SUB      (HL)        ; Same number of dimens
 2445 1057 CABD10                  JP       Z,FINDEL    ; Yes - Find element
 2446 105A 1E10         BSERR:     LD       E,BS        ; ?BS Error
 2447 105C C39B04                  JP       ERROR       ; Output error
 2448                   ;
 2449 105F 110400       CREARY:    LD       DE,4        ; 4 Bytes per entry
 2450 1062 F1                      POP      AF          ; Array to save or 0 di
 2451 1063 CAA609                  JP       Z,FCERR     ; Yes - ?FC Error
 2452 1066 71                      LD       (HL),C      ; Save second byte of n
 2453 1067 23                      INC      HL
 2454 1068 70                      LD       (HL),B      ; Save first byte of na
 2455 1069 23                      INC      HL
 2456 106A 4F                      LD       C,A         ; Number of dimensions 
 2457 106B CD6404                  CALL     CHKSTK      ; Check if enough memor
 2458 106E 23                      INC      HL          ; Point to number of di
 2459 106F 23                      INC      HL
 2460 1070 220A81                  LD       (CUROPR),HL ; Save address of point
 2461 1073 71                      LD       (HL),C      ; Set number of dimensi
 2462 1074 23                      INC      HL
 2463 1075 3AF180                  LD       A,(LCRFLG)  ; Locate of Create?
 2464 1078 17                      RLA                  ; Carry set = Create
 2465 1079 79                      LD       A,C         ; Get number of dimensi
 2466 107A 010B00       CRARLP:    LD       BC,10+1     ; Default dimension siz
 2467 107D D28210                  JP       NC,DEFSIZ   ; Locate - Set default 
 2468 1080 C1                      POP      BC          ; Get specified dimensi
 2469 1081 03                      INC      BC          ; Include zero element
 2470 1082 71           DEFSIZ:    LD       (HL),C      ; Save LSB of dimension
 2471 1083 23                      INC      HL
 2472 1084 70                      LD       (HL),B      ; Save MSB of dimension
 2473 1085 23                      INC      HL
 2474 1086 F5                      PUSH     AF          ; Save num' of dim'ns a
 2475 1087 E5                      PUSH     HL          ; Save address of dim'n
 2476 1088 CD1A18                  CALL     MLDEBC      ; Multiply DE by BC to 
 2477 108B EB                      EX       DE,HL       ; amount of mem needed 
 2478 108C E1                      POP      HL          ; Restore address of di
 2479 108D F1                      POP      AF          ; Restore number of dim
 2480 108E 3D                      DEC      A           ; Count them
 2481 108F C27A10                  JP       NZ,CRARLP   ; Do next dimension if 
 2482 1092 F5                      PUSH     AF          ; Save locate/create fl
 2483 1093 42                      LD       B,D         ; MSB of memory needed
 2484 1094 4B                      LD       C,E         ; LSB of memory needed
 2485 1095 EB                      EX       DE,HL
 2486 1096 19                      ADD      HL,DE       ; Add bytes to array st
 2487 1097 DA7C04                  JP       C,OMERR     ; Too big - Error
 2488 109A CD6D04                  CALL     ENFMEM      ; See if enough memory
 2489 109D 221F81                  LD       (ARREND),HL ; Save new end of array
 2490                   ;
 2491 10A0 2B           ZERARY:    DEC      HL          ; Back through array da
 2492 10A1 3600                    LD       (HL),0      ; Set array element to 
 2493 10A3 CD4F07                  CALL     CPDEHL      ; All elements zeroed?
 2494 10A6 C2A010                  JP       NZ,ZERARY   ; No - Keep on going
 2495 10A9 03                      INC      BC          ; Number of bytes + 1
 2496 10AA 57                      LD       D,A         ; A=0
 2497 10AB 2A0A81                  LD       HL,(CUROPR) ; Get address of array
 2498 10AE 5E                      LD       E,(HL)      ; Number of dimensions
 2499 10AF EB                      EX       DE,HL       ; To HL
 2500 10B0 29                      ADD      HL,HL       ; Two bytes per dimensi
 2501 10B1 09                      ADD      HL,BC       ; Add number of bytes
 2502 10B2 EB                      EX       DE,HL       ; Bytes needed to DE
 2503 10B3 2B                      DEC      HL
 2504 10B4 2B                      DEC      HL
 2505 10B5 73                      LD       (HL),E      ; Save LSB of bytes nee
 2506 10B6 23                      INC      HL
 2507 10B7 72                      LD       (HL),D      ; Save MSB of bytes nee
 2508 10B8 23                      INC      HL
 2509 10B9 F1                      POP      AF          ; Locate / Create?
 2510 10BA DAE110                  JP       C,ENDDIM    ; A is 0 , End if creat
 2511 10BD 47           FINDEL:    LD       B,A         ; Find array element
 2512 10BE 4F                      LD       C,A
 2513 10BF 7E                      LD       A,(HL)      ; Number of dimensions
 2514 10C0 23                      INC      HL
 2515 10C1 16                      DB       16H         ; Skip "POP HL"
 2516 10C2 E1           FNDELP:    POP      HL          ; Address of next dim' 
 2517 10C3 5E                      LD       E,(HL)      ; Get LSB of dim'n size
 2518 10C4 23                      INC      HL
 2519 10C5 56                      LD       D,(HL)      ; Get MSB of dim'n size
 2520 10C6 23                      INC      HL
 2521 10C7 E3                      EX       (SP),HL     ; Save address - Get in
 2522 10C8 F5                      PUSH     AF          ; Save number of dim'ns
 2523 10C9 CD4F07                  CALL     CPDEHL      ; Dimension too large?
 2524 10CC D25A10                  JP       NC,BSERR    ; Yes - ?BS Error
 2525 10CF E5                      PUSH     HL          ; Save index
 2526 10D0 CD1A18                  CALL     MLDEBC      ; Multiply previous by 
 2527 10D3 D1                      POP      DE          ; Index supplied to DE
 2528 10D4 19                      ADD      HL,DE       ; Add index to pointer
 2529 10D5 F1                      POP      AF          ; Number of dimensions
 2530 10D6 3D                      DEC      A           ; Count them
 2531 10D7 44                      LD       B,H         ; MSB of pointer
 2532 10D8 4D                      LD       C,L         ; LSB of pointer
 2533 10D9 C2C210                  JP       NZ,FNDELP   ; More - Keep going
 2534 10DC 29                      ADD      HL,HL       ; 4 Bytes per element
 2535 10DD 29                      ADD      HL,HL
 2536 10DE C1                      POP      BC          ; Start of array
 2537 10DF 09                      ADD      HL,BC       ; Point to element
 2538 10E0 EB                      EX       DE,HL       ; Address of element to
 2539 10E1 2A1581       ENDDIM:    LD       HL,(NXTOPR) ; Got code string addre
 2540 10E4 C9                      RET
 2541                   ;
 2542 10E5 2A1F81       FRE:       LD       HL,(ARREND) ; Start of free memory
 2543 10E8 EB                      EX       DE,HL       ; To DE
 2544 10E9 210000                  LD       HL,0        ; End of free memory
 2545 10EC 39                      ADD      HL,SP       ; Current stack value
 2546 10ED 3AF280                  LD       A,(TYPE)    ; Dummy argument type
 2547 10F0 B7                      OR       A
 2548 10F1 CA0111                  JP       Z,FRENUM    ; Numeric - Free variab
 2549 10F4 CD6813                  CALL     GSTRCU      ; Current string to poo
 2550 10F7 CD6812                  CALL     GARBGE      ; Garbage collection
 2551 10FA 2A9F80                  LD       HL,(STRSPC) ; Bottom of string spac
 2552 10FD EB                      EX       DE,HL       ; To DE
 2553 10FE 2A0881                  LD       HL,(STRBOT) ; Bottom of string spac
 2554 1101 7D           FRENUM:    LD       A,L         ; Get LSB of end
 2555 1102 93                      SUB      E           ; Subtract LSB of begin
 2556 1103 4F                      LD       C,A         ; Save difference if C
 2557 1104 7C                      LD       A,H         ; Get MSB of end
 2558 1105 9A                      SBC      A,D         ; Subtract MSB of begin
 2559 1106 41           ACPASS:    LD       B,C         ; Return integer AC
 2560 1107 50           ABPASS:    LD       D,B         ; Return integer AB
 2561 1108 1E00                    LD       E,0
 2562 110A 21F280                  LD       HL,TYPE     ; Point to type
 2563 110D 73                      LD       (HL),E      ; Set type to numeric
 2564 110E 0690                    LD       B,80H+16    ; 16 bit integer
 2565 1110 C34517                  JP       RETINT      ; Return the integr
 2566                   ;
 2567 1113 3AF080       POS:       LD       A,(CURPOS)  ; Get cursor position
 2568 1116 47           PASSA:     LD       B,A         ; Put A into AB
 2569 1117 AF                      XOR      A           ; Zero A
 2570 1118 C30711                  JP       ABPASS      ; Return integer AB
 2571                   ;
 2572 111B CD9E11       DEF:       CALL     CHEKFN      ; Get "FN" and name
 2573 111E CD9011                  CALL     IDTEST      ; Test for illegal dire
 2574 1121 01760A                  LD       BC,DATA     ; To get next statement
 2575 1124 C5                      PUSH     BC          ; Save address for RETu
 2576 1125 D5                      PUSH     DE          ; Save address of funct
 2577 1126 CD5507                  CALL     CHKSYN      ; Make sure "(" follows
 2578 1129 28                      DB       "("
 2579 112A CD420F                  CALL     GETVAR      ; Get argument variable
 2580 112D E5                      PUSH     HL          ; Save code string addr
 2581 112E EB                      EX       DE,HL       ; Argument address to H
 2582 112F 2B                      DEC      HL
 2583 1130 56                      LD       D,(HL)      ; Get first byte of arg
 2584 1131 2B                      DEC      HL
 2585 1132 5E                      LD       E,(HL)      ; Get second byte of ar
 2586 1133 E1                      POP      HL          ; Restore code string a
 2587 1134 CD4F0D                  CALL     TSTNUM      ; Make sure numeric arg
 2588 1137 CD5507                  CALL     CHKSYN      ; Make sure ")" follows
 2589 113A 29                      DB       ")"
 2590 113B CD5507                  CALL     CHKSYN      ; Make sure "=" follows
 2591 113E B4                      DB       ZEQUAL      ; "=" token
 2592 113F 44                      LD       B,H         ; Code string address t
 2593 1140 4D                      LD       C,L
 2594 1141 E3                      EX       (SP),HL     ; Save code str , Get F
 2595 1142 71                      LD       (HL),C      ; Save LSB of FN code s
 2596 1143 23                      INC      HL
 2597 1144 70                      LD       (HL),B      ; Save MSB of FN code s
 2598 1145 C3DD11                  JP       SVSTAD      ; Save address and do f
 2599                   ;
 2600 1148 CD9E11       DOFN:      CALL     CHEKFN      ; Make sure FN follows
 2601 114B D5                      PUSH     DE          ; Save function pointer
 2602 114C CD230E                  CALL     EVLPAR      ; Evaluate expression i
 2603 114F CD4F0D                  CALL     TSTNUM      ; Make sure numeric res
 2604 1152 E3                      EX       (SP),HL     ; Save code str , Get F
 2605 1153 5E                      LD       E,(HL)      ; Get LSB of FN code st
 2606 1154 23                      INC      HL
 2607 1155 56                      LD       D,(HL)      ; Get MSB of FN code st
 2608 1156 23                      INC      HL
 2609 1157 7A                      LD       A,D         ; And function DEFined?
 2610 1158 B3                      OR       E
 2611 1159 CA9304                  JP       Z,UFERR     ; No - ?UF Error
 2612 115C 7E                      LD       A,(HL)      ; Get LSB of argument a
 2613 115D 23                      INC      HL
 2614 115E 66                      LD       H,(HL)      ; Get MSB of argument a
 2615 115F 6F                      LD       L,A         ; HL = Arg variable add
 2616 1160 E5                      PUSH     HL          ; Save it
 2617 1161 2A2381                  LD       HL,(FNRGNM) ; Get old argument name
 2618 1164 E3                      EX       (SP),HL     ;        ; Save old , G
 2619 1165 222381                  LD       (FNRGNM),HL ; Set new argument name
 2620 1168 2A2781                  LD       HL,(FNARG+2) ; Get LSB,NLSB of old 
 2621 116B E5                      PUSH     HL          ; Save it
 2622 116C 2A2581                  LD       HL,(FNARG)  ; Get MSB,EXP of old ar
 2623 116F E5                      PUSH     HL          ; Save it
 2624 1170 212581                  LD       HL,FNARG    ; HL = Value of argumen
 2625 1173 D5                      PUSH     DE          ; Save FN code string a
 2626 1174 CD8617                  CALL     FPTHL       ; Move FPREG to argumen
 2627 1177 E1                      POP      HL          ; Get FN code string ad
 2628 1178 CD4C0D                  CALL     GETNUM      ; Get value from functi
 2629 117B 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 2630 117C CDDF08                  CALL     GETCHR      ; Get next character
 2631 117F C28704                  JP       NZ,SNERR    ; Bad character in FN -
 2632 1182 E1                      POP      HL          ; Get MSB,EXP of old ar
 2633 1183 222581                  LD       (FNARG),HL  ; Restore it
 2634 1186 E1                      POP      HL          ; Get LSB,NLSB of old a
 2635 1187 222781                  LD       (FNARG+2),HL ; Restore it
 2636 118A E1                      POP      HL          ; Get name of old arg
 2637 118B 222381                  LD       (FNRGNM),HL ; Restore it
 2638 118E E1                      POP      HL          ; Restore code string a
 2639 118F C9                      RET
 2640                   ;
 2641 1190 E5           IDTEST:    PUSH     HL          ; Save code string addr
 2642 1191 2AA180                  LD       HL,(LINEAT) ; Get current line numb
 2643 1194 23                      INC      HL          ; -1 means direct state
 2644 1195 7C                      LD       A,H
 2645 1196 B5                      OR       L
 2646 1197 E1                      POP      HL          ; Restore code string a
 2647 1198 C0                      RET      NZ          ; Return if in program
 2648 1199 1E16                    LD       E,ID        ; ?ID Error
 2649 119B C39B04                  JP       ERROR
 2650                   ;
 2651 119E CD5507       CHEKFN:    CALL     CHKSYN      ; Make sure FN follows
 2652 11A1 A7                      DB       ZFN         ; "FN" token
 2653 11A2 3E80                    LD       A,80H
 2654 11A4 321081                  LD       (FORFLG),A  ; Flag FN name to find
 2655 11A7 B6                      OR       (HL)        ; FN name has bit 7 set
 2656 11A8 47                      LD       B,A         ; in first byte of name
 2657 11A9 CD470F                  CALL     GTFNAM      ; Get FN name
 2658 11AC C34F0D                  JP       TSTNUM      ; Make sure numeric fun
 2659                   ;
 2660 11AF CD4F0D       STR:       CALL     TSTNUM      ; Make sure it's a numb
 2661 11B2 CDD318                  CALL     NUMASC      ; Turn number into text
 2662 11B5 CDE311       STR1:      CALL     CRTST       ; Create string entry f
 2663 11B8 CD6813                  CALL     GSTRCU      ; Current string to poo
 2664 11BB 01C313                  LD       BC,TOPOOL   ; Save in string pool
 2665 11BE C5                      PUSH     BC          ; Save address on stack
 2666                   ;
 2667 11BF 7E           SAVSTR:    LD       A,(HL)      ; Get string length
 2668 11C0 23                      INC      HL
 2669 11C1 23                      INC      HL
 2670 11C2 E5                      PUSH     HL          ; Save pointer to strin
 2671 11C3 CD3E12                  CALL     TESTR       ; See if enough string 
 2672 11C6 E1                      POP      HL          ; Restore pointer to st
 2673 11C7 4E                      LD       C,(HL)      ; Get LSB of address
 2674 11C8 23                      INC      HL
 2675 11C9 46                      LD       B,(HL)      ; Get MSB of address
 2676 11CA CDD711                  CALL     CRTMST      ; Create string entry
 2677 11CD E5                      PUSH     HL          ; Save pointer to MSB o
 2678 11CE 6F                      LD       L,A         ; Length of string
 2679 11CF CD5B13                  CALL     TOSTRA      ; Move to string area
 2680 11D2 D1                      POP      DE          ; Restore pointer to MS
 2681 11D3 C9                      RET
 2682                   ;
 2683 11D4 CD3E12       MKTMST:    CALL     TESTR       ; See if enough string 
 2684 11D7 210481       CRTMST:    LD       HL,TMPSTR   ; Temporary string
 2685 11DA E5                      PUSH     HL          ; Save it
 2686 11DB 77                      LD       (HL),A      ; Save length of string
 2687 11DC 23                      INC      HL
 2688 11DD 23           SVSTAD:    INC      HL
 2689 11DE 73                      LD       (HL),E      ; Save LSB of address
 2690 11DF 23                      INC      HL
 2691 11E0 72                      LD       (HL),D      ; Save MSB of address
 2692 11E1 E1                      POP      HL          ; Restore pointer
 2693 11E2 C9                      RET
 2694                   ;
 2695 11E3 2B           CRTST:     DEC      HL          ; DEC - INCed after
 2696 11E4 0622         QTSTR:     LD       B,'"'       ; Terminating quote
 2697 11E6 50                      LD       D,B         ; Quote to D
 2698 11E7 E5           DTSTR:     PUSH     HL          ; Save start
 2699 11E8 0EFF                    LD       C,-1        ; Set counter to -1
 2700 11EA 23           QTSTLP:    INC      HL          ; Move on
 2701 11EB 7E                      LD       A,(HL)      ; Get byte
 2702 11EC 0C                      INC      C           ; Count bytes
 2703 11ED B7                      OR       A           ; End of line?
 2704 11EE CAF911                  JP       Z,CRTSTE    ; Yes - Create string e
 2705 11F1 BA                      CP       D           ; Terminator D found?
 2706 11F2 CAF911                  JP       Z,CRTSTE    ; Yes - Create string e
 2707 11F5 B8                      CP       B           ; Terminator B found?
 2708 11F6 C2EA11                  JP       NZ,QTSTLP   ; No - Keep looking
 2709 11F9 FE22         CRTSTE:    CP       '"'         ; End with '"'?
 2710 11FB CCDF08                  CALL     Z,GETCHR    ; Yes - Get next charac
 2711 11FE E3                      EX       (SP),HL     ; Starting quote
 2712 11FF 23                      INC      HL          ; First byte of string
 2713 1200 EB                      EX       DE,HL       ; To DE
 2714 1201 79                      LD       A,C         ; Get length
 2715 1202 CDD711                  CALL     CRTMST      ; Create string entry
 2716 1205 110481       TSTOPL:    LD       DE,TMPSTR   ; Temporary string
 2717 1208 2AF680                  LD       HL,(TMSTPT) ; Temporary string pool
 2718 120B 222981                  LD       (FPREG),HL  ; Save address of strin
 2719 120E 3E01                    LD       A,1
 2720 1210 32F280                  LD       (TYPE),A    ; Set type to string
 2721 1213 CD8917                  CALL     DETHL4      ; Move string to pool
 2722 1216 CD4F07                  CALL     CPDEHL      ; Out of string pool?
 2723 1219 22F680                  LD       (TMSTPT),HL ; Save new pointer
 2724 121C E1                      POP      HL          ; Restore code string a
 2725 121D 7E                      LD       A,(HL)      ; Get next code byte
 2726 121E C0                      RET      NZ          ; Return if pool OK
 2727 121F 1E1E                    LD       E,ST        ; ?ST Error
 2728 1221 C39B04                  JP       ERROR       ; String pool overflow
 2729                   ;
 2730 1224 23           PRNUMS:    INC      HL          ; Skip leading space
 2731 1225 CDE311       PRS:       CALL     CRTST       ; Create string entry f
 2732 1228 CD6813       PRS1:      CALL     GSTRCU      ; Current string to poo
 2733 122B CD7D17                  CALL     LOADFP      ; Move string block to 
 2734 122E 1C                      INC      E           ; Length + 1
 2735 122F 1D           PRSLP:     DEC      E           ; Count characters
 2736 1230 C8                      RET      Z           ; End of string
 2737 1231 0A                      LD       A,(BC)      ; Get byte to output
 2738 1232 CD6007                  CALL     OUTC        ; Output character in A
 2739 1235 FE0D                    CP       CR          ; Return?
 2740 1237 CC910B                  CALL     Z,DONULL    ; Yes - Do nulls
 2741 123A 03                      INC      BC          ; Next byte in string
 2742 123B C32F12                  JP       PRSLP       ; More characters to ou
 2743                   ;
 2744 123E B7           TESTR:     OR       A           ; Test if enough room
 2745 123F 0E                      DB       0EH         ; No garbage collection
 2746 1240 F1           GRBDON:    POP      AF          ; Garbage collection do
 2747 1241 F5                      PUSH     AF          ; Save status
 2748 1242 2A9F80                  LD       HL,(STRSPC) ; Bottom of string spac
 2749 1245 EB                      EX       DE,HL       ; To DE
 2750 1246 2A0881                  LD       HL,(STRBOT) ; Bottom of string area
 2751 1249 2F                      CPL                  ; Negate length (Top do
 2752 124A 4F                      LD       C,A         ; -Length to BC
 2753 124B 06FF                    LD       B,-1        ; BC = -ve length of st
 2754 124D 09                      ADD      HL,BC       ; Add to bottom of spac
 2755 124E 23                      INC      HL          ; Plus one for 2's comp
 2756 124F CD4F07                  CALL     CPDEHL      ; Below string RAM area
 2757 1252 DA5C12                  JP       C,TESTOS    ; Tidy up if not done e
 2758 1255 220881                  LD       (STRBOT),HL ; Save new bottom of ar
 2759 1258 23                      INC      HL          ; Point to first byte o
 2760 1259 EB                      EX       DE,HL       ; Address to DE
 2761 125A F1           POPAF:     POP      AF          ; Throw away status pus
 2762 125B C9                      RET
 2763                   ;
 2764 125C F1           TESTOS:    POP      AF          ; Garbage collect been 
 2765 125D 1E1A                    LD       E,OS        ; ?OS Error
 2766 125F CA9B04                  JP       Z,ERROR     ; Yes - Not enough stri
 2767 1262 BF                      CP       A           ; Flag garbage collect 
 2768 1263 F5                      PUSH     AF          ; Save status
 2769 1264 014012                  LD       BC,GRBDON   ; Garbage collection do
 2770 1267 C5                      PUSH     BC          ; Save for RETurn
 2771 1268 2AF480       GARBGE:    LD       HL,(LSTRAM) ; Get end of RAM pointe
 2772 126B 220881       GARBLP:    LD       (STRBOT),HL ; Reset string pointer
 2773 126E 210000                  LD       HL,0
 2774 1271 E5                      PUSH     HL          ; Flag no string found
 2775 1272 2A9F80                  LD       HL,(STRSPC) ; Get bottom of string 
 2776 1275 E5                      PUSH     HL          ; Save bottom of string
 2777 1276 21F880                  LD       HL,TMSTPL   ; Temporary string pool
 2778 1279 EB           GRBLP:     EX       DE,HL
 2779 127A 2AF680                  LD       HL,(TMSTPT) ; Temporary string pool
 2780 127D EB                      EX       DE,HL
 2781 127E CD4F07                  CALL     CPDEHL      ; Temporary string pool
 2782 1281 017912                  LD       BC,GRBLP    ; Loop until string poo
 2783 1284 C2CD12                  JP       NZ,STPOOL   ; No - See if in string
 2784 1287 2A1B81                  LD       HL,(PROGND) ; Start of simple varia
 2785 128A EB           SMPVAR:    EX       DE,HL
 2786 128B 2A1D81                  LD       HL,(VAREND) ; End of simple variabl
 2787 128E EB                      EX       DE,HL
 2788 128F CD4F07                  CALL     CPDEHL      ; All simple strings do
 2789 1292 CAA012                  JP       Z,ARRLP     ; Yes - Do string array
 2790 1295 7E                      LD       A,(HL)      ; Get type of variable
 2791 1296 23                      INC      HL
 2792 1297 23                      INC      HL
 2793 1298 B7                      OR       A           ; "S" flag set if strin
 2794 1299 CDD012                  CALL     STRADD      ; See if string in stri
 2795 129C C38A12                  JP       SMPVAR      ; Loop until simple one
 2796                   ;
 2797 129F C1           GNXARY:    POP      BC          ; Scrap address of this
 2798 12A0 EB           ARRLP:     EX       DE,HL
 2799 12A1 2A1F81                  LD       HL,(ARREND) ; End of string arrays
 2800 12A4 EB                      EX       DE,HL
 2801 12A5 CD4F07                  CALL     CPDEHL      ; All string arrays don
 2802 12A8 CAF612                  JP       Z,SCNEND    ; Yes - Move string if 
 2803 12AB CD7D17                  CALL     LOADFP      ; Get array name to BCD
 2804 12AE 7B                      LD       A,E         ; Get type of array
 2805 12AF E5                      PUSH     HL          ; Save address of num o
 2806 12B0 09                      ADD      HL,BC       ; Start of next array
 2807 12B1 B7                      OR       A           ; Test type of array
 2808 12B2 F29F12                  JP       P,GNXARY    ; Numeric array - Ignor
 2809 12B5 220A81                  LD       (CUROPR),HL ; Save address of next 
 2810 12B8 E1                      POP      HL          ; Get address of num of
 2811 12B9 4E                      LD       C,(HL)      ; BC = Number of dimens
 2812 12BA 0600                    LD       B,0
 2813 12BC 09                      ADD      HL,BC       ; Two bytes per dimensi
 2814 12BD 09                      ADD      HL,BC
 2815 12BE 23                      INC      HL          ; Plus one for number o
 2816 12BF EB           GRBARY:    EX       DE,HL
 2817 12C0 2A0A81                  LD       HL,(CUROPR) ; Get address of next a
 2818 12C3 EB                      EX       DE,HL
 2819 12C4 CD4F07                  CALL     CPDEHL      ; Is this array finishe
 2820 12C7 CAA012                  JP       Z,ARRLP     ; Yes - Get next one
 2821 12CA 01BF12                  LD       BC,GRBARY   ; Loop until array all 
 2822 12CD C5           STPOOL:    PUSH     BC          ; Save return address
 2823 12CE F680                    OR       80H         ; Flag string type
 2824 12D0 7E           STRADD:    LD       A,(HL)      ; Get string length
 2825 12D1 23                      INC      HL
 2826 12D2 23                      INC      HL
 2827 12D3 5E                      LD       E,(HL)      ; Get LSB of string add
 2828 12D4 23                      INC      HL
 2829 12D5 56                      LD       D,(HL)      ; Get MSB of string add
 2830 12D6 23                      INC      HL
 2831 12D7 F0                      RET      P           ; Not a string - Return
 2832 12D8 B7                      OR       A           ; Set flags on string l
 2833 12D9 C8                      RET      Z           ; Null string - Return
 2834 12DA 44                      LD       B,H         ; Save variable pointer
 2835 12DB 4D                      LD       C,L
 2836 12DC 2A0881                  LD       HL,(STRBOT) ; Bottom of new area
 2837 12DF CD4F07                  CALL     CPDEHL      ; String been done?
 2838 12E2 60                      LD       H,B         ; Restore variable poin
 2839 12E3 69                      LD       L,C
 2840 12E4 D8                      RET      C           ; String done - Ignore
 2841 12E5 E1                      POP      HL          ; Return address
 2842 12E6 E3                      EX       (SP),HL     ; Lowest available stri
 2843 12E7 CD4F07                  CALL     CPDEHL      ; String within string 
 2844 12EA E3                      EX       (SP),HL     ; Lowest available stri
 2845 12EB E5                      PUSH     HL          ; Re-save return addres
 2846 12EC 60                      LD       H,B         ; Restore variable poin
 2847 12ED 69                      LD       L,C
 2848 12EE D0                      RET      NC          ; Outside string area -
 2849 12EF C1                      POP      BC          ; Get return , Throw 2 
 2850 12F0 F1                      POP      AF          ;
 2851 12F1 F1                      POP      AF          ;
 2852 12F2 E5                      PUSH     HL          ; Save variable pointer
 2853 12F3 D5                      PUSH     DE          ; Save address of curre
 2854 12F4 C5                      PUSH     BC          ; Put back return addre
 2855 12F5 C9                      RET                  ; Go to it
 2856                   ;
 2857 12F6 D1           SCNEND:    POP      DE          ; Addresses of strings
 2858 12F7 E1                      POP      HL          ;
 2859 12F8 7D                      LD       A,L         ; HL = 0 if no more to 
 2860 12F9 B4                      OR       H
 2861 12FA C8                      RET      Z           ; No more to do - Retur
 2862 12FB 2B                      DEC      HL
 2863 12FC 46                      LD       B,(HL)      ; MSB of address of str
 2864 12FD 2B                      DEC      HL
 2865 12FE 4E                      LD       C,(HL)      ; LSB of address of str
 2866 12FF E5                      PUSH     HL          ; Save variable address
 2867 1300 2B                      DEC      HL
 2868 1301 2B                      DEC      HL
 2869 1302 6E                      LD       L,(HL)      ; HL = Length of string
 2870 1303 2600                    LD       H,0
 2871 1305 09                      ADD      HL,BC       ; Address of end of str
 2872 1306 50                      LD       D,B         ; String address to DE
 2873 1307 59                      LD       E,C
 2874 1308 2B                      DEC      HL          ; Last byte in string
 2875 1309 44                      LD       B,H         ; Address to BC
 2876 130A 4D                      LD       C,L
 2877 130B 2A0881                  LD       HL,(STRBOT) ; Current bottom of str
 2878 130E CD5604                  CALL     MOVSTR      ; Move string to new ad
 2879 1311 E1                      POP      HL          ; Restore variable addr
 2880 1312 71                      LD       (HL),C      ; Save new LSB of addre
 2881 1313 23                      INC      HL
 2882 1314 70                      LD       (HL),B      ; Save new MSB of addre
 2883 1315 69                      LD       L,C         ; Next string area+1 to
 2884 1316 60                      LD       H,B
 2885 1317 2B                      DEC      HL          ; Next string area addr
 2886 1318 C36B12                  JP       GARBLP      ; Look for more strings
 2887                   ;
 2888 131B C5           CONCAT:    PUSH     BC          ; Save prec' opr & code
 2889 131C E5                      PUSH     HL          ;
 2890 131D 2A2981                  LD       HL,(FPREG)  ; Get first string
 2891 1320 E3                      EX       (SP),HL     ; Save first string
 2892 1321 CDD50D                  CALL     OPRND       ; Get second string
 2893 1324 E3                      EX       (SP),HL     ; Restore first string
 2894 1325 CD500D                  CALL     TSTSTR      ; Make sure it's a stri
 2895 1328 7E                      LD       A,(HL)      ; Get length of second 
 2896 1329 E5                      PUSH     HL          ; Save first string
 2897 132A 2A2981                  LD       HL,(FPREG)  ; Get second string
 2898 132D E5                      PUSH     HL          ; Save second string
 2899 132E 86                      ADD      A,(HL)      ; Add length of second 
 2900 132F 1E1C                    LD       E,LS        ; ?LS Error
 2901 1331 DA9B04                  JP       C,ERROR     ; String too long - Err
 2902 1334 CDD411                  CALL     MKTMST      ; Make temporary string
 2903 1337 D1                      POP      DE          ; Get second string to 
 2904 1338 CD6C13                  CALL     GSTRDE      ; Move to string pool i
 2905 133B E3                      EX       (SP),HL     ; Get first string
 2906 133C CD6B13                  CALL     GSTRHL      ; Move to string pool i
 2907 133F E5                      PUSH     HL          ; Save first string
 2908 1340 2A0681                  LD       HL,(TMPSTR+2) ; Temporary string ad
 2909 1343 EB                      EX       DE,HL       ; To DE
 2910 1344 CD5213                  CALL     SSTSA       ; First string to strin
 2911 1347 CD5213                  CALL     SSTSA       ; Second string to stri
 2912 134A 216A0D                  LD       HL,EVAL2    ; Return to evaluation 
 2913 134D E3                      EX       (SP),HL     ; Save return,get code 
 2914 134E E5                      PUSH     HL          ; Save code string addr
 2915 134F C30512                  JP       TSTOPL      ; To temporary string t
 2916                   ;
 2917 1352 E1           SSTSA:     POP      HL          ; Return address
 2918 1353 E3                      EX       (SP),HL     ; Get string block,save
 2919 1354 7E                      LD       A,(HL)      ; Get length of string
 2920 1355 23                      INC      HL
 2921 1356 23                      INC      HL
 2922 1357 4E                      LD       C,(HL)      ; Get LSB of string add
 2923 1358 23                      INC      HL
 2924 1359 46                      LD       B,(HL)      ; Get MSB of string add
 2925 135A 6F                      LD       L,A         ; Length to L
 2926 135B 2C           TOSTRA:    INC      L           ; INC - DECed after
 2927 135C 2D           TSALP:     DEC      L           ; Count bytes moved
 2928 135D C8                      RET      Z           ; End of string - Retur
 2929 135E 0A                      LD       A,(BC)      ; Get source
 2930 135F 12                      LD       (DE),A      ; Save destination
 2931 1360 03                      INC      BC          ; Next source
 2932 1361 13                      INC      DE          ; Next destination
 2933 1362 C35C13                  JP       TSALP       ; Loop until string mov
 2934                   ;
 2935 1365 CD500D       GETSTR:    CALL     TSTSTR      ; Make sure it's a stri
 2936 1368 2A2981       GSTRCU:    LD       HL,(FPREG)  ; Get current string
 2937 136B EB           GSTRHL:    EX       DE,HL       ; Save DE
 2938 136C CD8613       GSTRDE:    CALL     BAKTMP      ; Was it last tmp-str?
 2939 136F EB                      EX       DE,HL       ; Restore DE
 2940 1370 C0                      RET      NZ          ; No - Return
 2941 1371 D5                      PUSH     DE          ; Save string
 2942 1372 50                      LD       D,B         ; String block address 
 2943 1373 59                      LD       E,C
 2944 1374 1B                      DEC      DE          ; Point to length
 2945 1375 4E                      LD       C,(HL)      ; Get string length
 2946 1376 2A0881                  LD       HL,(STRBOT) ; Current bottom of str
 2947 1379 CD4F07                  CALL     CPDEHL      ; Last one in string ar
 2948 137C C28413                  JP       NZ,POPHL    ; No - Return
 2949 137F 47                      LD       B,A         ; Clear B (A=0)
 2950 1380 09                      ADD      HL,BC       ; Remove string from st
 2951 1381 220881                  LD       (STRBOT),HL ; Save new bottom of st
 2952 1384 E1           POPHL:     POP      HL          ; Restore string
 2953 1385 C9                      RET
 2954                   ;
 2955 1386 2AF680       BAKTMP:    LD       HL,(TMSTPT) ; Get temporary string 
 2956 1389 2B                      DEC      HL          ; Back
 2957 138A 46                      LD       B,(HL)      ; Get MSB of address
 2958 138B 2B                      DEC      HL          ; Back
 2959 138C 4E                      LD       C,(HL)      ; Get LSB of address
 2960 138D 2B                      DEC      HL          ; Back
 2961 138E 2B                      DEC      HL          ; Back
 2962 138F CD4F07                  CALL     CPDEHL      ; String last in string
 2963 1392 C0                      RET      NZ          ; Yes - Leave it
 2964 1393 22F680                  LD       (TMSTPT),HL ; Save new string pool 
 2965 1396 C9                      RET
 2966                   ;
 2967 1397 011611       LEN:       LD       BC,PASSA    ; To return integer A
 2968 139A C5                      PUSH     BC          ; Save address
 2969 139B CD6513       GETLEN:    CALL     GETSTR      ; Get string and its le
 2970 139E AF                      XOR      A
 2971 139F 57                      LD       D,A         ; Clear D
 2972 13A0 32F280                  LD       (TYPE),A    ; Set type to numeric
 2973 13A3 7E                      LD       A,(HL)      ; Get length of string
 2974 13A4 B7                      OR       A           ; Set status flags
 2975 13A5 C9                      RET
 2976                   ;
 2977 13A6 011611       ASC:       LD       BC,PASSA    ; To return integer A
 2978 13A9 C5                      PUSH     BC          ; Save address
 2979 13AA CD9B13       GTFLNM:    CALL     GETLEN      ; Get length of string
 2980 13AD CAA609                  JP       Z,FCERR     ; Null string - Error
 2981 13B0 23                      INC      HL
 2982 13B1 23                      INC      HL
 2983 13B2 5E                      LD       E,(HL)      ; Get LSB of address
 2984 13B3 23                      INC      HL
 2985 13B4 56                      LD       D,(HL)      ; Get MSB of address
 2986 13B5 1A                      LD       A,(DE)      ; Get first byte of str
 2987 13B6 C9                      RET
 2988                   ;
 2989 13B7 3E01         CHR:       LD       A,1         ; One character string
 2990 13B9 CDD411                  CALL     MKTMST      ; Make a temporary stri
 2991 13BC CDB014                  CALL     MAKINT      ; Make it integer A
 2992 13BF 2A0681                  LD       HL,(TMPSTR+2) ; Get address of stri
 2993 13C2 73                      LD       (HL),E      ; Save character
 2994 13C3 C1           TOPOOL:    POP      BC          ; Clean up stack
 2995 13C4 C30512                  JP       TSTOPL      ; Temporary string to p
 2996                   ;
 2997 13C7 CD6014       LEFT:      CALL     LFRGNM      ; Get number and ending
 2998 13CA AF                      XOR      A           ; Start at first byte i
 2999 13CB E3           RIGHT1:    EX       (SP),HL     ; Save code string,Get 
 3000 13CC 4F                      LD       C,A         ; Starting position in 
 3001 13CD E5           MID1:      PUSH     HL          ; Save string block add
 3002 13CE 7E                      LD       A,(HL)      ; Get length of string
 3003 13CF B8                      CP       B           ; Compare with number g
 3004 13D0 DAD513                  JP       C,ALLFOL    ; All following bytes r
 3005 13D3 78                      LD       A,B         ; Get new length
 3006 13D4 11                      DB       11H         ; Skip "LD C,0"
 3007 13D5 0E00         ALLFOL:    LD       C,0         ; First byte of string
 3008 13D7 C5                      PUSH     BC          ; Save position in stri
 3009 13D8 CD3E12                  CALL     TESTR       ; See if enough string 
 3010 13DB C1                      POP      BC          ; Get position in strin
 3011 13DC E1                      POP      HL          ; Restore string block 
 3012 13DD E5                      PUSH     HL          ; And re-save it
 3013 13DE 23                      INC      HL
 3014 13DF 23                      INC      HL
 3015 13E0 46                      LD       B,(HL)      ; Get LSB of address
 3016 13E1 23                      INC      HL
 3017 13E2 66                      LD       H,(HL)      ; Get MSB of address
 3018 13E3 68                      LD       L,B         ; HL = address of strin
 3019 13E4 0600                    LD       B,0         ; BC = starting address
 3020 13E6 09                      ADD      HL,BC       ; Point to that byte
 3021 13E7 44                      LD       B,H         ; BC = source string
 3022 13E8 4D                      LD       C,L
 3023 13E9 CDD711                  CALL     CRTMST      ; Create a string entry
 3024 13EC 6F                      LD       L,A         ; Length of new string
 3025 13ED CD5B13                  CALL     TOSTRA      ; Move string to string
 3026 13F0 D1                      POP      DE          ; Clear stack
 3027 13F1 CD6C13                  CALL     GSTRDE      ; Move to string pool i
 3028 13F4 C30512                  JP       TSTOPL      ; Temporary string to p
 3029                   ;
 3030 13F7 CD6014       RIGHT:     CALL     LFRGNM      ; Get number and ending
 3031 13FA D1                      POP      DE          ; Get string length
 3032 13FB D5                      PUSH     DE          ; And re-save
 3033 13FC 1A                      LD       A,(DE)      ; Get length
 3034 13FD 90                      SUB      B           ; Move back N bytes
 3035 13FE C3CB13                  JP       RIGHT1      ; Go and get sub-string
 3036                   ;
 3037 1401 EB           MID:       EX       DE,HL       ; Get code string addre
 3038 1402 7E                      LD       A,(HL)      ; Get next byte ',' or 
 3039 1403 CD6514                  CALL     MIDNUM      ; Get number supplied
 3040 1406 04                      INC      B           ; Is it character zero?
 3041 1407 05                      DEC      B
 3042 1408 CAA609                  JP       Z,FCERR     ; Yes - Error
 3043 140B C5                      PUSH     BC          ; Save starting positio
 3044 140C 1EFF                    LD       E,255       ; All of string
 3045 140E FE29                    CP       ')'         ; Any length given?
 3046 1410 CA1A14                  JP       Z,RSTSTR    ; No - Rest of string
 3047 1413 CD5507                  CALL     CHKSYN      ; Make sure ',' follows
 3048 1416 2C                      DB       ','
 3049 1417 CDAD14                  CALL     GETINT      ; Get integer 0-255
 3050 141A CD5507       RSTSTR:    CALL     CHKSYN      ; Make sure ")" follows
 3051 141D 29                      DB       ")"
 3052 141E F1                      POP      AF          ; Restore starting posi
 3053 141F E3                      EX       (SP),HL     ; Get string,8ave code 
 3054 1420 01CD13                  LD       BC,MID1     ; Continuation of MID$ 
 3055 1423 C5                      PUSH     BC          ; Save for return
 3056 1424 3D                      DEC      A           ; Starting position-1
 3057 1425 BE                      CP       (HL)        ; Compare with length
 3058 1426 0600                    LD       B,0         ; Zero bytes length
 3059 1428 D0                      RET      NC          ; Null string if start 
 3060 1429 4F                      LD       C,A         ; Save starting positio
 3061 142A 7E                      LD       A,(HL)      ; Get length of string
 3062 142B 91                      SUB      C           ; Subtract start
 3063 142C BB                      CP       E           ; Enough string for it?
 3064 142D 47                      LD       B,A         ; Save maximum length a
 3065 142E D8                      RET      C           ; Truncate string if ne
 3066 142F 43                      LD       B,E         ; Set specified length
 3067 1430 C9                      RET                  ; Go and create string
 3068                   ;
 3069 1431 CD9B13       VAL:       CALL     GETLEN      ; Get length of string
 3070 1434 CA4E15                  JP       Z,RESZER    ; Result zero
 3071 1437 5F                      LD       E,A         ; Save length
 3072 1438 23                      INC      HL
 3073 1439 23                      INC      HL
 3074 143A 7E                      LD       A,(HL)      ; Get LSB of address
 3075 143B 23                      INC      HL
 3076 143C 66                      LD       H,(HL)      ; Get MSB of address
 3077 143D 6F                      LD       L,A         ; HL = String address
 3078 143E E5                      PUSH     HL          ; Save string address
 3079 143F 19                      ADD      HL,DE
 3080 1440 46                      LD       B,(HL)      ; Get end of string+1 b
 3081 1441 72                      LD       (HL),D      ; Zero it to terminate
 3082 1442 E3                      EX       (SP),HL     ; Save string end,get s
 3083 1443 C5                      PUSH     BC          ; Save end+1 byte
 3084 1444 7E                      LD       A,(HL)      ; Get starting byte
 3085 1445 FE24                    CP       '$'         ; Hex number indicated?
 3086 1447 C24F14                  JP       NZ,VAL1
 3087 144A CD791C                  CALL     HEXTFP      ; Convert Hex to FPREG
 3088 144D 180D                    JR       VAL3
 3089 144F FE25         VAL1:      CP       '%'         ; Binary number indicat
 3090 1451 C25914                  JP       NZ,VAL2
 3091 1454 CDE91C                  CALL     BINTFP      ; Convert Bin to FPREG
 3092 1457 1803                    JR       VAL3
 3093 1459 CD3518       VAL2:      CALL     ASCTFP      ; Convert ASCII string 
 3094 145C C1           VAL3:      POP      BC          ; Restore end+1 byte
 3095 145D E1                      POP      HL          ; Restore end+1 address
 3096 145E 70                      LD       (HL),B      ; Put back original byt
 3097 145F C9                      RET
 3098                   ;
 3099 1460 EB           LFRGNM:    EX       DE,HL       ; Code string address t
 3100 1461 CD5507                  CALL     CHKSYN      ; Make sure ")" follows
 3101 1464 29                      DB       ")"
 3102 1465 C1           MIDNUM:    POP      BC          ; Get return address
 3103 1466 D1                      POP      DE          ; Get number supplied
 3104 1467 C5                      PUSH     BC          ; Re-save return addres
 3105 1468 43                      LD       B,E         ; Number to B
 3106 1469 C9                      RET
 3107                   ;
 3108 146A CDB014       INP:       CALL     MAKINT      ; Make it integer A
 3109 146D 328480                  LD       (INPORT),A  ; Set input port
 3110 1470 CD8380                  CALL     INPSUB      ; Get input from port
 3111 1473 C31611                  JP       PASSA       ; Return integer A
 3112                   ;
 3113 1476 CD9A14       POUT:      CALL     SETIO       ; Set up port number
 3114 1479 C34B80                  JP       OUTSUB      ; Output data and retur
 3115                   ;
 3116 147C CD9A14       WAIT:      CALL     SETIO       ; Set up port number
 3117 147F F5                      PUSH     AF          ; Save AND mask
 3118 1480 1E00                    LD       E,0         ; Assume zero if none g
 3119 1482 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 3120 1483 CDDF08                  CALL     GETCHR      ; Get next character
 3121 1486 CA9014                  JP       Z,NOXOR     ; No XOR byte given
 3122 1489 CD5507                  CALL     CHKSYN      ; Make sure ',' follows
 3123 148C 2C                      DB       ','
 3124 148D CDAD14                  CALL     GETINT      ; Get integer 0-255 to 
 3125 1490 C1           NOXOR:     POP      BC          ; Restore AND mask
 3126 1491 CD8380       WAITLP:    CALL     INPSUB      ; Get input
 3127 1494 AB                      XOR      E           ; Flip selected bits
 3128 1495 A0                      AND      B           ; Result non-zero?
 3129 1496 CA9114                  JP       Z,WAITLP    ; No = keep waiting
 3130 1499 C9                      RET
 3131                   ;
 3132 149A CDAD14       SETIO:     CALL     GETINT      ; Get integer 0-255
 3133 149D 328480                  LD       (INPORT),A  ; Set input port
 3134 14A0 324C80                  LD       (OTPORT),A  ; Set output port
 3135 14A3 CD5507                  CALL     CHKSYN      ; Make sure ',' follows
 3136 14A6 2C                      DB       ','
 3137 14A7 C3AD14                  JP       GETINT      ; Get integer 0-255 and
 3138                   ;
 3139 14AA CDDF08       FNDNUM:    CALL     GETCHR      ; Get next character
 3140 14AD CD4C0D       GETINT:    CALL     GETNUM      ; Get a number from 0 t
 3141 14B0 CD8B09       MAKINT:    CALL     DEPINT      ; Make sure value 0 - 2
 3142 14B3 7A                      LD       A,D         ; Get MSB of number
 3143 14B4 B7                      OR       A           ; Zero?
 3144 14B5 C2A609                  JP       NZ,FCERR    ; No - Error
 3145 14B8 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 3146 14B9 CDDF08                  CALL     GETCHR      ; Get next character
 3147 14BC 7B                      LD       A,E         ; Get number to A
 3148 14BD C9                      RET
 3149                   ;
 3150 14BE CD9109       PEEK:      CALL     DEINT       ; Get memory address
 3151 14C1 1A                      LD       A,(DE)      ; Get byte in memory
 3152 14C2 C31611                  JP       PASSA       ; Return integer A
 3153                   ;
 3154 14C5 CD4C0D       POKE:      CALL     GETNUM      ; Get memory address
 3155 14C8 CD9109                  CALL     DEINT       ; Get integer -32768 to
 3156 14CB D5                      PUSH     DE          ; Save memory address
 3157 14CC CD5507                  CALL     CHKSYN      ; Make sure ',' follows
 3158 14CF 2C                      DB       ','
 3159 14D0 CDAD14                  CALL     GETINT      ; Get integer 0-255
 3160 14D3 D1                      POP      DE          ; Restore memory addres
 3161 14D4 12                      LD       (DE),A      ; Load it into memory
 3162 14D5 C9                      RET
 3163                   ;
 3164 14D6 21AC19       ROUND:     LD       HL,HALF     ; Add 0.5 to FPREG
 3165 14D9 CD7D17       ADDPHL:    CALL     LOADFP      ; Load FP at (HL) to BC
 3166 14DC C3E814                  JP       FPADD       ; Add BCDE to FPREG
 3167                   ;
 3168 14DF CD7D17       SUBPHL:    CALL     LOADFP      ; FPREG = -FPREG + numb
 3169 14E2 21                      DB       21H         ; Skip "POP BC" and "PO
 3170 14E3 C1           PSUB:      POP      BC          ; Get FP number from st
 3171 14E4 D1                      POP      DE
 3172 14E5 CD5717       SUBCDE:    CALL     INVSGN      ; Negate FPREG
 3173 14E8 78           FPADD:     LD       A,B         ; Get FP exponent
 3174 14E9 B7                      OR       A           ; Is number zero?
 3175 14EA C8                      RET      Z           ; Yes - Nothing to add
 3176 14EB 3A2C81                  LD       A,(FPEXP)   ; Get FPREG exponent
 3177 14EE B7                      OR       A           ; Is this number zero?
 3178 14EF CA6F17                  JP       Z,FPBCDE    ; Yes - Move BCDE to FP
 3179 14F2 90                      SUB      B           ; BCDE number larger?
 3180 14F3 D20215                  JP       NC,NOSWAP   ; No - Don't swap them
 3181 14F6 2F                      CPL                  ; Two's complement
 3182 14F7 3C                      INC      A           ;       FP exponent
 3183 14F8 EB                      EX       DE,HL
 3184 14F9 CD5F17                  CALL     STAKFP      ; Put FPREG on stack
 3185 14FC EB                      EX       DE,HL
 3186 14FD CD6F17                  CALL     FPBCDE      ; Move BCDE to FPREG
 3187 1500 C1                      POP      BC          ; Restore number from s
 3188 1501 D1                      POP      DE
 3189 1502 FE19         NOSWAP:    CP       24+1        ; Second number insigni
 3190 1504 D0                      RET      NC          ; Yes - First number is
 3191 1505 F5                      PUSH     AF          ; Save number of bits t
 3192 1506 CD9417                  CALL     SIGNS       ; Set MSBs & sign of re
 3193 1509 67                      LD       H,A         ; Save sign of result
 3194 150A F1                      POP      AF          ; Restore scaling facto
 3195 150B CDAD15                  CALL     SCALE       ; Scale BCDE to same ex
 3196 150E B4                      OR       H           ; Result to be positive
 3197 150F 212981                  LD       HL,FPREG    ; Point to FPREG
 3198 1512 F22815                  JP       P,MINCDE    ; No - Subtract FPREG f
 3199 1515 CD8D15                  CALL     PLUCDE      ; Add FPREG to CDE
 3200 1518 D26E15                  JP       NC,RONDUP   ; No overflow - Round i
 3201 151B 23                      INC      HL          ; Point to exponent
 3202 151C 34                      INC      (HL)        ; Increment it
 3203 151D CA9604                  JP       Z,OVERR     ; Number overflowed - E
 3204 1520 2E01                    LD       L,1         ; 1 bit to shift right
 3205 1522 CDC315                  CALL     SHRT1       ; Shift result right
 3206 1525 C36E15                  JP       RONDUP      ; Round it up
 3207                   ;
 3208 1528 AF           MINCDE:    XOR      A           ; Clear A and carry
 3209 1529 90                      SUB      B           ; Negate exponent
 3210 152A 47                      LD       B,A         ; Re-save exponent
 3211 152B 7E                      LD       A,(HL)      ; Get LSB of FPREG
 3212 152C 9B                      SBC      A, E        ; Subtract LSB of BCDE
 3213 152D 5F                      LD       E,A         ; Save LSB of BCDE
 3214 152E 23                      INC      HL
 3215 152F 7E                      LD       A,(HL)      ; Get NMSB of FPREG
 3216 1530 9A                      SBC      A,D         ; Subtract NMSB of BCDE
 3217 1531 57                      LD       D,A         ; Save NMSB of BCDE
 3218 1532 23                      INC      HL
 3219 1533 7E                      LD       A,(HL)      ; Get MSB of FPREG
 3220 1534 99                      SBC      A,C         ; Subtract MSB of BCDE
 3221 1535 4F                      LD       C,A         ; Save MSB of BCDE
 3222 1536 DC9915       CONPOS:    CALL     C,COMPL     ; Overflow - Make it po
 3223                   ;
 3224 1539 68           BNORM:     LD       L,B         ; L = Exponent
 3225 153A 63                      LD       H,E         ; H = LSB
 3226 153B AF                      XOR      A
 3227 153C 47           BNRMLP:    LD       B,A         ; Save bit count
 3228 153D 79                      LD       A,C         ; Get MSB
 3229 153E B7                      OR       A           ; Is it zero?
 3230 153F C25B15                  JP       NZ,PNORM    ; No - Do it bit at a t
 3231 1542 4A                      LD       C,D         ; MSB = NMSB
 3232 1543 54                      LD       D,H         ; NMSB= LSB
 3233 1544 65                      LD       H,L         ; LSB = VLSB
 3234 1545 6F                      LD       L,A         ; VLSB= 0
 3235 1546 78                      LD       A,B         ; Get exponent
 3236 1547 D608                    SUB      8           ; Count 8 bits
 3237 1549 FEE0                    CP       0E0H        ; -24-8 Was number zero
 3238 154B C23C15                  JP       NZ,BNRMLP   ; No - Keep normalising
 3239 154E AF           RESZER:    XOR      A           ; Result is zero
 3240 154F 322C81       SAVEXP:    LD       (FPEXP),A   ; Save result as zero
 3241 1552 C9                      RET
 3242                   ;
 3243 1553 05           NORMAL:    DEC      B           ; Count bits
 3244 1554 29                      ADD      HL,HL       ; Shift HL left
 3245 1555 7A                      LD       A,D         ; Get NMSB
 3246 1556 17                      RLA                  ; Shift left with last 
 3247 1557 57                      LD       D,A         ; Save NMSB
 3248 1558 79                      LD       A,C         ; Get MSB
 3249 1559 8F                      ADC      A,A         ; Shift left with last 
 3250 155A 4F                      LD       C,A         ; Save MSB
 3251 155B F25315       PNORM:     JP       P,NORMAL    ; Not done - Keep going
 3252 155E 78                      LD       A,B         ; Number of bits shifte
 3253 155F 5C                      LD       E,H         ; Save HL in EB
 3254 1560 45                      LD       B,L
 3255 1561 B7                      OR       A           ; Any shifting done?
 3256 1562 CA6E15                  JP       Z,RONDUP    ; No - Round it up
 3257 1565 212C81                  LD       HL,FPEXP    ; Point to exponent
 3258 1568 86                      ADD      A,(HL)      ; Add shifted bits
 3259 1569 77                      LD       (HL),A      ; Re-save exponent
 3260 156A D24E15                  JP       NC,RESZER   ; Underflow - Result is
 3261 156D C8                      RET      Z           ; Result is zero
 3262 156E 78           RONDUP:    LD       A,B         ; Get VLSB of number
 3263 156F 212C81       RONDB:     LD       HL,FPEXP    ; Point to exponent
 3264 1572 B7                      OR       A           ; Any rounding?
 3265 1573 FC8015                  CALL     M,FPROND    ; Yes - Round number up
 3266 1576 46                      LD       B,(HL)      ; B = Exponent
 3267 1577 23                      INC      HL
 3268 1578 7E                      LD       A,(HL)      ; Get sign of result
 3269 1579 E680                    AND      10000000B   ; Only bit 7 needed
 3270 157B A9                      XOR      C           ; Set correct sign
 3271 157C 4F                      LD       C,A         ; Save correct sign in 
 3272 157D C36F17                  JP       FPBCDE      ; Move BCDE to FPREG
 3273                   ;
 3274 1580 1C           FPROND:    INC      E           ; Round LSB
 3275 1581 C0                      RET      NZ          ; Return if ok
 3276 1582 14                      INC      D           ; Round NMSB
 3277 1583 C0                      RET      NZ          ; Return if ok
 3278 1584 0C                      INC      C           ; Round MSB
 3279 1585 C0                      RET      NZ          ; Return if ok
 3280 1586 0E80                    LD       C,80H       ; Set normal value
 3281 1588 34                      INC      (HL)        ; Increment exponent
 3282 1589 C0                      RET      NZ          ; Return if ok
 3283 158A C39604                  JP       OVERR       ; Overflow error
 3284                   ;
 3285 158D 7E           PLUCDE:    LD       A,(HL)      ; Get LSB of FPREG
 3286 158E 83                      ADD      A,E         ; Add LSB of BCDE
 3287 158F 5F                      LD       E,A         ; Save LSB of BCDE
 3288 1590 23                      INC      HL
 3289 1591 7E                      LD       A,(HL)      ; Get NMSB of FPREG
 3290 1592 8A                      ADC      A,D         ; Add NMSB of BCDE
 3291 1593 57                      LD       D,A         ; Save NMSB of BCDE
 3292 1594 23                      INC      HL
 3293 1595 7E                      LD       A,(HL)      ; Get MSB of FPREG
 3294 1596 89                      ADC      A,C         ; Add MSB of BCDE
 3295 1597 4F                      LD       C,A         ; Save MSB of BCDE
 3296 1598 C9                      RET
 3297                   ;
 3298 1599 212D81       COMPL:     LD       HL,SGNRES   ; Sign of result
 3299 159C 7E                      LD       A,(HL)      ; Get sign of result
 3300 159D 2F                      CPL                  ; Negate it
 3301 159E 77                      LD       (HL),A      ; Put it back
 3302 159F AF                      XOR      A
 3303 15A0 6F                      LD       L,A         ; Set L to zero
 3304 15A1 90                      SUB      B           ; Negate exponent,set c
 3305 15A2 47                      LD       B,A         ; Re-save exponent
 3306 15A3 7D                      LD       A,L         ; Load zero
 3307 15A4 9B                      SBC      A,E         ; Negate LSB
 3308 15A5 5F                      LD       E,A         ; Re-save LSB
 3309 15A6 7D                      LD       A,L         ; Load zero
 3310 15A7 9A                      SBC      A,D         ; Negate NMSB
 3311 15A8 57                      LD       D,A         ; Re-save NMSB
 3312 15A9 7D                      LD       A,L         ; Load zero
 3313 15AA 99                      SBC      A,C         ; Negate MSB
 3314 15AB 4F                      LD       C,A         ; Re-save MSB
 3315 15AC C9                      RET
 3316                   ;
 3317 15AD 0600         SCALE:     LD       B,0         ; Clear underflow
 3318 15AF D608         SCALLP:    SUB      8           ; 8 bits (a whole byte)
 3319 15B1 DABC15                  JP       C,SHRITE    ; No - Shift right A bi
 3320 15B4 43                      LD       B,E         ; <- Shift
 3321 15B5 5A                      LD       E,D         ; <- right
 3322 15B6 51                      LD       D,C         ; <- eight
 3323 15B7 0E00                    LD       C,0         ; <- bits
 3324 15B9 C3AF15                  JP       SCALLP      ; More bits to shift
 3325                   ;
 3326 15BC C609         SHRITE:    ADD      A,8+1       ; Adjust count
 3327 15BE 6F                      LD       L,A         ; Save bits to shift
 3328 15BF AF           SHRLP:     XOR      A           ; Flag for all done
 3329 15C0 2D                      DEC      L           ; All shifting done?
 3330 15C1 C8                      RET      Z           ; Yes - Return
 3331 15C2 79                      LD       A,C         ; Get MSB
 3332 15C3 1F           SHRT1:     RRA                  ; Shift it right
 3333 15C4 4F                      LD       C,A         ; Re-save
 3334 15C5 7A                      LD       A,D         ; Get NMSB
 3335 15C6 1F                      RRA                  ; Shift right with last
 3336 15C7 57                      LD       D,A         ; Re-save it
 3337 15C8 7B                      LD       A,E         ; Get LSB
 3338 15C9 1F                      RRA                  ; Shift right with last
 3339 15CA 5F                      LD       E,A         ; Re-save it
 3340 15CB 78                      LD       A,B         ; Get underflow
 3341 15CC 1F                      RRA                  ; Shift right with last
 3342 15CD 47                      LD       B,A         ; Re-save underflow
 3343 15CE C3BF15                  JP       SHRLP       ; More bits to do
 3344                   ;
 3345 15D1 00000081     UNITY:     DB       000H,000H,000H,081H ; 1.00000
 3346                   ;
 3347 15D5 03           LOGTAB:    DB       3           ; Table used by LOG
 3348 15D6 AA561980                DB       0AAH,056H,019H,080H ; 0.59898
 3349 15DA F1227680                DB       0F1H,022H,076H,080H ; 0.96147
 3350 15DE 45AA3882                DB       045H,0AAH,038H,082H ; 2.88539
 3351                   ;
 3352 15E2 CD2E17       LOG:       CALL     TSTSGN      ; Test sign of value
 3353 15E5 B7                      OR       A
 3354 15E6 EAA609                  JP       PE,FCERR    ; ?FC Error if <= zero
 3355 15E9 212C81                  LD       HL,FPEXP    ; Point to exponent
 3356 15EC 7E                      LD       A,(HL)      ; Get exponent
 3357 15ED 013580                  LD       BC,8035H    ; BCDE = SQR(1/2)
 3358 15F0 11F304                  LD       DE,04F3H
 3359 15F3 90                      SUB      B           ; Scale value to be < 1
 3360 15F4 F5                      PUSH     AF          ; Save scale factor
 3361 15F5 70                      LD       (HL),B      ; Save new exponent
 3362 15F6 D5                      PUSH     DE          ; Save SQR(1/2)
 3363 15F7 C5                      PUSH     BC
 3364 15F8 CDE814                  CALL     FPADD       ; Add SQR(1/2) to value
 3365 15FB C1                      POP      BC          ; Restore SQR(1/2)
 3366 15FC D1                      POP      DE
 3367 15FD 04                      INC      B           ; Make it SQR(2)
 3368 15FE CD8416                  CALL     DVBCDE      ; Divide by SQR(2)
 3369 1601 21D115                  LD       HL,UNITY    ; Point to 1.
 3370 1604 CDDF14                  CALL     SUBPHL      ; Subtract FPREG from 1
 3371 1607 21D515                  LD       HL,LOGTAB   ; Coefficient table
 3372 160A CD761A                  CALL     SUMSER      ; Evaluate sum of serie
 3373 160D 018080                  LD       BC,8080H    ; BCDE = -0.5
 3374 1610 110000                  LD       DE,0000H
 3375 1613 CDE814                  CALL     FPADD       ; Subtract 0.5 from FPR
 3376 1616 F1                      POP      AF          ; Restore scale factor
 3377 1617 CDA918                  CALL     RSCALE      ; Re-scale number
 3378 161A 013180       MULLN2:    LD       BC,8031H    ; BCDE = Ln(2)
 3379 161D 111872                  LD       DE,7218H
 3380 1620 21                      DB       21H         ; Skip "POP BC" and "PO
 3381                   ;
 3382 1621 C1           MULT:      POP      BC          ; Get number from stack
 3383 1622 D1                      POP      DE
 3384 1623 CD2E17       FPMULT:    CALL     TSTSGN      ; Test sign of FPREG
 3385 1626 C8                      RET      Z           ; Return zero if zero
 3386 1627 2E00                    LD       L,0         ; Flag add exponents
 3387 1629 CDEC16                  CALL     ADDEXP      ; Add exponents
 3388 162C 79                      LD       A,C         ; Get MSB of multiplier
 3389 162D 323B81                  LD       (MULVAL),A  ; Save MSB of multiplie
 3390 1630 EB                      EX       DE,HL
 3391 1631 223C81                  LD       (MULVAL+1),HL ; Save rest of multip
 3392 1634 010000                  LD       BC,0        ; Partial product (BCDE
 3393 1637 50                      LD       D,B
 3394 1638 58                      LD       E,B
 3395 1639 213915                  LD       HL,BNORM    ; Address of normalise
 3396 163C E5                      PUSH     HL          ; Save for return
 3397 163D 214516                  LD       HL,MULT8    ; Address of 8 bit mult
 3398 1640 E5                      PUSH     HL          ; Save for NMSB,MSB
 3399 1641 E5                      PUSH     HL          ;
 3400 1642 212981                  LD       HL,FPREG    ; Point to number
 3401 1645 7E           MULT8:     LD       A,(HL)      ; Get LSB of number
 3402 1646 23                      INC      HL          ; Point to NMSB
 3403 1647 B7                      OR       A           ; Test LSB
 3404 1648 CA7116                  JP       Z,BYTSFT    ; Zero - shift to next 
 3405 164B E5                      PUSH     HL          ; Save address of numbe
 3406 164C 2E08                    LD       L,8         ; 8 bits to multiply by
 3407 164E 1F           MUL8LP:    RRA                  ; Shift LSB right
 3408 164F 67                      LD       H,A         ; Save LSB
 3409 1650 79                      LD       A,C         ; Get MSB
 3410 1651 D25F16                  JP       NC,NOMADD   ; Bit was zero - Don't 
 3411 1654 E5                      PUSH     HL          ; Save LSB and count
 3412 1655 2A3C81                  LD       HL,(MULVAL+1) ; Get LSB and NMSB
 3413 1658 19                      ADD      HL,DE       ; Add NMSB and LSB
 3414 1659 EB                      EX       DE,HL       ; Leave sum in DE
 3415 165A E1                      POP      HL          ; Restore MSB and count
 3416 165B 3A3B81                  LD       A,(MULVAL)  ; Get MSB of multiplier
 3417 165E 89                      ADC      A,C         ; Add MSB
 3418 165F 1F           NOMADD:    RRA                  ; Shift MSB right
 3419 1660 4F                      LD       C,A         ; Re-save MSB
 3420 1661 7A                      LD       A,D         ; Get NMSB
 3421 1662 1F                      RRA                  ; Shift NMSB right
 3422 1663 57                      LD       D,A         ; Re-save NMSB
 3423 1664 7B                      LD       A,E         ; Get LSB
 3424 1665 1F                      RRA                  ; Shift LSB right
 3425 1666 5F                      LD       E,A         ; Re-save LSB
 3426 1667 78                      LD       A,B         ; Get VLSB
 3427 1668 1F                      RRA                  ; Shift VLSB right
 3428 1669 47                      LD       B,A         ; Re-save VLSB
 3429 166A 2D                      DEC      L           ; Count bits multiplied
 3430 166B 7C                      LD       A,H         ; Get LSB of multiplier
 3431 166C C24E16                  JP       NZ,MUL8LP   ; More - Do it
 3432 166F E1           POPHRT:    POP      HL          ; Restore address of nu
 3433 1670 C9                      RET
 3434                   ;
 3435 1671 43           BYTSFT:    LD       B,E         ; Shift partial product
 3436 1672 5A                      LD       E,D
 3437 1673 51                      LD       D,C
 3438 1674 4F                      LD       C,A
 3439 1675 C9                      RET
 3440                   ;
 3441 1676 CD5F17       DIV10:     CALL     STAKFP      ; Save FPREG on stack
 3442 1679 012084                  LD       BC,8420H    ; BCDE = 10.
 3443 167C 110000                  LD       DE,0000H
 3444 167F CD6F17                  CALL     FPBCDE      ; Move 10 to FPREG
 3445                   ;
 3446 1682 C1           DIV:       POP      BC          ; Get number from stack
 3447 1683 D1                      POP      DE
 3448 1684 CD2E17       DVBCDE:    CALL     TSTSGN      ; Test sign of FPREG
 3449 1687 CA8A04                  JP       Z,DZERR     ; Error if division by 
 3450 168A 2EFF                    LD       L,-1        ; Flag subtract exponen
 3451 168C CDEC16                  CALL     ADDEXP      ; Subtract exponents
 3452 168F 34                      INC      (HL)        ; Add 2 to exponent to 
 3453 1690 34                      INC      (HL)
 3454 1691 2B                      DEC      HL          ; Point to MSB
 3455 1692 7E                      LD       A,(HL)      ; Get MSB of dividend
 3456 1693 325780                  LD       (DIV3),A    ; Save for subtraction
 3457 1696 2B                      DEC      HL
 3458 1697 7E                      LD       A,(HL)      ; Get NMSB of dividend
 3459 1698 325380                  LD       (DIV2),A    ; Save for subtraction
 3460 169B 2B                      DEC      HL
 3461 169C 7E                      LD       A,(HL)      ; Get MSB of dividend
 3462 169D 324F80                  LD       (DIV1),A    ; Save for subtraction
 3463 16A0 41                      LD       B,C         ; Get MSB
 3464 16A1 EB                      EX       DE,HL       ; NMSB,LSB to HL
 3465 16A2 AF                      XOR      A
 3466 16A3 4F                      LD       C,A         ; Clear MSB of quotient
 3467 16A4 57                      LD       D,A         ; Clear NMSB of quotien
 3468 16A5 5F                      LD       E,A         ; Clear LSB of quotient
 3469 16A6 325A80                  LD       (DIV4),A    ; Clear overflow count
 3470 16A9 E5           DIVLP:     PUSH     HL          ; Save divisor
 3471 16AA C5                      PUSH     BC
 3472 16AB 7D                      LD       A,L         ; Get LSB of number
 3473 16AC CD4E80                  CALL     DIVSUP      ; Subt' divisor from di
 3474 16AF DE00                    SBC      A,0         ; Count for overflows
 3475 16B1 3F                      CCF
 3476 16B2 D2BC16                  JP       NC,RESDIV   ; Restore divisor if bo
 3477 16B5 325A80                  LD       (DIV4),A    ; Re-save overflow coun
 3478 16B8 F1                      POP      AF          ; Scrap divisor
 3479 16B9 F1                      POP      AF
 3480 16BA 37                      SCF                  ; Set carry to
 3481 16BB D2                      DB       0D2H        ; Skip "POP BC" and "PO
 3482                   ;
 3483 16BC C1           RESDIV:    POP      BC          ; Restore divisor
 3484 16BD E1                      POP      HL
 3485 16BE 79                      LD       A,C         ; Get MSB of quotient
 3486 16BF 3C                      INC      A
 3487 16C0 3D                      DEC      A
 3488 16C1 1F                      RRA                  ; Bit 0 to bit 7
 3489 16C2 FA6F15                  JP       M,RONDB     ; Done - Normalise resu
 3490 16C5 17                      RLA                  ; Restore carry
 3491 16C6 7B                      LD       A,E         ; Get LSB of quotient
 3492 16C7 17                      RLA                  ; Double it
 3493 16C8 5F                      LD       E,A         ; Put it back
 3494 16C9 7A                      LD       A,D         ; Get NMSB of quotient
 3495 16CA 17                      RLA                  ; Double it
 3496 16CB 57                      LD       D,A         ; Put it back
 3497 16CC 79                      LD       A,C         ; Get MSB of quotient
 3498 16CD 17                      RLA                  ; Double it
 3499 16CE 4F                      LD       C,A         ; Put it back
 3500 16CF 29                      ADD      HL,HL       ; Double NMSB,LSB of di
 3501 16D0 78                      LD       A,B         ; Get MSB of divisor
 3502 16D1 17                      RLA                  ; Double it
 3503 16D2 47                      LD       B,A         ; Put it back
 3504 16D3 3A5A80                  LD       A,(DIV4)    ; Get VLSB of quotient
 3505 16D6 17                      RLA                  ; Double it
 3506 16D7 325A80                  LD       (DIV4),A    ; Put it back
 3507 16DA 79                      LD       A,C         ; Get MSB of quotient
 3508 16DB B2                      OR       D           ; Merge NMSB
 3509 16DC B3                      OR       E           ; Merge LSB
 3510 16DD C2A916                  JP       NZ,DIVLP    ; Not done - Keep divid
 3511 16E0 E5                      PUSH     HL          ; Save divisor
 3512 16E1 212C81                  LD       HL,FPEXP    ; Point to exponent
 3513 16E4 35                      DEC      (HL)        ; Divide by 2
 3514 16E5 E1                      POP      HL          ; Restore divisor
 3515 16E6 C2A916                  JP       NZ,DIVLP    ; Ok - Keep going
 3516 16E9 C39604                  JP       OVERR       ; Overflow error
 3517                   ;
 3518 16EC 78           ADDEXP:    LD       A,B         ; Get exponent of divid
 3519 16ED B7                      OR       A           ; Test it
 3520 16EE CA1017                  JP       Z,OVTST3    ; Zero - Result zero
 3521 16F1 7D                      LD       A,L         ; Get add/subtract flag
 3522 16F2 212C81                  LD       HL,FPEXP    ; Point to exponent
 3523 16F5 AE                      XOR      (HL)        ; Add or subtract it
 3524 16F6 80                      ADD      A,B         ; Add the other exponen
 3525 16F7 47                      LD       B,A         ; Save new exponent
 3526 16F8 1F                      RRA                  ; Test exponent for ove
 3527 16F9 A8                      XOR      B
 3528 16FA 78                      LD       A,B         ; Get exponent
 3529 16FB F20F17                  JP       P,OVTST2    ; Positive - Test for o
 3530 16FE C680                    ADD      A,80H       ; Add excess 128
 3531 1700 77                      LD       (HL),A      ; Save new exponent
 3532 1701 CA6F16                  JP       Z,POPHRT    ; Zero - Result zero
 3533 1704 CD9417                  CALL     SIGNS       ; Set MSBs and sign of 
 3534 1707 77                      LD       (HL),A      ; Save new exponent
 3535 1708 2B                      DEC      HL          ; Point to MSB
 3536 1709 C9                      RET
 3537                   ;
 3538 170A CD2E17       OVTST1:    CALL     TSTSGN      ; Test sign of FPREG
 3539 170D 2F                      CPL                  ; Invert sign
 3540 170E E1                      POP      HL          ; Clean up stack
 3541 170F B7           OVTST2:    OR       A           ; Test if new exponent 
 3542 1710 E1           OVTST3:    POP      HL          ; Clear off return addr
 3543 1711 F24E15                  JP       P,RESZER    ; Result zero
 3544 1714 C39604                  JP       OVERR       ; Overflow error
 3545                   ;
 3546 1717 CD7A17       MLSP10:    CALL     BCDEFP      ; Move FPREG to BCDE
 3547 171A 78                      LD       A,B         ; Get exponent
 3548 171B B7                      OR       A           ; Is it zero?
 3549 171C C8                      RET      Z           ; Yes - Result is zero
 3550 171D C602                    ADD      A,2         ; Multiply by 4
 3551 171F DA9604                  JP       C,OVERR     ; Overflow - ?OV Error
 3552 1722 47                      LD       B,A         ; Re-save exponent
 3553 1723 CDE814                  CALL     FPADD       ; Add BCDE to FPREG (Ti
 3554 1726 212C81                  LD       HL,FPEXP    ; Point to exponent
 3555 1729 34                      INC      (HL)        ; Double number (Times 
 3556 172A C0                      RET      NZ          ; Ok - Return
 3557 172B C39604                  JP       OVERR       ; Overflow error
 3558                   ;
 3559 172E 3A2C81       TSTSGN:    LD       A,(FPEXP)   ; Get sign of FPREG
 3560 1731 B7                      OR       A
 3561 1732 C8                      RET      Z           ; RETurn if number is z
 3562 1733 3A2B81                  LD       A,(FPREG+2) ; Get MSB of FPREG
 3563 1736 FE                      DB       0FEH        ; Test sign
 3564 1737 2F           RETREL:    CPL                  ; Invert sign
 3565 1738 17                      RLA                  ; Sign bit to carry
 3566 1739 9F           FLGDIF:    SBC      A,A         ; Carry to all bits of 
 3567 173A C0                      RET      NZ          ; Return -1 if negative
 3568 173B 3C                      INC      A           ; Bump to +1
 3569 173C C9                      RET                  ; Positive - Return +1
 3570                   ;
 3571 173D CD2E17       SGN:       CALL     TSTSGN      ; Test sign of FPREG
 3572 1740 0688         FLGREL:    LD       B,80H+8     ; 8 bit integer in expo
 3573 1742 110000                  LD       DE,0        ; Zero NMSB and LSB
 3574 1745 212C81       RETINT:    LD       HL,FPEXP    ; Point to exponent
 3575 1748 4F                      LD       C,A         ; CDE = MSB,NMSB and LS
 3576 1749 70                      LD       (HL),B      ; Save exponent
 3577 174A 0600                    LD       B,0         ; CDE = integer to norm
 3578 174C 23                      INC      HL          ; Point to sign of resu
 3579 174D 3680                    LD       (HL),80H    ; Set sign of result
 3580 174F 17                      RLA                  ; Carry = sign of integ
 3581 1750 C33615                  JP       CONPOS      ; Set sign of result
 3582                   ;
 3583 1753 CD2E17       ABS:       CALL     TSTSGN      ; Test sign of FPREG
 3584 1756 F0                      RET      P           ; Return if positive
 3585 1757 212B81       INVSGN:    LD       HL,FPREG+2  ; Point to MSB
 3586 175A 7E                      LD       A,(HL)      ; Get sign of mantissa
 3587 175B EE80                    XOR      80H         ; Invert sign of mantis
 3588 175D 77                      LD       (HL),A      ; Re-save sign of manti
 3589 175E C9                      RET
 3590                   ;
 3591 175F EB           STAKFP:    EX       DE,HL       ; Save code string addr
 3592 1760 2A2981                  LD       HL,(FPREG)  ; LSB,NLSB of FPREG
 3593 1763 E3                      EX       (SP),HL     ; Stack them,get return
 3594 1764 E5                      PUSH     HL          ; Re-save return
 3595 1765 2A2B81                  LD       HL,(FPREG+2) ; MSB and exponent of 
 3596 1768 E3                      EX       (SP),HL     ; Stack them,get return
 3597 1769 E5                      PUSH     HL          ; Re-save return
 3598 176A EB                      EX       DE,HL       ; Restore code string a
 3599 176B C9                      RET
 3600                   ;
 3601 176C CD7D17       PHLTFP:    CALL     LOADFP      ; Number at HL to BCDE
 3602 176F EB           FPBCDE:    EX       DE,HL       ; Save code string addr
 3603 1770 222981                  LD       (FPREG),HL  ; Save LSB,NLSB of numb
 3604 1773 60                      LD       H,B         ; Exponent of number
 3605 1774 69                      LD       L,C         ; MSB of number
 3606 1775 222B81                  LD       (FPREG+2),HL ; Save MSB and exponen
 3607 1778 EB                      EX       DE,HL       ; Restore code string a
 3608 1779 C9                      RET
 3609                   ;
 3610 177A 212981       BCDEFP:    LD       HL,FPREG    ; Point to FPREG
 3611 177D 5E           LOADFP:    LD       E,(HL)      ; Get LSB of number
 3612 177E 23                      INC      HL
 3613 177F 56                      LD       D,(HL)      ; Get NMSB of number
 3614 1780 23                      INC      HL
 3615 1781 4E                      LD       C,(HL)      ; Get MSB of number
 3616 1782 23                      INC      HL
 3617 1783 46                      LD       B,(HL)      ; Get exponent of numbe
 3618 1784 23           INCHL:     INC      HL          ; Used for conditional 
 3619 1785 C9                      RET
 3620                   ;
 3621 1786 112981       FPTHL:     LD       DE,FPREG    ; Point to FPREG
 3622 1789 0604         DETHL4:    LD       B,4         ; 4 bytes to move
 3623 178B 1A           DETHLB:    LD       A,(DE)      ; Get source
 3624 178C 77                      LD       (HL),A      ; Save destination
 3625 178D 13                      INC      DE          ; Next source
 3626 178E 23                      INC      HL          ; Next destination
 3627 178F 05                      DEC      B           ; Count bytes
 3628 1790 C28B17                  JP       NZ,DETHLB   ; Loop if more
 3629 1793 C9                      RET
 3630                   ;
 3631 1794 212B81       SIGNS:     LD       HL,FPREG+2  ; Point to MSB of FPREG
 3632 1797 7E                      LD       A,(HL)      ; Get MSB
 3633 1798 07                      RLCA                 ; Old sign to carry
 3634 1799 37                      SCF                  ; Set MSBit
 3635 179A 1F                      RRA                  ; Set MSBit of MSB
 3636 179B 77                      LD       (HL),A      ; Save new MSB
 3637 179C 3F                      CCF                  ; Complement sign
 3638 179D 1F                      RRA                  ; Old sign to carry
 3639 179E 23                      INC      HL
 3640 179F 23                      INC      HL
 3641 17A0 77                      LD       (HL),A      ; Set sign of result
 3642 17A1 79                      LD       A,C         ; Get MSB
 3643 17A2 07                      RLCA                 ; Old sign to carry
 3644 17A3 37                      SCF                  ; Set MSBit
 3645 17A4 1F                      RRA                  ; Set MSBit of MSB
 3646 17A5 4F                      LD       C,A         ; Save MSB
 3647 17A6 1F                      RRA
 3648 17A7 AE                      XOR      (HL)        ; New sign of result
 3649 17A8 C9                      RET
 3650                   ;
 3651 17A9 78           CMPNUM:    LD       A,B         ; Get exponent of numbe
 3652 17AA B7                      OR       A
 3653 17AB CA2E17                  JP       Z,TSTSGN    ; Zero - Test sign of F
 3654 17AE 213717                  LD       HL,RETREL   ; Return relation routi
 3655 17B1 E5                      PUSH     HL          ; Save for return
 3656 17B2 CD2E17                  CALL     TSTSGN      ; Test sign of FPREG
 3657 17B5 79                      LD       A,C         ; Get MSB of number
 3658 17B6 C8                      RET      Z           ; FPREG zero - Number's
 3659 17B7 212B81                  LD       HL,FPREG+2  ; MSB of FPREG
 3660 17BA AE                      XOR      (HL)        ; Combine signs
 3661 17BB 79                      LD       A,C         ; Get MSB of number
 3662 17BC F8                      RET      M           ; Exit if signs differe
 3663 17BD CDC317                  CALL     CMPFP       ; Compare FP numbers
 3664 17C0 1F                      RRA                  ; Get carry to sign
 3665 17C1 A9                      XOR      C           ; Combine with MSB of n
 3666 17C2 C9                      RET
 3667                   ;
 3668 17C3 23           CMPFP:     INC      HL          ; Point to exponent
 3669 17C4 78                      LD       A,B         ; Get exponent
 3670 17C5 BE                      CP       (HL)        ; Compare exponents
 3671 17C6 C0                      RET      NZ          ; Different
 3672 17C7 2B                      DEC      HL          ; Point to MBS
 3673 17C8 79                      LD       A,C         ; Get MSB
 3674 17C9 BE                      CP       (HL)        ; Compare MSBs
 3675 17CA C0                      RET      NZ          ; Different
 3676 17CB 2B                      DEC      HL          ; Point to NMSB
 3677 17CC 7A                      LD       A,D         ; Get NMSB
 3678 17CD BE                      CP       (HL)        ; Compare NMSBs
 3679 17CE C0                      RET      NZ          ; Different
 3680 17CF 2B                      DEC      HL          ; Point to LSB
 3681 17D0 7B                      LD       A,E         ; Get LSB
 3682 17D1 96                      SUB      (HL)        ; Compare LSBs
 3683 17D2 C0                      RET      NZ          ; Different
 3684 17D3 E1                      POP      HL          ; Drop RETurn
 3685 17D4 E1                      POP      HL          ; Drop another RETurn
 3686 17D5 C9                      RET
 3687                   ;
 3688 17D6 47           FPINT:     LD       B,A         ; <- Move
 3689 17D7 4F                      LD       C,A         ; <- exponent
 3690 17D8 57                      LD       D,A         ; <- to all
 3691 17D9 5F                      LD       E,A         ; <- bits
 3692 17DA B7                      OR       A           ; Test exponent
 3693 17DB C8                      RET      Z           ; Zero - Return zero
 3694 17DC E5                      PUSH     HL          ; Save pointer to numbe
 3695 17DD CD7A17                  CALL     BCDEFP      ; Move FPREG to BCDE
 3696 17E0 CD9417                  CALL     SIGNS       ; Set MSBs & sign of re
 3697 17E3 AE                      XOR      (HL)        ; Combine with sign of 
 3698 17E4 67                      LD       H,A         ; Save combined signs
 3699 17E5 FCFA17                  CALL     M,DCBCDE    ; Negative - Decrement 
 3700 17E8 3E98                    LD       A,80H+24    ; 24 bits
 3701 17EA 90                      SUB      B           ; Bits to shift
 3702 17EB CDAD15                  CALL     SCALE       ; Shift BCDE
 3703 17EE 7C                      LD       A,H         ; Get combined sign
 3704 17EF 17                      RLA                  ; Sign to carry
 3705 17F0 DC8015                  CALL     C,FPROND    ; Negative - Round numb
 3706 17F3 0600                    LD       B,0         ; Zero exponent
 3707 17F5 DC9915                  CALL     C,COMPL     ; If negative make posi
 3708 17F8 E1                      POP      HL          ; Restore pointer to nu
 3709 17F9 C9                      RET
 3710                   ;
 3711 17FA 1B           DCBCDE:    DEC      DE          ; Decrement BCDE
 3712 17FB 7A                      LD       A,D         ; Test LSBs
 3713 17FC A3                      AND      E
 3714 17FD 3C                      INC      A
 3715 17FE C0                      RET      NZ          ; Exit if LSBs not FFFF
 3716 17FF 0B                      DEC      BC          ; Decrement MSBs
 3717 1800 C9                      RET
 3718                   ;
 3719 1801 212C81       INT:       LD       HL,FPEXP    ; Point to exponent
 3720 1804 7E                      LD       A,(HL)      ; Get exponent
 3721 1805 FE98                    CP       80H+24      ; Integer accuracy only
 3722 1807 3A2981                  LD       A,(FPREG)   ; Get LSB
 3723 180A D0                      RET      NC          ; Yes - Already integer
 3724 180B 7E                      LD       A,(HL)      ; Get exponent
 3725 180C CDD617                  CALL     FPINT       ; F.P to integer
 3726 180F 3698                    LD       (HL),80H+24 ; Save 24 bit integer
 3727 1811 7B                      LD       A,E         ; Get LSB of number
 3728 1812 F5                      PUSH     AF          ; Save LSB
 3729 1813 79                      LD       A,C         ; Get MSB of number
 3730 1814 17                      RLA                  ; Sign to carry
 3731 1815 CD3615                  CALL     CONPOS      ; Set sign of result
 3732 1818 F1                      POP      AF          ; Restore LSB of number
 3733 1819 C9                      RET
 3734                   ;
 3735 181A 210000       MLDEBC:    LD       HL,0        ; Clear partial product
 3736 181D 78                      LD       A,B         ; Test multiplier
 3737 181E B1                      OR       C
 3738 181F C8                      RET      Z           ; Return zero if zero
 3739 1820 3E10                    LD       A,16        ; 16 bits
 3740 1822 29           MLDBLP:    ADD      HL,HL       ; Shift P.P left
 3741 1823 DA5A10                  JP       C,BSERR     ; ?BS Error if overflow
 3742 1826 EB                      EX       DE,HL
 3743 1827 29                      ADD      HL,HL       ; Shift multiplier left
 3744 1828 EB                      EX       DE,HL
 3745 1829 D23018                  JP       NC,NOMLAD   ; Bit was zero - No add
 3746 182C 09                      ADD      HL,BC       ; Add multiplicand
 3747 182D DA5A10                  JP       C,BSERR     ; ?BS Error if overflow
 3748 1830 3D           NOMLAD:    DEC      A           ; Count bits
 3749 1831 C22218                  JP       NZ,MLDBLP   ; More
 3750 1834 C9                      RET
 3751                   ;
 3752 1835 FE2D         ASCTFP:    CP       '-'         ; Negative?
 3753 1837 F5                      PUSH     AF          ; Save it and flags
 3754 1838 CA4118                  JP       Z,CNVNUM    ; Yes - Convert number
 3755 183B FE2B                    CP       '+'         ; Positive?
 3756 183D CA4118                  JP       Z,CNVNUM    ; Yes - Convert number
 3757 1840 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 3758 1841 CD4E15       CNVNUM:    CALL     RESZER      ; Set result to zero
 3759 1844 47                      LD       B,A         ; Digits after point co
 3760 1845 57                      LD       D,A         ; Sign of exponent
 3761 1846 5F                      LD       E,A         ; Exponent of ten
 3762 1847 2F                      CPL
 3763 1848 4F                      LD       C,A         ; Before or after point
 3764 1849 CDDF08       MANLP:     CALL     GETCHR      ; Get next character
 3765 184C DA9218                  JP       C,ADDIG     ; Digit - Add to number
 3766 184F FE2E                    CP       '.'
 3767 1851 CA6D18                  JP       Z,DPOINT    ; '.' - Flag point
 3768 1854 FE45                    CP       'E'
 3769 1856 C27118                  JP       NZ,CONEXP   ; Not 'E' - Scale numbe
 3770 1859 CDDF08                  CALL     GETCHR      ; Get next character
 3771 185C CD850E                  CALL     SGNEXP      ; Get sign of exponent
 3772 185F CDDF08       EXPLP:     CALL     GETCHR      ; Get next character
 3773 1862 DAB418                  JP       C,EDIGIT    ; Digit - Add to expone
 3774 1865 14                      INC      D           ; Is sign negative?
 3775 1866 C27118                  JP       NZ,CONEXP   ; No - Scale number
 3776 1869 AF                      XOR      A
 3777 186A 93                      SUB      E           ; Negate exponent
 3778 186B 5F                      LD       E,A         ; And re-save it
 3779 186C 0C                      INC      C           ; Flag end of number
 3780 186D 0C           DPOINT:    INC      C           ; Flag point passed
 3781 186E CA4918                  JP       Z,MANLP     ; Zero - Get another di
 3782 1871 E5           CONEXP:    PUSH     HL          ; Save code string addr
 3783 1872 7B                      LD       A,E         ; Get exponent
 3784 1873 90                      SUB      B           ; Subtract digits after
 3785 1874 F48A18       SCALMI:    CALL     P,SCALPL    ; Positive - Multiply n
 3786 1877 F28018                  JP       P,ENDCON    ; Positive - All done
 3787 187A F5                      PUSH     AF          ; Save number of times 
 3788 187B CD7616                  CALL     DIV10       ; Divide by 10
 3789 187E F1                      POP      AF          ; Restore count
 3790 187F 3C                      INC      A           ; Count divides
 3791                   ;
 3792 1880 C27418       ENDCON:    JP       NZ,SCALMI   ; More to do
 3793 1883 D1                      POP      DE          ; Restore code string a
 3794 1884 F1                      POP      AF          ; Restore sign of numbe
 3795 1885 CC5717                  CALL     Z,INVSGN    ; Negative - Negate num
 3796 1888 EB                      EX       DE,HL       ; Code string address t
 3797 1889 C9                      RET
 3798                   ;
 3799 188A C8           SCALPL:    RET      Z           ; Exit if no scaling ne
 3800 188B F5           MULTEN:    PUSH     AF          ; Save count
 3801 188C CD1717                  CALL     MLSP10      ; Multiply number by 10
 3802 188F F1                      POP      AF          ; Restore count
 3803 1890 3D                      DEC      A           ; Count multiplies
 3804 1891 C9                      RET
 3805                   ;
 3806 1892 D5           ADDIG:     PUSH     DE          ; Save sign of exponent
 3807 1893 57                      LD       D,A         ; Save digit
 3808 1894 78                      LD       A,B         ; Get digits after poin
 3809 1895 89                      ADC      A,C         ; Add one if after poin
 3810 1896 47                      LD       B,A         ; Re-save counter
 3811 1897 C5                      PUSH     BC          ; Save point flags
 3812 1898 E5                      PUSH     HL          ; Save code string addr
 3813 1899 D5                      PUSH     DE          ; Save digit
 3814 189A CD1717                  CALL     MLSP10      ; Multiply number by 10
 3815 189D F1                      POP      AF          ; Restore digit
 3816 189E D630                    SUB      '0'         ; Make it absolute
 3817 18A0 CDA918                  CALL     RSCALE      ; Re-scale number
 3818 18A3 E1                      POP      HL          ; Restore code string a
 3819 18A4 C1                      POP      BC          ; Restore point flags
 3820 18A5 D1                      POP      DE          ; Restore sign of expon
 3821 18A6 C34918                  JP       MANLP       ; Get another digit
 3822                   ;
 3823 18A9 CD5F17       RSCALE:    CALL     STAKFP      ; Put number on stack
 3824 18AC CD4017                  CALL     FLGREL      ; Digit to add to FPREG
 3825 18AF C1           PADD:      POP      BC          ; Restore number
 3826 18B0 D1                      POP      DE
 3827 18B1 C3E814                  JP       FPADD       ; Add BCDE to FPREG and
 3828                   ;
 3829 18B4 7B           EDIGIT:    LD       A,E         ; Get digit
 3830 18B5 07                      RLCA                 ; Times 2
 3831 18B6 07                      RLCA                 ; Times 4
 3832 18B7 83                      ADD      A,E         ; Times 5
 3833 18B8 07                      RLCA                 ; Times 10
 3834 18B9 86                      ADD      A,(HL)      ; Add next digit
 3835 18BA D630                    SUB      '0'         ; Make it absolute
 3836 18BC 5F                      LD       E,A         ; Save new digit
 3837 18BD C35F18                  JP       EXPLP       ; Look for another digi
 3838                   ;
 3839 18C0 E5           LINEIN:    PUSH     HL          ; Save code string addr
 3840 18C1 211F04                  LD       HL,INMSG    ; Output " in "
 3841 18C4 CD2512                  CALL     PRS         ; Output string at HL
 3842 18C7 E1                      POP      HL          ; Restore code string a
 3843 18C8 EB           PRNTHL:    EX       DE,HL       ; Code string address t
 3844 18C9 AF                      XOR      A
 3845 18CA 0698                    LD       B,80H+24    ; 24 bits
 3846 18CC CD4517                  CALL     RETINT      ; Return the integer
 3847 18CF 212412                  LD       HL,PRNUMS   ; Print number string
 3848 18D2 E5                      PUSH     HL          ; Save for return
 3849 18D3 212E81       NUMASC:    LD       HL,PBUFF    ; Convert number to ASC
 3850 18D6 E5                      PUSH     HL          ; Save for return
 3851 18D7 CD2E17                  CALL     TSTSGN      ; Test sign of FPREG
 3852 18DA 3620                    LD       (HL),' '    ; Space at start
 3853 18DC F2E118                  JP       P,SPCFST    ; Positive - Space to s
 3854 18DF 362D                    LD       (HL),'-'    ; '-' sign at start
 3855 18E1 23           SPCFST:    INC      HL          ; First byte of number
 3856 18E2 3630                    LD       (HL),'0'    ; '0' if zero
 3857 18E4 CA9719                  JP       Z,JSTZER    ; Return '0' if zero
 3858 18E7 E5                      PUSH     HL          ; Save buffer address
 3859 18E8 FC5717                  CALL     M,INVSGN    ; Negate FPREG if negat
 3860 18EB AF                      XOR      A           ; Zero A
 3861 18EC F5                      PUSH     AF          ; Save it
 3862 18ED CD9D19                  CALL     RNGTST      ; Test number is in ran
 3863 18F0 014391       SIXDIG:    LD       BC,9143H    ; BCDE - 99999.9
 3864 18F3 11F84F                  LD       DE,4FF8H
 3865 18F6 CDA917                  CALL     CMPNUM      ; Compare numbers
 3866 18F9 B7                      OR       A
 3867 18FA E20E19                  JP       PO,INRNG    ; > 99999.9 - Sort it o
 3868 18FD F1                      POP      AF          ; Restore count
 3869 18FE CD8B18                  CALL     MULTEN      ; Multiply by ten
 3870 1901 F5                      PUSH     AF          ; Re-save count
 3871 1902 C3F018                  JP       SIXDIG      ; Test it again
 3872                   ;
 3873 1905 CD7616       GTSIXD:    CALL     DIV10       ; Divide by 10
 3874 1908 F1                      POP      AF          ; Get count
 3875 1909 3C                      INC      A           ; Count divides
 3876 190A F5                      PUSH     AF          ; Re-save count
 3877 190B CD9D19                  CALL     RNGTST      ; Test number is in ran
 3878 190E CDD614       INRNG:     CALL     ROUND       ; Add 0.5 to FPREG
 3879 1911 3C                      INC      A
 3880 1912 CDD617                  CALL     FPINT       ; F.P to integer
 3881 1915 CD6F17                  CALL     FPBCDE      ; Move BCDE to FPREG
 3882 1918 010603                  LD       BC,0306H    ; 1E+06 to 1E-03 range
 3883 191B F1                      POP      AF          ; Restore count
 3884 191C 81                      ADD      A,C         ; 6 digits before point
 3885 191D 3C                      INC      A           ; Add one
 3886 191E FA2A19                  JP       M,MAKNUM    ; Do it in 'E' form if 
 3887 1921 FE08                    CP       6+1+1       ; More than 999999 ?
 3888 1923 D22A19                  JP       NC,MAKNUM   ; Yes - Do it in 'E' fo
 3889 1926 3C                      INC      A           ; Adjust for exponent
 3890 1927 47                      LD       B,A         ; Exponent of number
 3891 1928 3E02                    LD       A,2         ; Make it zero after
 3892                   ;
 3893 192A 3D           MAKNUM:    DEC      A           ; Adjust for digits to 
 3894 192B 3D                      DEC      A
 3895 192C E1                      POP      HL          ; Restore buffer addres
 3896 192D F5                      PUSH     AF          ; Save count
 3897 192E 11B019                  LD       DE,POWERS   ; Powers of ten
 3898 1931 05                      DEC      B           ; Count digits before p
 3899 1932 C23B19                  JP       NZ,DIGTXT   ; Not zero - Do number
 3900 1935 362E                    LD       (HL),'.'    ; Save point
 3901 1937 23                      INC      HL          ; Move on
 3902 1938 3630                    LD       (HL),'0'    ; Save zero
 3903 193A 23                      INC      HL          ; Move on
 3904 193B 05           DIGTXT:    DEC      B           ; Count digits before p
 3905 193C 362E                    LD       (HL),'.'    ; Save point in case
 3906 193E CC8417                  CALL     Z,INCHL     ; Last digit - move on
 3907 1941 C5                      PUSH     BC          ; Save digits before po
 3908 1942 E5                      PUSH     HL          ; Save buffer address
 3909 1943 D5                      PUSH     DE          ; Save powers of ten
 3910 1944 CD7A17                  CALL     BCDEFP      ; Move FPREG to BCDE
 3911 1947 E1                      POP      HL          ; Powers of ten table
 3912 1948 062F                    LD       B, '0'-1    ; ASCII '0' - 1
 3913 194A 04           TRYAGN:    INC      B           ; Count subtractions
 3914 194B 7B                      LD       A,E         ; Get LSB
 3915 194C 96                      SUB      (HL)        ; Subtract LSB
 3916 194D 5F                      LD       E,A         ; Save LSB
 3917 194E 23                      INC      HL
 3918 194F 7A                      LD       A,D         ; Get NMSB
 3919 1950 9E                      SBC      A,(HL)      ; Subtract NMSB
 3920 1951 57                      LD       D,A         ; Save NMSB
 3921 1952 23                      INC      HL
 3922 1953 79                      LD       A,C         ; Get MSB
 3923 1954 9E                      SBC      A,(HL)      ; Subtract MSB
 3924 1955 4F                      LD       C,A         ; Save MSB
 3925 1956 2B                      DEC      HL          ; Point back to start
 3926 1957 2B                      DEC      HL
 3927 1958 D24A19                  JP       NC,TRYAGN   ; No overflow - Try aga
 3928 195B CD8D15                  CALL     PLUCDE      ; Restore number
 3929 195E 23                      INC      HL          ; Start of next number
 3930 195F CD6F17                  CALL     FPBCDE      ; Move BCDE to FPREG
 3931 1962 EB                      EX       DE,HL       ; Save point in table
 3932 1963 E1                      POP      HL          ; Restore buffer addres
 3933 1964 70                      LD       (HL),B      ; Save digit in buffer
 3934 1965 23                      INC      HL          ; And move on
 3935 1966 C1                      POP      BC          ; Restore digit count
 3936 1967 0D                      DEC      C           ; Count digits
 3937 1968 C23B19                  JP       NZ,DIGTXT   ; More - Do them
 3938 196B 05                      DEC      B           ; Any decimal part?
 3939 196C CA7B19                  JP       Z,DOEBIT    ; No - Do 'E' bit
 3940 196F 2B           SUPTLZ:    DEC      HL          ; Move back through buf
 3941 1970 7E                      LD       A,(HL)      ; Get character
 3942 1971 FE30                    CP       '0'         ; '0' character?
 3943 1973 CA6F19                  JP       Z,SUPTLZ    ; Yes - Look back for m
 3944 1976 FE2E                    CP       '.'         ; A decimal point?
 3945 1978 C48417                  CALL     NZ,INCHL    ; Move back over digit
 3946                   ;
 3947 197B F1           DOEBIT:    POP      AF          ; Get 'E' flag
 3948 197C CA9A19                  JP       Z,NOENED    ; No 'E' needed - End b
 3949 197F 3645                    LD       (HL),'E'    ; Put 'E' in buffer
 3950 1981 23                      INC      HL          ; And move on
 3951 1982 362B                    LD       (HL),'+'    ; Put '+' in buffer
 3952 1984 F28B19                  JP       P,OUTEXP    ; Positive - Output exp
 3953 1987 362D                    LD       (HL),'-'    ; Put '-' in buffer
 3954 1989 2F                      CPL                  ; Negate exponent
 3955 198A 3C                      INC      A
 3956 198B 062F         OUTEXP:    LD       B,'0'-1     ; ASCII '0' - 1
 3957 198D 04           EXPTEN:    INC      B           ; Count subtractions
 3958 198E D60A                    SUB      10          ; Tens digit
 3959 1990 D28D19                  JP       NC,EXPTEN   ; More to do
 3960 1993 C63A                    ADD      A,'0'+10    ; Restore and make ASCI
 3961 1995 23                      INC      HL          ; Move on
 3962 1996 70                      LD       (HL),B      ; Save MSB of exponent
 3963 1997 23           JSTZER:    INC      HL          ;
 3964 1998 77                      LD       (HL),A      ; Save LSB of exponent
 3965 1999 23                      INC      HL
 3966 199A 71           NOENED:    LD       (HL),C      ; Mark end of buffer
 3967 199B E1                      POP      HL          ; Restore code string a
 3968 199C C9                      RET
 3969                   ;
 3970 199D 017494       RNGTST:    LD       BC,9474H    ; BCDE = 999999.
 3971 19A0 11F723                  LD       DE,23F7H
 3972 19A3 CDA917                  CALL     CMPNUM      ; Compare numbers
 3973 19A6 B7                      OR       A
 3974 19A7 E1                      POP      HL          ; Return address to HL
 3975 19A8 E20519                  JP       PO,GTSIXD   ; Too big - Divide by t
 3976 19AB E9                      JP       (HL)        ; Otherwise return to c
 3977                   ;
 3978 19AC 00000080     HALF:      DB       00H,00H,00H,80H ; 0.5
 3979                   ;
 3980 19B0 A08601       POWERS:    DB       0A0H,086H,001H ; 100000
 3981 19B3 102700                  DB       010H,027H,000H ; 10000
 3982 19B6 E80300                  DB       0E8H,003H,000H ; 1000
 3983 19B9 640000                  DB       064H,000H,000H ; 100
 3984 19BC 0A0000                  DB       00AH,000H,000H ; 10
 3985 19BF 010000                  DB       001H,000H,000H ; 1
 3986                   ;
 3987 19C2 215717       NEGAFT:    LD       HL,INVSGN   ; Negate result
 3988 19C5 E3                      EX       (SP),HL     ; To be done after call
 3989 19C6 E9                      JP       (HL)        ; Return to caller
 3990                   ;
 3991 19C7 CD5F17       SQR:       CALL     STAKFP      ; Put value on stack
 3992 19CA 21AC19                  LD       HL,HALF     ; Set power to 1/2
 3993 19CD CD6C17                  CALL     PHLTFP      ; Move 1/2 to FPREG
 3994                   ;
 3995 19D0 C1           POWER:     POP      BC          ; Get base
 3996 19D1 D1                      POP      DE
 3997 19D2 CD2E17                  CALL     TSTSGN      ; Test sign of power
 3998 19D5 78                      LD       A,B         ; Get exponent of base
 3999 19D6 CA151A                  JP       Z,EXP       ; Make result 1 if zero
 4000 19D9 F2E019                  JP       P,POWER1    ; Positive base - Ok
 4001 19DC B7                      OR       A           ; Zero to negative powe
 4002 19DD CA8A04                  JP       Z,DZERR     ; Yes - ?/0 Error
 4003 19E0 B7           POWER1:    OR       A           ; Base zero?
 4004 19E1 CA4F15                  JP       Z,SAVEXP    ; Yes - Return zero
 4005 19E4 D5                      PUSH     DE          ; Save base
 4006 19E5 C5                      PUSH     BC
 4007 19E6 79                      LD       A,C         ; Get MSB of base
 4008 19E7 F67F                    OR       01111111B   ; Get sign status
 4009 19E9 CD7A17                  CALL     BCDEFP      ; Move power to BCDE
 4010 19EC F2FD19                  JP       P,POWER2    ; Positive base - Ok
 4011 19EF D5                      PUSH     DE          ; Save power
 4012 19F0 C5                      PUSH     BC
 4013 19F1 CD0118                  CALL     INT         ; Get integer of power
 4014 19F4 C1                      POP      BC          ; Restore power
 4015 19F5 D1                      POP      DE
 4016 19F6 F5                      PUSH     AF          ; MSB of base
 4017 19F7 CDA917                  CALL     CMPNUM      ; Power an integer?
 4018 19FA E1                      POP      HL          ; Restore MSB of base
 4019 19FB 7C                      LD       A,H         ; but don't affect flag
 4020 19FC 1F                      RRA                  ; Exponent odd or even?
 4021 19FD E1           POWER2:    POP      HL          ; Restore MSB and expon
 4022 19FE 222B81                  LD       (FPREG+2),HL ; Save base in FPREG
 4023 1A01 E1                      POP      HL          ; LSBs of base
 4024 1A02 222981                  LD       (FPREG),HL  ; Save in FPREG
 4025 1A05 DCC219                  CALL     C,NEGAFT    ; Odd power - Negate re
 4026 1A08 CC5717                  CALL     Z,INVSGN    ; Negative base - Negat
 4027 1A0B D5                      PUSH     DE          ; Save power
 4028 1A0C C5                      PUSH     BC
 4029 1A0D CDE215                  CALL     LOG         ; Get LOG of base
 4030 1A10 C1                      POP      BC          ; Restore power
 4031 1A11 D1                      POP      DE
 4032 1A12 CD2316                  CALL     FPMULT      ; Multiply LOG by power
 4033                   ;
 4034 1A15 CD5F17       EXP:       CALL     STAKFP      ; Put value on stack
 4035 1A18 013881                  LD       BC,08138H   ; BCDE = 1/Ln(2)
 4036 1A1B 113BAA                  LD       DE,0AA3BH
 4037 1A1E CD2316                  CALL     FPMULT      ; Multiply value by 1/L
 4038 1A21 3A2C81                  LD       A,(FPEXP)   ; Get exponent
 4039 1A24 FE88                    CP       80H+8       ; Is it in range?
 4040 1A26 D20A17                  JP       NC,OVTST1   ; No - Test for overflo
 4041 1A29 CD0118                  CALL     INT         ; Get INT of FPREG
 4042 1A2C C680                    ADD      A,80H       ; For excess 128
 4043 1A2E C602                    ADD      A,2         ; Exponent > 126?
 4044 1A30 DA0A17                  JP       C,OVTST1    ; Yes - Test for overfl
 4045 1A33 F5                      PUSH     AF          ; Save scaling factor
 4046 1A34 21D115                  LD       HL,UNITY    ; Point to 1.
 4047 1A37 CDD914                  CALL     ADDPHL      ; Add 1 to FPREG
 4048 1A3A CD1A16                  CALL     MULLN2      ; Multiply by LN(2)
 4049 1A3D F1                      POP      AF          ; Restore scaling facto
 4050 1A3E C1                      POP      BC          ; Restore exponent
 4051 1A3F D1                      POP      DE
 4052 1A40 F5                      PUSH     AF          ; Save scaling factor
 4053 1A41 CDE514                  CALL     SUBCDE      ; Subtract exponent fro
 4054 1A44 CD5717                  CALL     INVSGN      ; Negate result
 4055 1A47 21551A                  LD       HL,EXPTAB   ; Coefficient table
 4056 1A4A CD851A                  CALL     SMSER1      ; Sum the series
 4057 1A4D 110000                  LD       DE,0        ; Zero LSBs
 4058 1A50 C1                      POP      BC          ; Scaling factor
 4059 1A51 4A                      LD       C,D         ; Zero MSB
 4060 1A52 C32316                  JP       FPMULT      ; Scale result to corre
 4061                   ;
 4062 1A55 08           EXPTAB:    DB       8           ; Table used by EXP
 4063 1A56 402E9474                DB       040H,02EH,094H,074H ; -1/7! (-1/504
 4064 1A5A 704F2E77                DB       070H,04FH,02EH,077H ;  1/6! ( 1/720
 4065 1A5E 6E02887A                DB       06EH,002H,088H,07AH ; -1/5! (-1/120
 4066 1A62 E6A02A7C                DB       0E6H,0A0H,02AH,07CH ;  1/4! ( 1/24)
 4067 1A66 50AAAA7E                DB       050H,0AAH,0AAH,07EH ; -1/3! (-1/6)
 4068 1A6A FFFF7F7F                DB       0FFH,0FFH,07FH,07FH ;  1/2! ( 1/2)
 4069 1A6E 00008081                DB       000H,000H,080H,081H ; -1/1! (-1/1)
 4070 1A72 00000081                DB       000H,000H,000H,081H ;  1/0! ( 1/1)
 4071                   ;
 4072 1A76 CD5F17       SUMSER:    CALL     STAKFP      ; Put FPREG on stack
 4073 1A79 112116                  LD       DE,MULT     ; Multiply by "X"
 4074 1A7C D5                      PUSH     DE          ; To be done after
 4075 1A7D E5                      PUSH     HL          ; Save address of table
 4076 1A7E CD7A17                  CALL     BCDEFP      ; Move FPREG to BCDE
 4077 1A81 CD2316                  CALL     FPMULT      ; Square the value
 4078 1A84 E1                      POP      HL          ; Restore address of ta
 4079 1A85 CD5F17       SMSER1:    CALL     STAKFP      ; Put value on stack
 4080 1A88 7E                      LD       A,(HL)      ; Get number of coeffic
 4081 1A89 23                      INC      HL          ; Point to start of tab
 4082 1A8A CD6C17                  CALL     PHLTFP      ; Move coefficient to F
 4083 1A8D 06                      DB       06H         ; Skip "POP AF"
 4084 1A8E F1           SUMLP:     POP      AF          ; Restore count
 4085 1A8F C1                      POP      BC          ; Restore number
 4086 1A90 D1                      POP      DE
 4087 1A91 3D                      DEC      A           ; Cont coefficients
 4088 1A92 C8                      RET      Z           ; All done
 4089 1A93 D5                      PUSH     DE          ; Save number
 4090 1A94 C5                      PUSH     BC
 4091 1A95 F5                      PUSH     AF          ; Save count
 4092 1A96 E5                      PUSH     HL          ; Save address in table
 4093 1A97 CD2316                  CALL     FPMULT      ; Multiply FPREG by BCD
 4094 1A9A E1                      POP      HL          ; Restore address in ta
 4095 1A9B CD7D17                  CALL     LOADFP      ; Number at HL to BCDE
 4096 1A9E E5                      PUSH     HL          ; Save address in table
 4097 1A9F CDE814                  CALL     FPADD       ; Add coefficient to FP
 4098 1AA2 E1                      POP      HL          ; Restore address in ta
 4099 1AA3 C38E1A                  JP       SUMLP       ; More coefficients
 4100                   ;
 4101 1AA6 CD2E17       RND:       CALL     TSTSGN      ; Test sign of FPREG
 4102 1AA9 215E80                  LD       HL,SEED+2   ; Random number seed
 4103 1AAC FA071B                  JP       M,RESEED    ; Negative - Re-seed
 4104 1AAF 217F80                  LD       HL,LSTRND   ; Last random number
 4105 1AB2 CD6C17                  CALL     PHLTFP      ; Move last RND to FPRE
 4106 1AB5 215E80                  LD       HL,SEED+2   ; Random number seed
 4107 1AB8 C8                      RET      Z           ; Return if RND(0)
 4108 1AB9 86                      ADD      A,(HL)      ; Add (SEED)+2)
 4109 1ABA E607                    AND      00000111B   ; 0 to 7
 4110 1ABC 0600                    LD       B,0
 4111 1ABE 77                      LD       (HL),A      ; Re-save seed
 4112 1ABF 23                      INC      HL          ; Move to coefficient t
 4113 1AC0 87                      ADD      A,A         ; 4 bytes
 4114 1AC1 87                      ADD      A,A         ; per entry
 4115 1AC2 4F                      LD       C,A         ; BC = Offset into tabl
 4116 1AC3 09                      ADD      HL,BC       ; Point to coefficient
 4117 1AC4 CD7D17                  CALL     LOADFP      ; Coefficient to BCDE
 4118 1AC7 CD2316                  CALL     FPMULT      ;       ; Multiply FPRE
 4119 1ACA 3A5D80                  LD       A,(SEED+1)  ; Get (SEED+1)
 4120 1ACD 3C                      INC      A           ; Add 1
 4121 1ACE E603                    AND      00000011B   ; 0 to 3
 4122 1AD0 0600                    LD       B,0
 4123 1AD2 FE01                    CP       1           ; Is it zero?
 4124 1AD4 88                      ADC      A,B         ; Yes - Make it 1
 4125 1AD5 325D80                  LD       (SEED+1),A  ; Re-save seed
 4126 1AD8 210B1B                  LD       HL,RNDTAB-4 ; Addition table
 4127 1ADB 87                      ADD      A,A         ; 4 bytes
 4128 1ADC 87                      ADD      A,A         ; per entry
 4129 1ADD 4F                      LD       C,A         ; BC = Offset into tabl
 4130 1ADE 09                      ADD      HL,BC       ; Point to value
 4131 1ADF CDD914                  CALL     ADDPHL      ; Add value to FPREG
 4132 1AE2 CD7A17       RND1:      CALL     BCDEFP      ; Move FPREG to BCDE
 4133 1AE5 7B                      LD       A,E         ; Get LSB
 4134 1AE6 59                      LD       E,C         ; LSB = MSB
 4135 1AE7 EE4F                    XOR      01001111B   ; Fiddle around
 4136 1AE9 4F                      LD       C,A         ; New MSB
 4137 1AEA 3680                    LD       (HL),80H    ; Set exponent
 4138 1AEC 2B                      DEC      HL          ; Point to MSB
 4139 1AED 46                      LD       B,(HL)      ; Get MSB
 4140 1AEE 3680                    LD       (HL),80H    ; Make value -0.5
 4141 1AF0 215C80                  LD       HL,SEED     ; Random number seed
 4142 1AF3 34                      INC      (HL)        ; Count seed
 4143 1AF4 7E                      LD       A,(HL)      ; Get seed
 4144 1AF5 D6AB                    SUB      171         ; Do it modulo 171
 4145 1AF7 C2FE1A                  JP       NZ,RND2     ; Non-zero - Ok
 4146 1AFA 77                      LD       (HL),A      ; Zero seed
 4147 1AFB 0C                      INC      C           ; Fillde about
 4148 1AFC 15                      DEC      D           ; with the
 4149 1AFD 1C                      INC      E           ; number
 4150 1AFE CD3915       RND2:      CALL     BNORM       ; Normalise number
 4151 1B01 217F80                  LD       HL,LSTRND   ; Save random number
 4152 1B04 C38617                  JP       FPTHL       ; Move FPREG to last an
 4153                   ;
 4154 1B07 77           RESEED:    LD       (HL),A      ; Re-seed random number
 4155 1B08 2B                      DEC      HL
 4156 1B09 77                      LD       (HL),A
 4157 1B0A 2B                      DEC      HL
 4158 1B0B 77                      LD       (HL),A
 4159 1B0C C3E21A                  JP       RND1        ; Return RND seed
 4160                   ;
 4161 1B0F 68B14668     RNDTAB:    DB       068H,0B1H,046H,068H ; Table used by
 4162 1B13 99E99269                DB       099H,0E9H,092H,069H
 4163 1B17 10D17568                DB       010H,0D1H,075H,068H
 4164                   ;
 4165 1B1B 21651B       COS:       LD       HL,HALFPI   ; Point to PI/2
 4166 1B1E CDD914                  CALL     ADDPHL      ; Add it to PPREG
 4167 1B21 CD5F17       SIN:       CALL     STAKFP      ; Put angle on stack
 4168 1B24 014983                  LD       BC,8349H    ; BCDE = 2 PI
 4169 1B27 11DB0F                  LD       DE,0FDBH
 4170 1B2A CD6F17                  CALL     FPBCDE      ; Move 2 PI to FPREG
 4171 1B2D C1                      POP      BC          ; Restore angle
 4172 1B2E D1                      POP      DE
 4173 1B2F CD8416                  CALL     DVBCDE      ; Divide angle by 2 PI
 4174 1B32 CD5F17                  CALL     STAKFP      ; Put it on stack
 4175 1B35 CD0118                  CALL     INT         ; Get INT of result
 4176 1B38 C1                      POP      BC          ; Restore number
 4177 1B39 D1                      POP      DE
 4178 1B3A CDE514                  CALL     SUBCDE      ; Make it 0 <= value < 
 4179 1B3D 21691B                  LD       HL,QUARTR   ; Point to 0.25
 4180 1B40 CDDF14                  CALL     SUBPHL      ; Subtract value from 0
 4181 1B43 CD2E17                  CALL     TSTSGN      ; Test sign of value
 4182 1B46 37                      SCF                  ; Flag positive
 4183 1B47 F2511B                  JP       P,SIN1      ; Positive - Ok
 4184 1B4A CDD614                  CALL     ROUND       ; Add 0.5 to value
 4185 1B4D CD2E17                  CALL     TSTSGN      ; Test sign of value
 4186 1B50 B7                      OR       A           ; Flag negative
 4187 1B51 F5           SIN1:      PUSH     AF          ; Save sign
 4188 1B52 F45717                  CALL     P,INVSGN    ; Negate value if posit
 4189 1B55 21691B                  LD       HL,QUARTR   ; Point to 0.25
 4190 1B58 CDD914                  CALL     ADDPHL      ; Add 0.25 to value
 4191 1B5B F1                      POP      AF          ; Restore sign
 4192 1B5C D45717                  CALL     NC,INVSGN   ; Negative - Make posit
 4193 1B5F 216D1B                  LD       HL,SINTAB   ; Coefficient table
 4194 1B62 C3761A                  JP       SUMSER      ; Evaluate sum of serie
 4195                   ;
 4196 1B65 DB0F4981     HALFPI:    DB       0DBH,00FH,049H,081H ; 1.5708 (PI/2)
 4197                   ;
 4198 1B69 0000007F     QUARTR:    DB       000H,000H,000H,07FH ; 0.25
 4199                   ;
 4200 1B6D 05           SINTAB:    DB       5           ; Table used by SIN
 4201 1B6E BAD71E86                DB       0BAH,0D7H,01EH,086H ; 39.711
 4202 1B72 64269987                DB       064H,026H,099H,087H ;-76.575
 4203 1B76 58342387                DB       058H,034H,023H,087H ; 81.602
 4204 1B7A E05DA586                DB       0E0H,05DH,0A5H,086H ;-41.342
 4205 1B7E DA0F4983                DB       0DAH,00FH,049H,083H ; 6.2832
 4206                   ;
 4207 1B82 CD5F17       TAN:       CALL     STAKFP      ; Put angle on stack
 4208 1B85 CD211B                  CALL     SIN         ; Get SIN of angle
 4209 1B88 C1                      POP      BC          ; Restore angle
 4210 1B89 E1                      POP      HL
 4211 1B8A CD5F17                  CALL     STAKFP      ; Save SIN of angle
 4212 1B8D EB                      EX       DE,HL       ; BCDE = Angle
 4213 1B8E CD6F17                  CALL     FPBCDE      ; Angle to FPREG
 4214 1B91 CD1B1B                  CALL     COS         ; Get COS of angle
 4215 1B94 C38216                  JP       DIV         ; TAN = SIN / COS
 4216                   ;
 4217 1B97 CD2E17       ATN:       CALL     TSTSGN      ; Test sign of value
 4218 1B9A FCC219                  CALL     M,NEGAFT    ; Negate result after i
 4219 1B9D FC5717                  CALL     M,INVSGN    ; Negate value if -ve
 4220 1BA0 3A2C81                  LD       A,(FPEXP)   ; Get exponent
 4221 1BA3 FE81                    CP       81H         ; Number less than 1?
 4222 1BA5 DAB41B                  JP       C,ATN1      ; Yes - Get arc tangnt
 4223 1BA8 010081                  LD       BC,8100H    ; BCDE = 1
 4224 1BAB 51                      LD       D,C
 4225 1BAC 59                      LD       E,C
 4226 1BAD CD8416                  CALL     DVBCDE      ; Get reciprocal of num
 4227 1BB0 21DF14                  LD       HL,SUBPHL   ; Sub angle from PI/2
 4228 1BB3 E5                      PUSH     HL          ; Save for angle > 1
 4229 1BB4 21BE1B       ATN1:      LD       HL,ATNTAB   ; Coefficient table
 4230 1BB7 CD761A                  CALL     SUMSER      ; Evaluate sum of serie
 4231 1BBA 21651B                  LD       HL,HALFPI   ; PI/2 - angle in case 
 4232 1BBD C9                      RET                  ; Number > 1 - Sub from
 4233                   ;
 4234 1BBE 09           ATNTAB:    DB       9           ; Table used by ATN
 4235 1BBF 4AD73B78                DB       04AH,0D7H,03BH,078H ; 1/17
 4236 1BC3 026E847B                DB       002H,06EH,084H,07BH ;-1/15
 4237 1BC7 FEC12F7C                DB       0FEH,0C1H,02FH,07CH ; 1/13
 4238 1BCB 74319A7D                DB       074H,031H,09AH,07DH ;-1/11
 4239 1BCF 843D5A7D                DB       084H,03DH,05AH,07DH ; 1/9
 4240 1BD3 C87F917E                DB       0C8H,07FH,091H,07EH ;-1/7
 4241 1BD7 E4BB4C7E                DB       0E4H,0BBH,04CH,07EH ; 1/5
 4242 1BDB 6CAAAA7F                DB       06CH,0AAH,0AAH,07FH ;-1/3
 4243 1BDF 00000081                DB       000H,000H,000H,081H ; 1/1
 4244                   ;
 4245                   
 4246 1BE3 C9           ARET:      RET                  ; A RETurn instruction
 4247                   ;
 4248 1BE4 D7           GETINP:    RST      10H         ;input a character
 4249 1BE5 C9                      RET
 4250                   ;
 4251 1BE6              CLS:
 4252 1BE6 3E0C                    LD       A,CS        ; ASCII Clear screen
 4253 1BE8 C31C1D                  JP       MONOUT      ; Output character
 4254                   ;
 4255 1BEB CDAD14       WIDTH:     CALL     GETINT      ; Get integer 0-255
 4256 1BEE 7B                      LD       A,E         ; Width to A
 4257 1BEF 328780                  LD       (LWIDTH),A  ; Set width
 4258 1BF2 C9                      RET
 4259                   ;
 4260 1BF3 CD4C0D       LINES:     CALL     GETNUM      ; Get a number
 4261 1BF6 CD9109                  CALL     DEINT       ; Get integer -32768 to
 4262 1BF9 ED538B80                LD       (LINESC),DE ; Set lines counter
 4263 1BFD ED538D80                LD       (LINESN),DE ; Set lines number
 4264 1C01 C9                      RET
 4265                   ;
 4266 1C02 CD9109       DEEK:      CALL     DEINT       ; Get integer -32768 to
 4267 1C05 D5                      PUSH     DE          ; Save number
 4268 1C06 E1                      POP      HL          ; Number to HL
 4269 1C07 46                      LD       B,(HL)      ; Get LSB of contents
 4270 1C08 23                      INC      HL
 4271 1C09 7E                      LD       A,(HL)      ; Get MSB of contents
 4272 1C0A C30711                  JP       ABPASS      ; Return integer AB
 4273                   ;
 4274 1C0D CD4C0D       DOKE:      CALL     GETNUM      ; Get a number
 4275 1C10 CD9109                  CALL     DEINT       ; Get integer -32768 to
 4276 1C13 D5                      PUSH     DE          ; Save address
 4277 1C14 CD5507                  CALL     CHKSYN      ; Make sure ',' follows
 4278 1C17 2C                      DB       ','
 4279 1C18 CD4C0D                  CALL     GETNUM      ; Get a number
 4280 1C1B CD9109                  CALL     DEINT       ; Get integer -32768 to
 4281 1C1E E3                      EX       (SP),HL     ; Save value,get addres
 4282 1C1F 73                      LD       (HL),E      ; Save LSB of value
 4283 1C20 23                      INC      HL
 4284 1C21 72                      LD       (HL),D      ; Save MSB of value
 4285 1C22 E1                      POP      HL          ; Restore code string a
 4286 1C23 C9                      RET
 4287                   ;
 4288                   
 4289                   ; HEX$(nn) Convert 16 bit number to Hexadecimal string
 4290                   ;
 4291 1C24 CD4F0D       HEX:       CALL     TSTNUM      ; Verify it's a number
 4292 1C27 CD9109                  CALL     DEINT       ; Get integer -32768 to
 4293 1C2A C5                      PUSH     BC          ; Save contents of BC
 4294 1C2B 212E81                  LD       HL,PBUFF
 4295 1C2E 7A                      LD       A,D         ; Get high order into A
 4296 1C2F FE00                    CP       0
 4297 1C31 280C                    JR       Z,HEX2      ; Skip output if both h
 4298 1C33 CD5C1C                  CALL     BYT2ASC     ; Convert D to ASCII
 4299 1C36 78                      LD       A,B
 4300 1C37 FE30                    CP       '0'
 4301 1C39 2802                    JR       Z,HEX1      ; Don't store high digi
 4302 1C3B 70                      LD       (HL),B      ; Store it to PBUFF
 4303 1C3C 23                      INC      HL          ; Next location
 4304 1C3D 71           HEX1:      LD       (HL),C      ; Store C to PBUFF+1
 4305 1C3E 23                      INC      HL          ; Next location
 4306 1C3F 7B           HEX2:      LD       A,E         ; Get lower byte
 4307 1C40 CD5C1C                  CALL     BYT2ASC     ; Convert E to ASCII
 4308 1C43 7A                      LD       A,D
 4309 1C44 FE00                    CP       0
 4310 1C46 2005                    JR       NZ,HEX3     ; If upper byte was not
 4311 1C48 78                      LD       A,B
 4312 1C49 FE30                    CP       '0'         ; If high digit of lowe
 4313 1C4B 2802                    JR       Z,HEX4
 4314 1C4D 70           HEX3:      LD       (HL),B      ; to PBUFF+2
 4315 1C4E 23                      INC      HL          ; Next location
 4316 1C4F 71           HEX4:      LD       (HL),C      ; to PBUFF+3
 4317 1C50 23                      INC      HL          ; PBUFF+4 to zero
 4318 1C51 AF                      XOR      A           ; Terminating character
 4319 1C52 77                      LD       (HL),A      ; Store zero to termina
 4320 1C53 23                      INC      HL          ; Make sure PBUFF is te
 4321 1C54 77                      LD       (HL),A      ; Store the double zero
 4322 1C55 C1                      POP      BC          ; Get BC back
 4323 1C56 212E81                  LD       HL,PBUFF    ; Reset to start of PBU
 4324 1C59 C3B511                  JP       STR1        ; Convert the PBUFF to 
 4325                   ;
 4326 1C5C 47           BYT2ASC    LD       B,A         ; Save original value
 4327 1C5D E60F                    AND      0FH         ; Strip off upper nybbl
 4328 1C5F FE0A                    CP       0AH         ; 0-9?
 4329 1C61 3802                    JR       C,ADD30     ; If A-F, add 7 more
 4330 1C63 C607                    ADD      A,07H       ; Bring value up to ASC
 4331 1C65 C630         ADD30      ADD      A,30H       ; And make ASCII
 4332 1C67 4F                      LD       C,A         ; Save converted char t
 4333 1C68 78                      LD       A,B         ; Retrieve original val
 4334 1C69 0F                      RRCA                 ; and Rotate it right
 4335 1C6A 0F                      RRCA
 4336 1C6B 0F                      RRCA
 4337 1C6C 0F                      RRCA
 4338 1C6D E60F                    AND      0FH         ; Mask off upper nybble
 4339 1C6F FE0A                    CP       0AH         ; 0-9? < A hex?
 4340 1C71 3802                    JR       C,ADD301    ; Skip Add 7
 4341 1C73 C607                    ADD      A,07H       ; Bring it up to ASCII 
 4342 1C75 C630         ADD301     ADD      A,30H       ; And make it full ASCI
 4343 1C77 47                      LD       B,A         ; Store high order byte
 4344 1C78 C9                      RET
 4345                   ;
 4346                   ; Convert "&Hnnnn" to FPREG
 4347                   ; Gets a character from (HL) checks for Hexadecimal ASC
 4348                   ; Char is in A, NC if char is;<=>?@ A-z, CY is set if 0
 4349 1C79 EB           HEXTFP     EX       DE,HL       ; Move code string poin
 4350 1C7A 210000                  LD       HL,0000H    ; Zero out the value
 4351 1C7D CD921C                  CALL     GETHEX      ; Check the number for 
 4352 1C80 DAB21C                  JP       C,HXERR     ; First value wasn't he
 4353 1C83 1805                    JR       HEXLP1      ; Convert first charact
 4354 1C85 CD921C       HEXLP      CALL     GETHEX      ; Get second and addtio
 4355 1C88 381F                    JR       C,HEXIT     ; Exit if not a hex cha
 4356 1C8A 29           HEXLP1     ADD      HL,HL       ; Rotate 4 bits to the 
 4357 1C8B 29                      ADD      HL,HL
 4358 1C8C 29                      ADD      HL,HL
 4359 1C8D 29                      ADD      HL,HL
 4360 1C8E B5                      OR       L           ; Add in D0-D3 into L
 4361 1C8F 6F                      LD       L,A         ; Save new value
 4362 1C90 18F3                    JR       HEXLP       ; And continue until al
 4363                   ;
 4364 1C92 13           GETHEX     INC      DE          ; Next location
 4365 1C93 1A                      LD       A,(DE)      ; Load character at poi
 4366 1C94 FE20                    CP       ' '
 4367 1C96 CA921C                  JP       Z,GETHEX    ; Skip spaces
 4368 1C99 D630                    SUB      30H         ; Get absolute value
 4369 1C9B D8                      RET      C           ; < "0", error
 4370 1C9C FE0A                    CP       0AH
 4371 1C9E 3805                    JR       C,NOSUB7    ; Is already in the ran
 4372 1CA0 D607                    SUB      07H         ; Reduce to A-F
 4373 1CA2 FE0A                    CP       0AH         ; Value should be $0A-$
 4374 1CA4 D8                      RET      C           ; CY set if was :      
 4375 1CA5 FE10         NOSUB7     CP       10H         ; > Greater than "F"?
 4376 1CA7 3F                      CCF
 4377 1CA8 C9                      RET                  ; CY set if it wasn't v
 4378                   
 4379 1CA9 EB           HEXIT      EX       DE,HL       ; Value into DE, Code s
 4380 1CAA 7A                      LD       A,D         ; Load DE into AC
 4381 1CAB 4B                      LD       C,E         ; For prep to
 4382 1CAC E5                      PUSH     HL
 4383 1CAD CD0611                  CALL     ACPASS      ; ACPASS to set AC as i
 4384 1CB0 E1                      POP      HL
 4385 1CB1 C9                      RET
 4386                   ;
 4387 1CB2 1E26         HXERR:     LD       E,HX        ; ?HEX Error
 4388 1CB4 C39B04                  JP       ERROR
 4389                   ;
 4390                   ; BIN$(NN) Convert integer to a 1-16 char binary string
 4391 1CB7 CD4F0D       BIN:       CALL     TSTNUM      ; Verify it's a number
 4392 1CBA CD9109                  CALL     DEINT       ; Get integer -32768 to
 4393 1CBD C5           BIN2:      PUSH     BC          ; Save contents of BC
 4394 1CBE 212E81                  LD       HL,PBUFF
 4395 1CC1 0611                    LD       B,17        ; One higher than max c
 4396 1CC3              ZEROSUP:                        ; Suppress leading zero
 4397 1CC3 05                      DEC      B           ; Max 16 chars
 4398 1CC4 78                      LD       A,B
 4399 1CC5 FE01                    CP       01H
 4400 1CC7 2808                    JR       Z,BITOUT    ; Always output at leas
 4401 1CC9 CB13                    RL       E
 4402 1CCB CB12                    RL       D
 4403 1CCD 30F4                    JR       NC,ZEROSUP
 4404 1CCF 1804                    JR       BITOUT2
 4405 1CD1              BITOUT:
 4406 1CD1 CB13                    RL       E
 4407 1CD3 CB12                    RL       D           ; Top bit now in carry
 4408 1CD5              BITOUT2:
 4409 1CD5 3E30                    LD       A,'0'       ; Char for '0'
 4410 1CD7 CE00                    ADC      A,0         ; If carry set then '0'
 4411 1CD9 77                      LD       (HL),A
 4412 1CDA 23                      INC      HL
 4413 1CDB 05                      DEC      B
 4414 1CDC 20F3                    JR       NZ,BITOUT
 4415 1CDE AF                      XOR      A           ; Terminating character
 4416 1CDF 77                      LD       (HL),A      ; Store zero to termina
 4417 1CE0 23                      INC      HL          ; Make sure PBUFF is te
 4418 1CE1 77                      LD       (HL),A      ; Store the double zero
 4419 1CE2 C1                      POP      BC
 4420 1CE3 212E81                  LD       HL,PBUFF
 4421 1CE6 C3B511                  JP       STR1
 4422                   ;
 4423                   ; Convert "&Bnnnn" to FPREG
 4424                   ; Gets a character from (HL) checks for Binary ASCII nu
 4425 1CE9 EB           BINTFP:    EX       DE,HL       ; Move code string poin
 4426 1CEA 210000                  LD       HL,0000H    ; Zero out the value
 4427 1CED CD061D                  CALL     CHKBIN      ; Check the number for 
 4428 1CF0 DA141D                  JP       C,BINERR    ; First value wasn't bi
 4429 1CF3 D630         BINIT:     SUB      '0'
 4430 1CF5 29                      ADD      HL,HL       ; Rotate HL left
 4431 1CF6 B5                      OR       L
 4432 1CF7 6F                      LD       L,A
 4433 1CF8 CD061D                  CALL     CHKBIN      ; Get second and addtio
 4434 1CFB 30F6                    JR       NC,BINIT    ; Process if a bin char
 4435 1CFD EB                      EX       DE,HL       ; Value into DE, Code s
 4436 1CFE 7A                      LD       A,D         ; Load DE into AC
 4437 1CFF 4B                      LD       C,E         ; For prep to
 4438 1D00 E5                      PUSH     HL
 4439 1D01 CD0611                  CALL     ACPASS      ; ACPASS to set AC as i
 4440 1D04 E1                      POP      HL
 4441 1D05 C9                      RET
 4442                   ;
 4443                   ; Char is in A, NC if char is 0 or 1
 4444 1D06 13           CHKBIN:    INC      DE
 4445 1D07 1A                      LD       A,(DE)
 4446 1D08 FE20                    CP       ' '
 4447 1D0A CA061D                  JP       Z,CHKBIN    ; Skip spaces
 4448 1D0D FE30                    CP       '0'         ; Set C if < '0'
 4449 1D0F D8                      RET      C
 4450 1D10 FE32                    CP       '2'
 4451 1D12 3F                      CCF                  ; Set C if > '1'
 4452 1D13 C9                      RET
 4453                   ;
 4454 1D14 1E28         BINERR:    LD       E,BN        ; ?BIN Error
 4455 1D16 C39B04                  JP       ERROR
 4456                   ;
 4457 1D19 C3E000       JJUMP1:    JP       CSTART      ; Go and initialise
 4458                   ;
 4459 1D1C C30800       MONOUT:    JP       0008H       ; output a char
 4460                   ;
 4461 1D1F C30000       MONITR:    JP       0000H       ; Restart (Normally Mon
 4462                   ;
 4463 1D22 3E00         INITST:    LD       A,0         ; Clear break flag
 4464 1D24 329280                  LD       (BRKFLG),A
 4465 1D27 C3E700                  JP       INIT
 4466                   ;
 4467 1D2A F5           TSTBIT:    PUSH     AF          ; Save bit mask
 4468 1D2B A0                      AND      B           ; Get common bits
 4469 1D2C C1                      POP      BC          ; Restore bit mask
 4470 1D2D B8                      CP       B           ; Same bit set?
 4471 1D2E 3E00                    LD       A,0         ; Return 0 in A
 4472 1D30 C9                      RET
 4473                   ;
 4474 1D31 CD6007       OUTNCR:    CALL     OUTC        ; Output character in A
 4475 1D34 C3870B                  JP       PRCRLF      ; Output CRLF
 4476                   ;
 4477 1D37                         END
